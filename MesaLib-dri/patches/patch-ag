$NetBSD: patch-ag,v 1.5 2007/07/24 19:30:12 bsadewitz Exp $

--- src/mesa/main/image.c.orig	2007-06-21 18:10:54.000000000 -0400
+++ src/mesa/main/image.c
@@ -1,6 +1,6 @@
 /*
  * Mesa 3-D graphics library
- * Version:  7.0
+ * Version:  7.1
  *
  * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
  *
@@ -3878,10 +3878,20 @@ _mesa_pack_stencil_span( const GLcontext
                     SWAP4BYTE(value);                                   \
                 }                                                       \
             }                                                           \
-            depthValues[i] = CLAMP(GLTYPE2FLOAT(value), 0.0F, 1.0F);    \
+            depthValues[i] = GLTYPE2FLOAT(value);                       \
         }                                                               \
     } while (0)
 
+
+/**
+ * Unpack a row of depth/z values from memory, returning GLushort, GLuint
+ * or GLfloat values.
+ * The glPixelTransfer (scale/bias) params will be applied.
+ *
+ * \param dstType  one of GL_UNSIGNED_SHORT, GL_UNSIGNED_INT, GL_FLOAT
+ * \param depthScale  scale factor (max value) for returned GLushort or
+ *                    GLuint values (ignored for GLfloat).
+ */
 void
 _mesa_unpack_depth_span( const GLcontext *ctx, GLuint n,
                          GLenum dstType, GLvoid *dest, GLfloat depthScale,
@@ -3889,6 +3899,7 @@ _mesa_unpack_depth_span( const GLcontext
                          const struct gl_pixelstore_attrib *srcPacking )
 {
    GLfloat depthTemp[MAX_WIDTH], *depthValues;
+   GLboolean needClamp = GL_FALSE;
 
    /* Look for special cases first.
     * Not only are these faster, they're less prone to numeric conversion
@@ -3906,7 +3917,9 @@ _mesa_unpack_depth_span( const GLcontext
          }
          return;
       }
-      if (srcType == GL_UNSIGNED_SHORT && dstType == GL_UNSIGNED_INT) {
+      if (srcType == GL_UNSIGNED_SHORT
+          && dstType == GL_UNSIGNED_INT
+          && depthScale == (GLfloat) 0xffffffff) {
          const GLushort *src = (const GLushort *) source;
          GLuint *dst = (GLuint *) dest;
          GLuint i;
@@ -3918,7 +3931,7 @@ _mesa_unpack_depth_span( const GLcontext
       /* XXX may want to add additional cases here someday */
    }
 
-   /* general case path */
+   /* general case path follows */
 
    if (dstType == GL_FLOAT) {
       depthValues = (GLfloat *) dest;
@@ -3927,29 +3940,31 @@ _mesa_unpack_depth_span( const GLcontext
       depthValues = depthTemp;
    }
 
-   /* XXX we need to obey srcPacking->SwapBytes here!!! */
-   (void) srcPacking;
-
-   /* convert incoming values to GLfloat */
+   /* Convert incoming values to GLfloat.  Some conversions will require
+    * clamping, below.
+    */
    switch (srcType) {
       case GL_BYTE:
-          DEPTH_VALUES(GLbyte, BYTE_TO_FLOAT);
-          break;
+         DEPTH_VALUES(GLbyte, BYTE_TO_FLOAT);
+         needClamp = GL_TRUE;
+         break;
       case GL_UNSIGNED_BYTE:
-          DEPTH_VALUES(GLubyte, UBYTE_TO_FLOAT);
-          break;
+         DEPTH_VALUES(GLubyte, UBYTE_TO_FLOAT);
+         break;
       case GL_SHORT:
-          DEPTH_VALUES(GLshort, SHORT_TO_FLOAT);
-          break;
+         DEPTH_VALUES(GLshort, SHORT_TO_FLOAT);
+         needClamp = GL_TRUE;
+         break;
       case GL_UNSIGNED_SHORT:
-          DEPTH_VALUES(GLushort, USHORT_TO_FLOAT);
-          break;
+         DEPTH_VALUES(GLushort, USHORT_TO_FLOAT);
+         break;
       case GL_INT:
-          DEPTH_VALUES(GLint, INT_TO_FLOAT);
-          break;
+         DEPTH_VALUES(GLint, INT_TO_FLOAT);
+         needClamp = GL_TRUE;
+         break;
       case GL_UNSIGNED_INT:
-          DEPTH_VALUES(GLuint, UINT_TO_FLOAT);
-          break;
+         DEPTH_VALUES(GLuint, UINT_TO_FLOAT);
+         break;
       case GL_UNSIGNED_INT_24_8_EXT: /* GL_EXT_packed_depth_stencil */
          if (dstType == GL_UNSIGNED_INT &&
              depthScale == (GLfloat) 0xffffff &&
@@ -3981,19 +3996,21 @@ _mesa_unpack_depth_span( const GLcontext
          }
          break;
       case GL_FLOAT:
-          DEPTH_VALUES(GLfloat, 1*);
-          break;
+         DEPTH_VALUES(GLfloat, 1*);
+         needClamp = GL_TRUE;
+         break;
       case GL_HALF_FLOAT_ARB:
          {
             GLuint i;
             const GLhalfARB *src = (const GLhalfARB *) source;
             for (i = 0; i < n; i++) {
-                GLhalfARB value = src[i];
-                if (srcPacking->SwapBytes) {
-                    SWAP2BYTE(value);
-                }
+               GLhalfARB value = src[i];
+               if (srcPacking->SwapBytes) {
+                  SWAP2BYTE(value);
+               }
                depthValues[i] = _mesa_half_to_float(value);
             }
+            needClamp = GL_TRUE;
          }
          break;
       default:
@@ -4001,12 +4018,30 @@ _mesa_unpack_depth_span( const GLcontext
          return;
    }
 
+   /* apply depth scale and bias */
+   {
+      const GLfloat scale = ctx->Pixel.DepthScale;
+      const GLfloat bias = ctx->Pixel.DepthBias;
+      if (scale != 1.0 || bias != 0.0) {
+         GLuint i;
+         for (i = 0; i < n; i++) {
+            depthValues[i] = depthValues[i] * scale + bias;
+         }
+         needClamp = GL_TRUE;
+      }
+   }
 
-   /* apply depth scale and bias and clamp to [0,1] */
-   if (ctx->Pixel.DepthScale != 1.0 || ctx->Pixel.DepthBias != 0.0) {
-      _mesa_scale_and_bias_depth(ctx, n, depthValues);
+   /* clamp to [0, 1] */
+   if (needClamp) {
+      GLuint i;
+      for (i = 0; i < n; i++) {
+         depthValues[i] = CLAMP(depthValues[i], 0.0, 1.0);
+      }
    }
 
+   /*
+    * Convert values to dstType
+    */
    if (dstType == GL_UNSIGNED_INT) {
       GLuint *zValues = (GLuint *) dest;
       GLuint i;
