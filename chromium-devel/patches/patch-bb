$NetBSD: patch-bb,v 1.1.1.1 2010/09/08 15:00:57 rxg Exp $

--- chrome/browser/child_process_launcher.cc.orig	2010-08-19 09:08:28.000000000 +0000
+++ chrome/browser/child_process_launcher.cc
@@ -19,7 +19,7 @@
 #if defined(OS_WIN)
 #include "base/file_path.h"
 #include "chrome/common/sandbox_policy.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_POSIX) && !defined(OS_MACOSX)
 #include "base/singleton.h"
 #include "chrome/browser/crash_handler_host_linux.h"
 #include "chrome/browser/zygote_host_linux.h"
@@ -42,7 +42,7 @@ class ChildProcessLauncher::Context
  public:
   Context()
       : starting_(true)
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
         , zygote_(false)
 #endif
         {
@@ -107,7 +107,7 @@ class ChildProcessLauncher::Context
     handle = sandbox::StartProcessWithAccess(cmd_line, exposed_dir);
 #elif defined(OS_POSIX)
 
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
     if (use_zygote) {
       base::GlobalDescriptors::Mapping mapping;
       mapping.push_back(std::pair<uint32_t, int>(kPrimaryIPCChannel, ipcfd));
@@ -127,7 +127,7 @@ class ChildProcessLauncher::Context
           ipcfd,
           kPrimaryIPCChannel + base::GlobalDescriptors::kBaseDescriptor));
 
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
       // On Linux, we need to add some extra file descriptors for crash handling
       // and the sandbox.
       bool is_renderer =
@@ -159,7 +159,7 @@ class ChildProcessLauncher::Context
             sandbox_fd,
             kSandboxIPCChannel + base::GlobalDescriptors::kBaseDescriptor));
       }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_POSIX) && !defined(OS_MACOSX)
 
       // Actually launch the app.
       bool launched;
@@ -186,20 +186,20 @@ class ChildProcessLauncher::Context
         NewRunnableMethod(
             this,
             &ChildProcessLauncher::Context::Notify,
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
             use_zygote,
 #endif
             handle));
   }
 
   void Notify(
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
       bool zygote,
 #endif
       base::ProcessHandle handle) {
     starting_ = false;
     process_.set_handle(handle);
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
     zygote_ = zygote;
 #endif
     if (client_) {
@@ -219,7 +219,7 @@ class ChildProcessLauncher::Context
         ChromeThread::PROCESS_LAUNCHER, FROM_HERE,
         NewRunnableFunction(
             &ChildProcessLauncher::Context::TerminateInternal,
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
             zygote_,
 #endif
             process_.handle()));
@@ -227,7 +227,7 @@ class ChildProcessLauncher::Context
   }
 
   static void TerminateInternal(
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
       bool zygote,
 #endif
       base::ProcessHandle handle) {
@@ -237,13 +237,13 @@ class ChildProcessLauncher::Context
     process.Terminate(ResultCodes::NORMAL_EXIT);
     // On POSIX, we must additionally reap the child.
 #if defined(OS_POSIX)
-#if defined(OS_LINUX)
+#if !defined(OS_MACOSX)
     if (zygote) {
       // If the renderer was created via a zygote, we have to proxy the reaping
       // through the zygote process.
       Singleton<ZygoteHost>()->EnsureProcessTerminated(handle);
     } else
-#endif  // OS_LINUX
+#endif  // !OS_MACOSX
     {
       ProcessWatcher::EnsureProcessTerminated(handle);
     }
@@ -256,7 +256,7 @@ class ChildProcessLauncher::Context
   base::Process process_;
   bool starting_;
 
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
   bool zygote_;
 #endif
 };
@@ -301,7 +301,7 @@ base::ProcessHandle ChildProcessLauncher
 bool ChildProcessLauncher::DidProcessCrash() {
   bool did_crash, child_exited;
   base::ProcessHandle handle = context_->process_.handle();
-#if defined(OS_LINUX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
   if (context_->zygote_) {
     did_crash = Singleton<ZygoteHost>()->DidProcessCrash(handle, &child_exited);
   } else
