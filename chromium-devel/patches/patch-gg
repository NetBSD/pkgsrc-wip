$NetBSD: patch-gg,v 1.1.1.1 2010/09/08 15:01:02 rxg Exp $

--- third_party/WebKit/WebCore/platform/graphics/skia/PlatformContextSkia.cpp.orig	2010-08-29 09:08:32.000000000 +0000
+++ third_party/WebKit/WebCore/platform/graphics/skia/PlatformContextSkia.cpp
@@ -97,7 +97,7 @@ struct PlatformContextSkia::State {
     // color to produce a new output color.
     SkColor applyAlpha(SkColor) const;
 
-#if OS(LINUX) || OS(WINDOWS)
+#if OS(LINUX) || OS(FREEBSD) || OS(NETBSD) || OS(WINDOWS)
     // If non-empty, the current State is clipped to this image.
     SkBitmap m_imageBufferClip;
     // If m_imageBufferClip is non-empty, this is the region the image is clipped to.
@@ -154,7 +154,7 @@ PlatformContextSkia::State::State(const 
     , m_lineJoin(other.m_lineJoin)
     , m_dash(other.m_dash)
     , m_textDrawingMode(other.m_textDrawingMode)
-#if OS(LINUX) || OS(WINDOWS)
+#if OS(LINUX) || OS(FREEBSD) || OS(NETBSD) || OS(WINDOWS)
     , m_imageBufferClip(other.m_imageBufferClip)
     , m_clip(other.m_clip)
 #endif
@@ -249,7 +249,7 @@ void PlatformContextSkia::save()
     m_stateStack.append(m_state->cloneInheritedProperties());
     m_state = &m_stateStack.last();
 
-#if OS(LINUX) || OS(WINDOWS)
+#if OS(LINUX) || OS(FREEBSD) || OS(NETBSD) || OS(WINDOWS)
     // The clip image only needs to be applied once. Reset the image so that we
     // don't attempt to clip multiple times.
     m_state->m_imageBufferClip.reset();
@@ -259,7 +259,7 @@ void PlatformContextSkia::save()
     canvas()->save();
 }
 
-#if OS(LINUX) || OS(WINDOWS)
+#if OS(LINUX) || OS(FREEBSD) || OS(NETBSD) || OS(WINDOWS)
 void PlatformContextSkia::beginLayerClippedToImage(const FloatRect& rect,
                                                    const ImageBuffer* imageBuffer)
 {
@@ -307,7 +307,7 @@ void PlatformContextSkia::clipPathAntiAl
 
 void PlatformContextSkia::restore()
 {
-#if OS(LINUX) || OS(WINDOWS)
+#if OS(LINUX) || OS(FREEBSD) || OS(NETBSD) || OS(WINDOWS)
     if (!m_state->m_imageBufferClip.empty()) {
         applyClipFromImage(m_state->m_clip, m_state->m_imageBufferClip);
         canvas()->restore();
@@ -631,7 +631,7 @@ bool PlatformContextSkia::hasImageResamp
     return !m_imageResamplingHintSrcSize.isEmpty() && !m_imageResamplingHintDstSize.isEmpty();
 }
 
-#if OS(LINUX) || OS(WINDOWS)
+#if OS(LINUX) || OS(FREEBSD) || OS(NETBSD) || OS(WINDOWS)
 void PlatformContextSkia::applyClipFromImage(const FloatRect& rect, const SkBitmap& imageBuffer)
 {
     // NOTE: this assumes the image mask contains opaque black for the portions that are to be shown, as such we
