? diff_from_1.5.22.patch
Index: INSTALL
===================================================================
RCS file: /usr/local/cvs/oops/INSTALL,v
retrieving revision 1.15
retrieving revision 1.17
diff -c -r1.15 -r1.17
*** INSTALL	2001/11/08 13:04:37	1.15
--- INSTALL	2002/07/26 06:29:05	1.17
***************
*** 1,3 ****
--- 1,9 ----
+ What you will need:
+ 
+ BerkeleyDB (www.sleepycat.com)
+ flex (ftp.gnu.org/pub/gnu/nun-gnu/flex)
+ 
+ 
  General procedure:
  
  1) ./configure
***************
*** 70,75 ****
--- 76,86 ----
  	}
  
  	module transparent {
+ 	#
+ 	#       myport must be consistent with rules for ipfilter
+ 	#	i.e. all packets must be forwarded by firewall to this
+ 	#	"myport"
+ 	#
  		myport	80
  	}
  	module wccp2 {
Index: Makefile
===================================================================
RCS file: /usr/local/cvs/oops/Makefile,v
retrieving revision 1.62
retrieving revision 1.63
diff -c -r1.62 -r1.63
*** Makefile	2002/02/01 14:02:26	1.62
--- Makefile	2002/03/22 07:09:05	1.63
***************
*** 1,4 ****
! VER=1.5.22
  
  all:
  	cd src; $(MAKE)
--- 1,4 ----
! VER=1.5.22f1
  
  all:
  	cd src; $(MAKE)
Index: configure
===================================================================
RCS file: /usr/local/cvs/oops/configure,v
retrieving revision 1.39
diff -c -r1.39 configure
*** configure	2001/12/19 12:22:34	1.39
--- configure	2003/01/21 07:40:05
***************
*** 1,119 ****
  #! /bin/sh
  # Guess values for system-dependent variables and create Makefiles.
! # Generated by Autoconf 2.52.
  #
- # Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
- # Free Software Foundation, Inc.
  # This configure script is free software; the Free Software Foundation
  # gives unlimited permission to copy, distribute and modify it.
- 
- # Avoid depending upon Character Ranges.
- as_cr_letters='abcdefghijklmnopqrstuvwxyz'
- as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
- as_cr_Letters=$as_cr_letters$as_cr_LETTERS
- as_cr_digits='0123456789'
- as_cr_alnum=$as_cr_Letters$as_cr_digits
- 
- # Sed expression to map a string onto a valid variable name.
- as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
- 
- # Sed expression to map a string onto a valid CPP name.
- as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
- 
- # Be Bourne compatible
- if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-   emulate sh
-   NULLCMD=:
- elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
-   set -o posix
- fi
- 
- # Name of the executable.
- as_me=`echo "$0" |sed 's,.*[\\/],,'`
- 
- if expr a : '\(a\)' >/dev/null 2>&1; then
-   as_expr=expr
- else
-   as_expr=false
- fi
- 
- rm -f conf$$ conf$$.exe conf$$.file
- echo >conf$$.file
- if ln -s conf$$.file conf$$ 2>/dev/null; then
-   # We could just check for DJGPP; but this test a) works b) is more generic
-   # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
-   if test -f conf$$.exe; then
-     # Don't use ln at all; we don't have any links
-     as_ln_s='cp -p'
-   else
-     as_ln_s='ln -s'
-   fi
- elif ln conf$$.file conf$$ 2>/dev/null; then
-   as_ln_s=ln
- else
-   as_ln_s='cp -p'
- fi
- rm -f conf$$ conf$$.exe conf$$.file
- 
- as_executable_p="test -f"
- 
- # Support unset when possible.
- if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
-   as_unset=unset
- else
-   as_unset=false
- fi
- 
- # NLS nuisances.
- $as_unset LANG || test "${LANG+set}" != set || { LANG=C; export LANG; }
- $as_unset LC_ALL || test "${LC_ALL+set}" != set || { LC_ALL=C; export LC_ALL; }
- $as_unset LC_TIME || test "${LC_TIME+set}" != set || { LC_TIME=C; export LC_TIME; }
- $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set || { LC_CTYPE=C; export LC_CTYPE; }
- $as_unset LANGUAGE || test "${LANGUAGE+set}" != set || { LANGUAGE=C; export LANGUAGE; }
- $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set || { LC_COLLATE=C; export LC_COLLATE; }
- $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set || { LC_NUMERIC=C; export LC_NUMERIC; }
- $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set || { LC_MESSAGES=C; export LC_MESSAGES; }
- 
- # IFS
- # We need space, tab and new line, in precisely that order.
- as_nl='
- '
- IFS=" 	$as_nl"
- 
- # CDPATH.
- $as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=:; export CDPATH; }
- 
- # Name of the host.
- # hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
- # so uname gets run too.
- ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
  
! exec 6>&1
! 
! #
! # Initializations.
! #
  ac_default_prefix=/usr/local
! cross_compiling=no
! subdirs=
! MFLAGS= MAKEFLAGS=
! SHELL=${CONFIG_SHELL-/bin/sh}
! 
! # Maximum number of lines to put in a shell here document.
! # This variable seems obsolete.  It should probably be removed, and
! # only ac_max_sed_lines should be used.
! : ${ac_max_here_lines=38}
  
- ac_unique_file="src/oops.c"
- 
  # Initialize some variables set by options.
- ac_init_help=
- ac_init_version=false
  # The variables have the same names as the options, with
  # dashes changed to underlines.
! cache_file=/dev/null
  exec_prefix=NONE
  no_create=
  no_recursion=
  prefix=NONE
  program_prefix=NONE
--- 1,52 ----
  #! /bin/sh
+ 
  # Guess values for system-dependent variables and create Makefiles.
! # Generated automatically using autoconf version 2.13 
! # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
  #
  # This configure script is free software; the Free Software Foundation
  # gives unlimited permission to copy, distribute and modify it.
  
! # Defaults:
! ac_help=
  ac_default_prefix=/usr/local
! # Any additions from configure.in:
! ac_help="$ac_help
! --enable-opt-modules      Additional modules (comma separated)"
! ac_help="$ac_help
! --enable-large-files      Enable large files support"
! ac_help="$ac_help
! --enable-static-modules   Link modules statically"
! ac_help="$ac_help
! --enable-db-locks         Enable internal DB locks (use only with BerkeleyDB!)"
! ac_help="$ac_help
! --enable-oops-user        Username under which uid Oops will run"
! ac_help="$ac_help
! --enable-tnf-probes       Enable TNFPROBE under Solaris"
! ac_help="$ac_help
! --with-DB=[DIR]           BerkeleyDB home directory"
! ac_help="$ac_help
! --with-GB=[PATH]           Gigabase library path"
! ac_help="$ac_help
! --with-MYSQL=[DIR]        MySQL home directory"
! ac_help="$ac_help
! --with-PGSQL=[DIR]        Postgres home directory"
! ac_help="$ac_help
! --with-regexp=(builtin|pcre|system)   Which regex to use"
! ac_help="$ac_help
! --with-malloc             Which malloc library/object file to use"
! ac_help="$ac_help
! --with-zlib=[PATH]         Which zlib library/object file to use"
  
  # Initialize some variables set by options.
  # The variables have the same names as the options, with
  # dashes changed to underlines.
! build=NONE
! cache_file=./config.cache
  exec_prefix=NONE
+ host=NONE
  no_create=
+ nonopt=NONE
  no_recursion=
  prefix=NONE
  program_prefix=NONE
***************
*** 122,136 ****
  silent=
  site=
  srcdir=
  verbose=
  x_includes=NONE
  x_libraries=NONE
- 
- # Installation directory options.
- # These are left unexpanded so users can "make install exec_prefix=/foo"
- # and all the variables that are supposed to be based on exec_prefix
- # by default will actually change.
- # Use braces instead of parens because sh, perl, etc. also accept them.
  bindir='${exec_prefix}/bin'
  sbindir='${exec_prefix}/sbin'
  libexecdir='${exec_prefix}/libexec'
--- 55,64 ----
  silent=
  site=
  srcdir=
+ target=NONE
  verbose=
  x_includes=NONE
  x_libraries=NONE
  bindir='${exec_prefix}/bin'
  sbindir='${exec_prefix}/sbin'
  libexecdir='${exec_prefix}/libexec'
***************
*** 144,159 ****
  infodir='${prefix}/info'
  mandir='${prefix}/man'
  
! # Identity of this package.
! PACKAGE_NAME=
! PACKAGE_TARNAME=
! PACKAGE_VERSION=
! PACKAGE_STRING=
! PACKAGE_BUGREPORT=
  
  ac_prev=
  for ac_option
  do
    # If the previous option needs an argument, assign it.
    if test -n "$ac_prev"; then
      eval "$ac_prev=\$ac_option"
--- 72,88 ----
  infodir='${prefix}/info'
  mandir='${prefix}/man'
  
! # Initialize some other variables.
! subdirs=
! MFLAGS= MAKEFLAGS=
! SHELL=${CONFIG_SHELL-/bin/sh}
! # Maximum number of lines to put in a shell here document.
! ac_max_here_lines=12
  
  ac_prev=
  for ac_option
  do
+ 
    # If the previous option needs an argument, assign it.
    if test -n "$ac_prev"; then
      eval "$ac_prev=\$ac_option"
***************
*** 161,219 ****
      continue
    fi
  
!   ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
  
    # Accept the important Cygnus configure options, so we can diagnose typos.
  
!   case $ac_option in
  
    -bindir | --bindir | --bindi | --bind | --bin | --bi)
      ac_prev=bindir ;;
    -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
!     bindir=$ac_optarg ;;
  
    -build | --build | --buil | --bui | --bu)
!     ac_prev=build_alias ;;
    -build=* | --build=* | --buil=* | --bui=* | --bu=*)
!     build_alias=$ac_optarg ;;
  
    -cache-file | --cache-file | --cache-fil | --cache-fi \
    | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
      ac_prev=cache_file ;;
    -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
    | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
!     cache_file=$ac_optarg ;;
  
-   --config-cache | -C)
-     cache_file=config.cache ;;
- 
    -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
      ac_prev=datadir ;;
    -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
    | --da=*)
!     datadir=$ac_optarg ;;
  
    -disable-* | --disable-*)
!     ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid feature name: $ac_feature" >&2
!    { (exit 1); exit 1; }; }
!     ac_feature=`echo $ac_feature | sed 's/-/_/g'`
!     eval "enable_$ac_feature=no" ;;
  
    -enable-* | --enable-*)
!     ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid feature name: $ac_feature" >&2
!    { (exit 1); exit 1; }; }
!     ac_feature=`echo $ac_feature | sed 's/-/_/g'`
!     case $ac_option in
!       *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
        *) ac_optarg=yes ;;
      esac
!     eval "enable_$ac_feature='$ac_optarg'" ;;
  
    -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
    | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
--- 90,148 ----
      continue
    fi
  
!   case "$ac_option" in
!   -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
!   *) ac_optarg= ;;
!   esac
  
    # Accept the important Cygnus configure options, so we can diagnose typos.
  
!   case "$ac_option" in
  
    -bindir | --bindir | --bindi | --bind | --bin | --bi)
      ac_prev=bindir ;;
    -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
!     bindir="$ac_optarg" ;;
  
    -build | --build | --buil | --bui | --bu)
!     ac_prev=build ;;
    -build=* | --build=* | --buil=* | --bui=* | --bu=*)
!     build="$ac_optarg" ;;
  
    -cache-file | --cache-file | --cache-fil | --cache-fi \
    | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
      ac_prev=cache_file ;;
    -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
    | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
!     cache_file="$ac_optarg" ;;
  
    -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
      ac_prev=datadir ;;
    -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
    | --da=*)
!     datadir="$ac_optarg" ;;
  
    -disable-* | --disable-*)
!     ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
!       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
!     fi
!     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
!     eval "enable_${ac_feature}=no" ;;
  
    -enable-* | --enable-*)
!     ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
!       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
!     fi
!     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
!     case "$ac_option" in
!       *=*) ;;
        *) ac_optarg=yes ;;
      esac
!     eval "enable_${ac_feature}='$ac_optarg'" ;;
  
    -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
    | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
***************
*** 222,268 ****
    -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
    | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
    | --exec=* | --exe=* | --ex=*)
!     exec_prefix=$ac_optarg ;;
  
    -gas | --gas | --ga | --g)
      # Obsolete; use --with-gas.
      with_gas=yes ;;
  
!   -help | --help | --hel | --he | -h)
!     ac_init_help=long ;;
!   -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
!     ac_init_help=recursive ;;
!   -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
!     ac_init_help=short ;;
  
    -host | --host | --hos | --ho)
!     ac_prev=host_alias ;;
    -host=* | --host=* | --hos=* | --ho=*)
!     host_alias=$ac_optarg ;;
  
    -includedir | --includedir | --includedi | --included | --include \
    | --includ | --inclu | --incl | --inc)
      ac_prev=includedir ;;
    -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
    | --includ=* | --inclu=* | --incl=* | --inc=*)
!     includedir=$ac_optarg ;;
  
    -infodir | --infodir | --infodi | --infod | --info | --inf)
      ac_prev=infodir ;;
    -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
!     infodir=$ac_optarg ;;
  
    -libdir | --libdir | --libdi | --libd)
      ac_prev=libdir ;;
    -libdir=* | --libdir=* | --libdi=* | --libd=*)
!     libdir=$ac_optarg ;;
  
    -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
    | --libexe | --libex | --libe)
      ac_prev=libexecdir ;;
    -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
    | --libexe=* | --libex=* | --libe=*)
!     libexecdir=$ac_optarg ;;
  
    -localstatedir | --localstatedir | --localstatedi | --localstated \
    | --localstate | --localstat | --localsta | --localst \
--- 151,245 ----
    -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
    | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
    | --exec=* | --exe=* | --ex=*)
!     exec_prefix="$ac_optarg" ;;
  
    -gas | --gas | --ga | --g)
      # Obsolete; use --with-gas.
      with_gas=yes ;;
  
!   -help | --help | --hel | --he)
!     # Omit some internal or obsolete options to make the list less imposing.
!     # This message is too long to be a string in the A/UX 3.1 sh.
!     cat << EOF
! Usage: configure [options] [host]
! Options: [defaults in brackets after descriptions]
! Configuration:
!   --cache-file=FILE       cache test results in FILE
!   --help                  print this message
!   --no-create             do not create output files
!   --quiet, --silent       do not print \`checking...' messages
!   --version               print the version of autoconf that created configure
! Directory and file names:
!   --prefix=PREFIX         install architecture-independent files in PREFIX
!                           [$ac_default_prefix]
!   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
!                           [same as prefix]
!   --bindir=DIR            user executables in DIR [EPREFIX/bin]
!   --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
!   --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
!   --datadir=DIR           read-only architecture-independent data in DIR
!                           [PREFIX/share]
!   --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
!   --sharedstatedir=DIR    modifiable architecture-independent data in DIR
!                           [PREFIX/com]
!   --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
!   --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
!   --includedir=DIR        C header files in DIR [PREFIX/include]
!   --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
!   --infodir=DIR           info documentation in DIR [PREFIX/info]
!   --mandir=DIR            man documentation in DIR [PREFIX/man]
!   --srcdir=DIR            find the sources in DIR [configure dir or ..]
!   --program-prefix=PREFIX prepend PREFIX to installed program names
!   --program-suffix=SUFFIX append SUFFIX to installed program names
!   --program-transform-name=PROGRAM
!                           run sed PROGRAM on installed program names
! EOF
!     cat << EOF
! Host type:
!   --build=BUILD           configure for building on BUILD [BUILD=HOST]
!   --host=HOST             configure for HOST [guessed]
!   --target=TARGET         configure for TARGET [TARGET=HOST]
! Features and packages:
!   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
!   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
!   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
!   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
!   --x-includes=DIR        X include files are in DIR
!   --x-libraries=DIR       X library files are in DIR
! EOF
!     if test -n "$ac_help"; then
!       echo "--enable and --with options recognized:$ac_help"
!     fi
!     exit 0 ;;
  
    -host | --host | --hos | --ho)
!     ac_prev=host ;;
    -host=* | --host=* | --hos=* | --ho=*)
!     host="$ac_optarg" ;;
  
    -includedir | --includedir | --includedi | --included | --include \
    | --includ | --inclu | --incl | --inc)
      ac_prev=includedir ;;
    -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
    | --includ=* | --inclu=* | --incl=* | --inc=*)
!     includedir="$ac_optarg" ;;
  
    -infodir | --infodir | --infodi | --infod | --info | --inf)
      ac_prev=infodir ;;
    -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
!     infodir="$ac_optarg" ;;
  
    -libdir | --libdir | --libdi | --libd)
      ac_prev=libdir ;;
    -libdir=* | --libdir=* | --libdi=* | --libd=*)
!     libdir="$ac_optarg" ;;
  
    -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
    | --libexe | --libex | --libe)
      ac_prev=libexecdir ;;
    -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
    | --libexe=* | --libex=* | --libe=*)
!     libexecdir="$ac_optarg" ;;
  
    -localstatedir | --localstatedir | --localstatedi | --localstated \
    | --localstate | --localstat | --localsta | --localst \
***************
*** 271,282 ****
    -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
    | --localstate=* | --localstat=* | --localsta=* | --localst=* \
    | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
!     localstatedir=$ac_optarg ;;
  
    -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
      ac_prev=mandir ;;
    -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
!     mandir=$ac_optarg ;;
  
    -nfp | --nfp | --nf)
      # Obsolete; use --without-fp.
--- 248,259 ----
    -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
    | --localstate=* | --localstat=* | --localsta=* | --localst=* \
    | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
!     localstatedir="$ac_optarg" ;;
  
    -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
      ac_prev=mandir ;;
    -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
!     mandir="$ac_optarg" ;;
  
    -nfp | --nfp | --nf)
      # Obsolete; use --without-fp.
***************
*** 297,322 ****
    -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
    | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
    | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
!     oldincludedir=$ac_optarg ;;
  
    -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
      ac_prev=prefix ;;
    -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
!     prefix=$ac_optarg ;;
  
    -program-prefix | --program-prefix | --program-prefi | --program-pref \
    | --program-pre | --program-pr | --program-p)
      ac_prev=program_prefix ;;
    -program-prefix=* | --program-prefix=* | --program-prefi=* \
    | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
!     program_prefix=$ac_optarg ;;
  
    -program-suffix | --program-suffix | --program-suffi | --program-suff \
    | --program-suf | --program-su | --program-s)
      ac_prev=program_suffix ;;
    -program-suffix=* | --program-suffix=* | --program-suffi=* \
    | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
!     program_suffix=$ac_optarg ;;
  
    -program-transform-name | --program-transform-name \
    | --program-transform-nam | --program-transform-na \
--- 274,299 ----
    -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
    | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
    | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
!     oldincludedir="$ac_optarg" ;;
  
    -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
      ac_prev=prefix ;;
    -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
!     prefix="$ac_optarg" ;;
  
    -program-prefix | --program-prefix | --program-prefi | --program-pref \
    | --program-pre | --program-pr | --program-p)
      ac_prev=program_prefix ;;
    -program-prefix=* | --program-prefix=* | --program-prefi=* \
    | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
!     program_prefix="$ac_optarg" ;;
  
    -program-suffix | --program-suffix | --program-suffi | --program-suff \
    | --program-suf | --program-su | --program-s)
      ac_prev=program_suffix ;;
    -program-suffix=* | --program-suffix=* | --program-suffi=* \
    | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
!     program_suffix="$ac_optarg" ;;
  
    -program-transform-name | --program-transform-name \
    | --program-transform-nam | --program-transform-na \
***************
*** 333,339 ****
    | --program-transfo=* | --program-transf=* \
    | --program-trans=* | --program-tran=* \
    | --progr-tra=* | --program-tr=* | --program-t=*)
!     program_transform_name=$ac_optarg ;;
  
    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
    | -silent | --silent | --silen | --sile | --sil)
--- 310,316 ----
    | --program-transfo=* | --program-transf=* \
    | --program-trans=* | --program-tran=* \
    | --progr-tra=* | --program-tr=* | --program-t=*)
!     program_transform_name="$ac_optarg" ;;
  
    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
    | -silent | --silent | --silen | --sile | --sil)
***************
*** 343,349 ****
      ac_prev=sbindir ;;
    -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
    | --sbi=* | --sb=*)
!     sbindir=$ac_optarg ;;
  
    -sharedstatedir | --sharedstatedir | --sharedstatedi \
    | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
--- 320,326 ----
      ac_prev=sbindir ;;
    -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
    | --sbi=* | --sb=*)
!     sbindir="$ac_optarg" ;;
  
    -sharedstatedir | --sharedstatedir | --sharedstatedi \
    | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
***************
*** 354,410 ****
    | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
    | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
    | --sha=* | --sh=*)
!     sharedstatedir=$ac_optarg ;;
  
    -site | --site | --sit)
      ac_prev=site ;;
    -site=* | --site=* | --sit=*)
!     site=$ac_optarg ;;
  
    -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
      ac_prev=srcdir ;;
    -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
!     srcdir=$ac_optarg ;;
  
    -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
    | --syscon | --sysco | --sysc | --sys | --sy)
      ac_prev=sysconfdir ;;
    -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
    | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
!     sysconfdir=$ac_optarg ;;
  
    -target | --target | --targe | --targ | --tar | --ta | --t)
!     ac_prev=target_alias ;;
    -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
!     target_alias=$ac_optarg ;;
  
    -v | -verbose | --verbose | --verbos | --verbo | --verb)
      verbose=yes ;;
  
!   -version | --version | --versio | --versi | --vers | -V)
!     ac_init_version=: ;;
  
    -with-* | --with-*)
!     ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid package name: $ac_package" >&2
!    { (exit 1); exit 1; }; }
      ac_package=`echo $ac_package| sed 's/-/_/g'`
!     case $ac_option in
!       *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
        *) ac_optarg=yes ;;
      esac
!     eval "with_$ac_package='$ac_optarg'" ;;
  
    -without-* | --without-*)
!     ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
      # Reject names that are not valid shell variable names.
!     expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
!       { echo "$as_me: error: invalid package name: $ac_package" >&2
!    { (exit 1); exit 1; }; }
!     ac_package=`echo $ac_package | sed 's/-/_/g'`
!     eval "with_$ac_package=no" ;;
  
    --x)
      # Obsolete; use --with-x.
--- 331,388 ----
    | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
    | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
    | --sha=* | --sh=*)
!     sharedstatedir="$ac_optarg" ;;
  
    -site | --site | --sit)
      ac_prev=site ;;
    -site=* | --site=* | --sit=*)
!     site="$ac_optarg" ;;
  
    -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
      ac_prev=srcdir ;;
    -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
!     srcdir="$ac_optarg" ;;
  
    -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
    | --syscon | --sysco | --sysc | --sys | --sy)
      ac_prev=sysconfdir ;;
    -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
    | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
!     sysconfdir="$ac_optarg" ;;
  
    -target | --target | --targe | --targ | --tar | --ta | --t)
!     ac_prev=target ;;
    -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
!     target="$ac_optarg" ;;
  
    -v | -verbose | --verbose | --verbos | --verbo | --verb)
      verbose=yes ;;
  
!   -version | --version | --versio | --versi | --vers)
!     echo "configure generated by autoconf version 2.13"
!     exit 0 ;;
  
    -with-* | --with-*)
!     ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
!       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
!     fi
      ac_package=`echo $ac_package| sed 's/-/_/g'`
!     case "$ac_option" in
!       *=*) ;;
        *) ac_optarg=yes ;;
      esac
!     eval "with_${ac_package}='$ac_optarg'" ;;
  
    -without-* | --without-*)
!     ac_package=`echo $ac_option|sed -e 's/-*without-//'`
      # Reject names that are not valid shell variable names.
!     if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
!       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
!     fi
!     ac_package=`echo $ac_package| sed 's/-/_/g'`
!     eval "with_${ac_package}=no" ;;
  
    --x)
      # Obsolete; use --with-x.
***************
*** 415,512 ****
      ac_prev=x_includes ;;
    -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
    | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
!     x_includes=$ac_optarg ;;
  
    -x-libraries | --x-libraries | --x-librarie | --x-librari \
    | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
      ac_prev=x_libraries ;;
    -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
    | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
!     x_libraries=$ac_optarg ;;
  
!   -*) { echo "$as_me: error: unrecognized option: $ac_option
! Try \`$0 --help' for more information." >&2
!    { (exit 1); exit 1; }; }
      ;;
  
-   *=*)
-     ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-     # Reject names that are not valid shell variable names.
-     expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
-       { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
-    { (exit 1); exit 1; }; }
-     ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
-     eval "$ac_envvar='$ac_optarg'"
-     export $ac_envvar ;;
- 
    *)
!     # FIXME: should be removed in autoconf 3.0.
!     echo "$as_me: WARNING: you should use --build, --host, --target" >&2
!     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
!       echo "$as_me: WARNING: invalid host type: $ac_option" >&2
!     : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
      ;;
  
    esac
  done
  
  if test -n "$ac_prev"; then
!   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
!   { echo "$as_me: error: missing argument to $ac_option" >&2
!    { (exit 1); exit 1; }; }
  fi
  
! # Be sure to have absolute paths.
! for ac_var in exec_prefix prefix
! do
!   eval ac_val=$`echo $ac_var`
!   case $ac_val in
!     [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
!     *)  { echo "$as_me: error: expected an absolute path for --$ac_var: $ac_val" >&2
!    { (exit 1); exit 1; }; };;
!   esac
! done
  
! # Be sure to have absolute paths.
! for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
!               localstatedir libdir includedir oldincludedir infodir mandir
  do
!   eval ac_val=$`echo $ac_var`
!   case $ac_val in
!     [\\/$]* | ?:[\\/]* ) ;;
!     *)  { echo "$as_me: error: expected an absolute path for --$ac_var: $ac_val" >&2
!    { (exit 1); exit 1; }; };;
    esac
  done
  
! # There might be people who depend on the old broken behavior: `$host'
! # used to hold the argument of --host etc.
! build=$build_alias
! host=$host_alias
! target=$target_alias
! 
! # FIXME: should be removed in autoconf 3.0.
! if test "x$host_alias" != x; then
!   if test "x$build_alias" = x; then
!     cross_compiling=maybe
!     echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
!     If a cross compiler is detected then cross compile mode will be used." >&2
!   elif test "x$build_alias" != "x$host_alias"; then
!     cross_compiling=yes
!   fi
! fi
  
! ac_tool_prefix=
! test -n "$host_alias" && ac_tool_prefix=$host_alias-
  
! test "$silent" = yes && exec 6>/dev/null
  
  # Find the source files, if location was not specified.
  if test -z "$srcdir"; then
    ac_srcdir_defaulted=yes
    # Try the directory containing this script, then its parent.
    ac_prog=$0
!   ac_confdir=`echo "$ac_prog" | sed 's%[\\/][^\\/][^\\/]*$%%'`
    test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
    srcdir=$ac_confdir
    if test ! -r $srcdir/$ac_unique_file; then
--- 393,490 ----
      ac_prev=x_includes ;;
    -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
    | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
!     x_includes="$ac_optarg" ;;
  
    -x-libraries | --x-libraries | --x-librarie | --x-librari \
    | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
      ac_prev=x_libraries ;;
    -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
    | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
!     x_libraries="$ac_optarg" ;;
  
!   -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
      ;;
  
    *)
!     if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
!       echo "configure: warning: $ac_option: invalid host type" 1>&2
!     fi
!     if test "x$nonopt" != xNONE; then
!       { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
!     fi
!     nonopt="$ac_option"
      ;;
  
    esac
  done
  
  if test -n "$ac_prev"; then
!   { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
  fi
  
! trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
! 
! # File descriptor usage:
! # 0 standard input
! # 1 file creation
! # 2 errors and warnings
! # 3 some systems may open it to /dev/tty
! # 4 used on the Kubota Titan
! # 6 checking for... messages and results
! # 5 compiler messages saved in config.log
! if test "$silent" = yes; then
!   exec 6>/dev/null
! else
!   exec 6>&1
! fi
! exec 5>./config.log
! 
! echo "\
! This file contains any messages produced by compilers while
! running configure, to aid debugging if configure makes a mistake.
! " 1>&5
  
! # Strip out --no-create and --no-recursion so they do not pile up.
! # Also quote any args containing shell metacharacters.
! ac_configure_args=
! for ac_arg
  do
!   case "$ac_arg" in
!   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
!   | --no-cr | --no-c) ;;
!   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
!   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
!   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
!   ac_configure_args="$ac_configure_args '$ac_arg'" ;;
!   *) ac_configure_args="$ac_configure_args $ac_arg" ;;
    esac
  done
  
! # NLS nuisances.
! # Only set these to C if already set.  These must not be set unconditionally
! # because not all systems understand e.g. LANG=C (notably SCO).
! # Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
! # Non-C LC_CTYPE values break the ctype check.
! if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
! if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
! if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
! if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
  
! # confdefs.h avoids OS command line length limits that DEFS can exceed.
! rm -rf conftest* confdefs.h
! # AIX cpp loses on an empty file, so make sure it contains at least a newline.
! echo > confdefs.h
  
! # A filename unique to this package, relative to the directory that
! # configure is in, which we can look for to find out if srcdir is correct.
! ac_unique_file=src/oops.c
  
  # Find the source files, if location was not specified.
  if test -z "$srcdir"; then
    ac_srcdir_defaulted=yes
    # Try the directory containing this script, then its parent.
    ac_prog=$0
!   ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
    test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
    srcdir=$ac_confdir
    if test ! -r $srcdir/$ac_unique_file; then
***************
*** 517,847 ****
  fi
  if test ! -r $srcdir/$ac_unique_file; then
    if test "$ac_srcdir_defaulted" = yes; then
!     { echo "$as_me: error: cannot find sources in $ac_confdir or .." >&2
!    { (exit 1); exit 1; }; }
    else
!     { echo "$as_me: error: cannot find sources in $srcdir" >&2
!    { (exit 1); exit 1; }; }
    fi
- fi
- srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
- ac_env_build_alias_set=${build_alias+set}
- ac_env_build_alias_value=$build_alias
- ac_cv_env_build_alias_set=${build_alias+set}
- ac_cv_env_build_alias_value=$build_alias
- ac_env_host_alias_set=${host_alias+set}
- ac_env_host_alias_value=$host_alias
- ac_cv_env_host_alias_set=${host_alias+set}
- ac_cv_env_host_alias_value=$host_alias
- ac_env_target_alias_set=${target_alias+set}
- ac_env_target_alias_value=$target_alias
- ac_cv_env_target_alias_set=${target_alias+set}
- ac_cv_env_target_alias_value=$target_alias
- ac_env_CC_set=${CC+set}
- ac_env_CC_value=$CC
- ac_cv_env_CC_set=${CC+set}
- ac_cv_env_CC_value=$CC
- ac_env_CFLAGS_set=${CFLAGS+set}
- ac_env_CFLAGS_value=$CFLAGS
- ac_cv_env_CFLAGS_set=${CFLAGS+set}
- ac_cv_env_CFLAGS_value=$CFLAGS
- ac_env_LDFLAGS_set=${LDFLAGS+set}
- ac_env_LDFLAGS_value=$LDFLAGS
- ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
- ac_cv_env_LDFLAGS_value=$LDFLAGS
- ac_env_CPPFLAGS_set=${CPPFLAGS+set}
- ac_env_CPPFLAGS_value=$CPPFLAGS
- ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
- ac_cv_env_CPPFLAGS_value=$CPPFLAGS
- ac_env_CXX_set=${CXX+set}
- ac_env_CXX_value=$CXX
- ac_cv_env_CXX_set=${CXX+set}
- ac_cv_env_CXX_value=$CXX
- ac_env_CXXFLAGS_set=${CXXFLAGS+set}
- ac_env_CXXFLAGS_value=$CXXFLAGS
- ac_cv_env_CXXFLAGS_set=${CXXFLAGS+set}
- ac_cv_env_CXXFLAGS_value=$CXXFLAGS
- ac_env_CPP_set=${CPP+set}
- ac_env_CPP_value=$CPP
- ac_cv_env_CPP_set=${CPP+set}
- ac_cv_env_CPP_value=$CPP
- 
- #
- # Report the --help message.
- #
- if test "$ac_init_help" = "long"; then
-   # Omit some internal or obsolete options to make the list less imposing.
-   # This message is too long to be a string in the A/UX 3.1 sh.
-   cat <<EOF
- \`configure' configures this package to adapt to many kinds of systems.
- 
- Usage: $0 [OPTION]... [VAR=VALUE]...
- 
- To assign environment variables (e.g., CC, CFLAGS...), specify them as
- VAR=VALUE.  See below for descriptions of some of the useful variables.
- 
- Defaults for the options are specified in brackets.
- 
- Configuration:
-   -h, --help              display this help and exit
-       --help=short        display options specific to this package
-       --help=recursive    display the short help of all the included packages
-   -V, --version           display version information and exit
-   -q, --quiet, --silent   do not print \`checking...' messages
-       --cache-file=FILE   cache test results in FILE [disabled]
-   -C, --config-cache      alias for \`--cache-file=config.cache'
-   -n, --no-create         do not create output files
-       --srcdir=DIR        find the sources in DIR [configure dir or \`..']
- 
- EOF
- 
-   cat <<EOF
- Installation directories:
-   --prefix=PREFIX         install architecture-independent files in PREFIX
-                           [$ac_default_prefix]
-   --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                           [PREFIX]
- 
- By default, \`make install' will install all the files in
- \`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
- an installation prefix other than \`$ac_default_prefix' using \`--prefix',
- for instance \`--prefix=\$HOME'.
- 
- For better control, use the options below.
- 
- Fine tuning of the installation directories:
-   --bindir=DIR           user executables [EPREFIX/bin]
-   --sbindir=DIR          system admin executables [EPREFIX/sbin]
-   --libexecdir=DIR       program executables [EPREFIX/libexec]
-   --datadir=DIR          read-only architecture-independent data [PREFIX/share]
-   --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
-   --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
-   --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
-   --libdir=DIR           object code libraries [EPREFIX/lib]
-   --includedir=DIR       C header files [PREFIX/include]
-   --oldincludedir=DIR    C header files for non-gcc [/usr/include]
-   --infodir=DIR          info documentation [PREFIX/info]
-   --mandir=DIR           man documentation [PREFIX/man]
- EOF
- 
-   cat <<\EOF
- 
- System types:
-   --build=BUILD     configure for building on BUILD [guessed]
-   --host=HOST       build programs to run on HOST [BUILD]
-   --target=TARGET   configure for building compilers for TARGET [HOST]
- EOF
- fi
- 
- if test -n "$ac_init_help"; then
- 
-   cat <<\EOF
- 
- Optional Features:
-   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
- --enable-opt-modules      Additional modules (comma separated)
- --enable-large-files      Enable large files support
- --enable-static-modules   Link modules statically
- --enable-db-locks         Enable internal DB locks (use only with BerkeleyDB!)
- --enable-oops-user        Username under which uid Oops will run
- --enable-tnf-probes       Enable TNFPROBE under Solaris
- 
- Optional Packages:
-   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
- --with-DB=DIR           BerkeleyDB home directory
- --with-GB=PATH           Gigabase library path
- --with-MYSQL=DIR        MySQL home directory
- --with-PGSQL=DIR        Postgres home directory
- --with-regexp=(builtin|pcre|system)   Which regex to use
- --with-malloc             Which malloc library/object file to use
- --with-zlib=PATH         Which zlib library/object file to use
- 
- Some influential environment variables:
-   CC          C compiler command
-   CFLAGS      C compiler flags
-   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-               nonstandard directory <lib dir>
-   CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
-               headers in a nonstandard directory <include dir>
-   CXX         C++ compiler command
-   CXXFLAGS    C++ compiler flags
-   CPP         C preprocessor
- 
- Use these variables to override the choices made by `configure' or to help
- it to find libraries and programs with nonstandard names/locations.
- 
- EOF
- fi
- 
- if test "$ac_init_help" = "recursive"; then
-   # If there are subdirs, report their specific --help.
-   ac_popdir=`pwd`
-   for ac_subdir in : $ac_subdirs_all; do test "x$ac_subdir" = x: && continue
-     cd $ac_subdir
-     # A "../" for each directory in /$ac_subdir.
-     ac_dots=`echo $ac_subdir |
-              sed 's,^\./,,;s,[^/]$,&/,;s,[^/]*/,../,g'`
- 
-     case $srcdir in
-     .) # No --srcdir option.  We are building in place.
-       ac_sub_srcdir=$srcdir ;;
-     [\\/]* | ?:[\\/]* ) # Absolute path.
-       ac_sub_srcdir=$srcdir/$ac_subdir ;;
-     *) # Relative path.
-       ac_sub_srcdir=$ac_dots$srcdir/$ac_subdir ;;
-     esac
- 
-     # Check for guested configure; otherwise get Cygnus style configure.
-     if test -f $ac_sub_srcdir/configure.gnu; then
-       echo
-       $SHELL $ac_sub_srcdir/configure.gnu  --help=recursive
-     elif test -f $ac_sub_srcdir/configure; then
-       echo
-       $SHELL $ac_sub_srcdir/configure  --help=recursive
-     elif test -f $ac_sub_srcdir/configure.ac ||
-            test -f $ac_sub_srcdir/configure.in; then
-       echo
-       $ac_configure --help
-     else
-       echo "$as_me: WARNING: no configuration information is in $ac_subdir" >&2
-     fi
-     cd $ac_popdir
-   done
- fi
- 
- test -n "$ac_init_help" && exit 0
- if $ac_init_version; then
-   cat <<\EOF
- 
- Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
- Free Software Foundation, Inc.
- This configure script is free software; the Free Software Foundation
- gives unlimited permission to copy, distribute and modify it.
- EOF
-   exit 0
  fi
! exec 5>config.log
! cat >&5 <<EOF
! This file contains any messages produced by compilers while
! running configure, to aid debugging if configure makes a mistake.
! 
! It was created by $as_me, which was
! generated by GNU Autoconf 2.52.  Invocation command line was
! 
!   $ $0 $@
! 
! EOF
! {
! cat <<_ASUNAME
! ## ---------- ##
! ## Platform.  ##
! ## ---------- ##
! 
! hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
! uname -m = `(uname -m) 2>/dev/null || echo unknown`
! uname -r = `(uname -r) 2>/dev/null || echo unknown`
! uname -s = `(uname -s) 2>/dev/null || echo unknown`
! uname -v = `(uname -v) 2>/dev/null || echo unknown`
! 
! /usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
! /bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
! 
! /bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
! /usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
! /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
! hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
! /bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
! /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
! /bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
! 
! PATH = $PATH
! 
! _ASUNAME
! } >&5
! 
! cat >&5 <<EOF
! ## ------------ ##
! ## Core tests.  ##
! ## ------------ ##
! 
! EOF
  
- # Keep a trace of the command line.
- # Strip out --no-create and --no-recursion so they do not pile up.
- # Also quote any args containing shell meta-characters.
- ac_configure_args=
- ac_sep=
- for ac_arg
- do
-   case $ac_arg in
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c) ;;
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
-   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
-     ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"`
-     ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
-     ac_sep=" " ;;
-   *) ac_configure_args="$ac_configure_args$ac_sep$ac_arg"
-      ac_sep=" " ;;
-   esac
-   # Get rid of the leading space.
- done
- 
- # When interrupted or exit'd, cleanup temporary files, and complete
- # config.log.  We remove comments because anyway the quotes in there
- # would cause problems or look ugly.
- trap 'exit_status=$?
-   # Save into config.log some information that might help in debugging.
-   echo >&5
-   echo "## ----------------- ##" >&5
-   echo "## Cache variables.  ##" >&5
-   echo "## ----------------- ##" >&5
-   echo >&5
-   # The following way of writing the cache mishandles newlines in values,
- {
-   (set) 2>&1 |
-     case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
-     *ac_space=\ *)
-       sed -n \
-         "s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
-     	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
-       ;;
-     *)
-       sed -n \
-         "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
-       ;;
-     esac;
- } >&5
-   sed "/^$/d" confdefs.h >conftest.log
-   if test -s conftest.log; then
-     echo >&5
-     echo "## ------------ ##" >&5
-     echo "## confdefs.h.  ##" >&5
-     echo "## ------------ ##" >&5
-     echo >&5
-     cat conftest.log >&5
-   fi
-   (echo; echo) >&5
-   test "$ac_signal" != 0 &&
-     echo "$as_me: caught signal $ac_signal" >&5
-   echo "$as_me: exit $exit_status" >&5
-   rm -rf conftest* confdefs* core core.* *.core conf$$* $ac_clean_files &&
-     exit $exit_status
-      ' 0
- for ac_signal in 1 2 13 15; do
-   trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
- done
- ac_signal=0
- 
- # confdefs.h avoids OS command line length limits that DEFS can exceed.
- rm -rf conftest* confdefs.h
- # AIX cpp loses on an empty file, so make sure it contains at least a newline.
- echo >confdefs.h
- 
- # Let the site file select an alternate cache file if it wants to.
  # Prefer explicitly selected file to automatically selected ones.
  if test -z "$CONFIG_SITE"; then
    if test "x$prefix" != xNONE; then
--- 495,507 ----
  fi
  if test ! -r $srcdir/$ac_unique_file; then
    if test "$ac_srcdir_defaulted" = yes; then
!     { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
    else
!     { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
    fi
  fi
! srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
  
  # Prefer explicitly selected file to automatically selected ones.
  if test -z "$CONFIG_SITE"; then
    if test "x$prefix" != xNONE; then
***************
*** 852,958 ****
  fi
  for ac_site_file in $CONFIG_SITE; do
    if test -r "$ac_site_file"; then
!     { echo "$as_me:855: loading site script $ac_site_file" >&5
! echo "$as_me: loading site script $ac_site_file" >&6;}
!     cat "$ac_site_file" >&5
      . "$ac_site_file"
    fi
  done
  
  if test -r "$cache_file"; then
!   # Some versions of bash will fail to source /dev/null (special
!   # files actually), so we avoid doing that.
!   if test -f "$cache_file"; then
!     { echo "$as_me:866: loading cache $cache_file" >&5
! echo "$as_me: loading cache $cache_file" >&6;}
!     case $cache_file in
!       [\\/]* | ?:[\\/]* ) . $cache_file;;
!       *)                      . ./$cache_file;;
!     esac
!   fi
  else
!   { echo "$as_me:874: creating cache $cache_file" >&5
! echo "$as_me: creating cache $cache_file" >&6;}
!   >$cache_file
! fi
! 
! # Check that the precious variables saved in the cache have kept the same
! # value.
! ac_cache_corrupted=false
! for ac_var in `(set) 2>&1 |
!                sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
!   eval ac_old_set=\$ac_cv_env_${ac_var}_set
!   eval ac_new_set=\$ac_env_${ac_var}_set
!   eval ac_old_val="\$ac_cv_env_${ac_var}_value"
!   eval ac_new_val="\$ac_env_${ac_var}_value"
!   case $ac_old_set,$ac_new_set in
!     set,)
!       { echo "$as_me:890: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
! echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
!       ac_cache_corrupted=: ;;
!     ,set)
!       { echo "$as_me:894: error: \`$ac_var' was not set in the previous run" >&5
! echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
!       ac_cache_corrupted=: ;;
!     ,);;
!     *)
!       if test "x$ac_old_val" != "x$ac_new_val"; then
!         { echo "$as_me:900: error: \`$ac_var' has changed since the previous run:" >&5
! echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
!         { echo "$as_me:902:   former value:  $ac_old_val" >&5
! echo "$as_me:   former value:  $ac_old_val" >&2;}
!         { echo "$as_me:904:   current value: $ac_new_val" >&5
! echo "$as_me:   current value: $ac_new_val" >&2;}
!         ac_cache_corrupted=:
!       fi;;
!   esac
!   # Pass precious variables to config.status.  It doesn't matter if
!   # we pass some twice (in addition to the command line arguments).
!   if test "$ac_new_set" = set; then
!     case $ac_new_val in
!     *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
!       ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"`
!       ac_configure_args="$ac_configure_args '$ac_arg'"
!       ;;
!     *) ac_configure_args="$ac_configure_args $ac_var=$ac_new_val"
!        ;;
!     esac
!   fi
! done
! if $ac_cache_corrupted; then
!   { echo "$as_me:923: error: changes in the environment can compromise the build" >&5
! echo "$as_me: error: changes in the environment can compromise the build" >&2;}
!   { { echo "$as_me:925: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
! echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
!    { (exit 1); exit 1; }; }
  fi
  
  ac_ext=c
  ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! 
! case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
!   *c*,-n*) ECHO_N= ECHO_C='
! ' ECHO_T='	' ;;
!   *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
!   *)      ECHO_N= ECHO_C='\c' ECHO_T= ;;
! esac
! echo "#! $SHELL" >conftest.sh
! echo  "exit 0"   >>conftest.sh
! chmod +x conftest.sh
! if { (echo "$as_me:945: PATH=\".;.\"; conftest.sh") >&5
!   (PATH=".;."; conftest.sh) 2>&5
!   ac_status=$?
!   echo "$as_me:948: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   ac_path_separator=';'
  else
!   ac_path_separator=:
  fi
! PATH_SEPARATOR="$ac_path_separator"
! rm -f conftest.sh
  
  ac_aux_dir=
  for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
--- 512,551 ----
  fi
  for ac_site_file in $CONFIG_SITE; do
    if test -r "$ac_site_file"; then
!     echo "loading site script $ac_site_file"
      . "$ac_site_file"
    fi
  done
  
  if test -r "$cache_file"; then
!   echo "loading cache $cache_file"
!   . $cache_file
  else
!   echo "creating cache $cache_file"
!   > $cache_file
  fi
  
  ac_ext=c
+ # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
  ac_cpp='$CPP $CPPFLAGS'
! ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cc_cross
! 
! ac_exeext=
! ac_objext=o
! if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
!   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
!   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
!     ac_n= ac_c='
! ' ac_t='	'
!   else
!     ac_n=-n ac_c= ac_t=
!   fi
  else
!   ac_n= ac_c='\c' ac_t=
  fi
! 
  
  ac_aux_dir=
  for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
***************
*** 964,1635 ****
      ac_aux_dir=$ac_dir
      ac_install_sh="$ac_aux_dir/install.sh -c"
      break
-   elif test -f $ac_dir/shtool; then
-     ac_aux_dir=$ac_dir
-     ac_install_sh="$ac_aux_dir/shtool install -c"
-     break
    fi
  done
  if test -z "$ac_aux_dir"; then
!   { { echo "$as_me:974: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
! echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
!    { (exit 1); exit 1; }; }
! fi
! ac_config_guess="$SHELL $ac_aux_dir/config.guess"
! ac_config_sub="$SHELL $ac_aux_dir/config.sub"
! ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
  
! # Make sure we can run config.sub.
! $ac_config_sub sun4 >/dev/null 2>&1 ||
!   { { echo "$as_me:984: error: cannot run $ac_config_sub" >&5
! echo "$as_me: error: cannot run $ac_config_sub" >&2;}
!    { (exit 1); exit 1; }; }
! 
! echo "$as_me:988: checking build system type" >&5
! echo $ECHO_N "checking build system type... $ECHO_C" >&6
! if test "${ac_cv_build+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_build_alias=$build_alias
! test -z "$ac_cv_build_alias" &&
!   ac_cv_build_alias=`$ac_config_guess`
! test -z "$ac_cv_build_alias" &&
!   { { echo "$as_me:997: error: cannot guess build type; you must specify one" >&5
! echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
!    { (exit 1); exit 1; }; }
! ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
!   { { echo "$as_me:1001: error: $ac_config_sub $ac_cv_build_alias failed." >&5
! echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed." >&2;}
!    { (exit 1); exit 1; }; }
! 
! fi
! echo "$as_me:1006: result: $ac_cv_build" >&5
! echo "${ECHO_T}$ac_cv_build" >&6
! build=$ac_cv_build
! build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! 
! echo "$as_me:1013: checking host system type" >&5
! echo $ECHO_N "checking host system type... $ECHO_C" >&6
! if test "${ac_cv_host+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_host_alias=$host_alias
! test -z "$ac_cv_host_alias" &&
!   ac_cv_host_alias=$ac_cv_build_alias
! ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
!   { { echo "$as_me:1022: error: $ac_config_sub $ac_cv_host_alias failed" >&5
! echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
!    { (exit 1); exit 1; }; }
! 
! fi
! echo "$as_me:1027: result: $ac_cv_host" >&5
! echo "${ECHO_T}$ac_cv_host" >&6
! host=$ac_cv_host
! host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! 
! echo "$as_me:1034: checking target system type" >&5
! echo $ECHO_N "checking target system type... $ECHO_C" >&6
! if test "${ac_cv_target+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_cv_target_alias=$target_alias
! test "x$ac_cv_target_alias" = "x" &&
!   ac_cv_target_alias=$ac_cv_host_alias
! ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
!   { { echo "$as_me:1043: error: $ac_config_sub $ac_cv_target_alias failed" >&5
! echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
!    { (exit 1); exit 1; }; }
! 
! fi
! echo "$as_me:1048: result: $ac_cv_target" >&5
! echo "${ECHO_T}$ac_cv_target" >&6
! target=$ac_cv_target
! target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
  
  # The aliases save the names the user supplied, while $host etc.
  # will get canonicalized.
! test -n "$target_alias" &&
!   test "$program_prefix$program_suffix$program_transform_name" = \
!     NONENONEs,x,x, &&
!   program_prefix=${target_alias}-
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! if test -n "$ac_tool_prefix"; then
!   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
! set dummy ${ac_tool_prefix}gcc; ac_word=$2
! echo "$as_me:1069: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test -n "$CC"; then
!   ac_cv_prog_CC="$CC" # Let the user override the test.
! else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_CC="${ac_tool_prefix}gcc"
! echo "$as_me:1084: found $ac_dir/$ac_word" >&5
! break
! done
  
- fi
- fi
- CC=$ac_cv_prog_CC
- if test -n "$CC"; then
-   echo "$as_me:1092: result: $CC" >&5
- echo "${ECHO_T}$CC" >&6
- else
-   echo "$as_me:1095: result: no" >&5
- echo "${ECHO_T}no" >&6
- fi
  
  fi
- if test -z "$ac_cv_prog_CC"; then
-   ac_ct_CC=$CC
-   # Extract the first word of "gcc", so it can be a program name with args.
- set dummy gcc; ac_word=$2
- echo "$as_me:1104: checking for $ac_word" >&5
- echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
- if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-   echo $ECHO_N "(cached) $ECHO_C" >&6
- else
-   if test -n "$ac_ct_CC"; then
-   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
- else
-   ac_save_IFS=$IFS; IFS=$ac_path_separator
- ac_dummy="$PATH"
- for ac_dir in $ac_dummy; do
-   IFS=$ac_save_IFS
-   test -z "$ac_dir" && ac_dir=.
-   $as_executable_p "$ac_dir/$ac_word" || continue
- ac_cv_prog_ac_ct_CC="gcc"
- echo "$as_me:1119: found $ac_dir/$ac_word" >&5
- break
- done
  
! fi
! fi
! ac_ct_CC=$ac_cv_prog_ac_ct_CC
! if test -n "$ac_ct_CC"; then
!   echo "$as_me:1127: result: $ac_ct_CC" >&5
! echo "${ECHO_T}$ac_ct_CC" >&6
! else
!   echo "$as_me:1130: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
  
!   CC=$ac_ct_CC
! else
!   CC="$ac_cv_prog_CC"
! fi
  
! if test -z "$CC"; then
!   if test -n "$ac_tool_prefix"; then
!   # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
! set dummy ${ac_tool_prefix}cc; ac_word=$2
! echo "$as_me:1143: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_CC="${ac_tool_prefix}cc"
! echo "$as_me:1158: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! CC=$ac_cv_prog_CC
  if test -n "$CC"; then
!   echo "$as_me:1166: result: $CC" >&5
! echo "${ECHO_T}$CC" >&6
! else
!   echo "$as_me:1169: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
! 
! fi
! if test -z "$ac_cv_prog_CC"; then
!   ac_ct_CC=$CC
!   # Extract the first word of "cc", so it can be a program name with args.
! set dummy cc; ac_word=$2
! echo "$as_me:1178: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test -n "$ac_ct_CC"; then
!   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
! else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_ac_ct_CC="cc"
! echo "$as_me:1193: found $ac_dir/$ac_word" >&5
! break
! done
! 
! fi
! fi
! ac_ct_CC=$ac_cv_prog_ac_ct_CC
! if test -n "$ac_ct_CC"; then
!   echo "$as_me:1201: result: $ac_ct_CC" >&5
! echo "${ECHO_T}$ac_ct_CC" >&6
! else
!   echo "$as_me:1204: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
! 
!   CC=$ac_ct_CC
  else
!   CC="$ac_cv_prog_CC"
  fi
  
- fi
  if test -z "$CC"; then
    # Extract the first word of "cc", so it can be a program name with args.
  set dummy cc; ac_word=$2
! echo "$as_me:1217: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
    ac_prog_rejected=no
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
!   ac_prog_rejected=yes
!   continue
! fi
! ac_cv_prog_CC="cc"
! echo "$as_me:1237: found $ac_dir/$ac_word" >&5
! break
! done
! 
  if test $ac_prog_rejected = yes; then
    # We found a bogon in the path, so make sure we never use it.
    set dummy $ac_cv_prog_CC
    shift
!   if test $# != 0; then
      # We chose a different compiler from the bogus one.
      # However, it has the same basename, so the bogon will be chosen
      # first if we set CC to just the basename; use the full file name.
      shift
!     set dummy "$ac_dir/$ac_word" ${1+"$@"}
      shift
      ac_cv_prog_CC="$@"
    fi
  fi
  fi
  fi
! CC=$ac_cv_prog_CC
  if test -n "$CC"; then
!   echo "$as_me:1259: result: $CC" >&5
! echo "${ECHO_T}$CC" >&6
  else
!   echo "$as_me:1262: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
! fi
! if test -z "$CC"; then
!   if test -n "$ac_tool_prefix"; then
!   for ac_prog in cl
!   do
!     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
! set dummy $ac_tool_prefix$ac_prog; ac_word=$2
! echo "$as_me:1273: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
! echo "$as_me:1288: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! CC=$ac_cv_prog_CC
  if test -n "$CC"; then
!   echo "$as_me:1296: result: $CC" >&5
! echo "${ECHO_T}$CC" >&6
  else
!   echo "$as_me:1299: result: no" >&5
! echo "${ECHO_T}no" >&6
! fi
! 
!     test -n "$CC" && break
!   done
! fi
! if test -z "$CC"; then
!   ac_ct_CC=$CC
!   for ac_prog in cl
! do
!   # Extract the first word of "$ac_prog", so it can be a program name with args.
! set dummy $ac_prog; ac_word=$2
! echo "$as_me:1312: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test -n "$ac_ct_CC"; then
!   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
! else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_ac_ct_CC="$ac_prog"
! echo "$as_me:1327: found $ac_dir/$ac_word" >&5
! break
! done
! 
! fi
  fi
! ac_ct_CC=$ac_cv_prog_ac_ct_CC
! if test -n "$ac_ct_CC"; then
!   echo "$as_me:1335: result: $ac_ct_CC" >&5
! echo "${ECHO_T}$ac_ct_CC" >&6
! else
!   echo "$as_me:1338: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
!   test -n "$ac_ct_CC" && break
! done
! 
!   CC=$ac_ct_CC
! fi
  
! fi
  
! test -z "$CC" && { { echo "$as_me:1350: error: no acceptable cc found in \$PATH" >&5
! echo "$as_me: error: no acceptable cc found in \$PATH" >&2;}
!    { (exit 1); exit 1; }; }
! 
! # Provide some information about the compiler.
! echo "$as_me:1355:" \
!      "checking for C compiler version" >&5
! ac_compiler=`set X $ac_compile; echo $2`
! { (eval echo "$as_me:1358: \"$ac_compiler --version </dev/null >&5\"") >&5
!   (eval $ac_compiler --version </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1361: \$? = $ac_status" >&5
!   (exit $ac_status); }
! { (eval echo "$as_me:1363: \"$ac_compiler -v </dev/null >&5\"") >&5
!   (eval $ac_compiler -v </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1366: \$? = $ac_status" >&5
!   (exit $ac_status); }
! { (eval echo "$as_me:1368: \"$ac_compiler -V </dev/null >&5\"") >&5
!   (eval $ac_compiler -V </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1371: \$? = $ac_status" >&5
!   (exit $ac_status); }
  
! cat >conftest.$ac_ext <<_ACEOF
! #line 1375 "configure"
  #include "confdefs.h"
- 
- int
- main ()
- {
  
!   ;
!   return 0;
! }
! _ACEOF
! ac_clean_files_save=$ac_clean_files
! ac_clean_files="$ac_clean_files a.out a.exe"
! # Try to create an executable without -o first, disregard a.out.
! # It will help us diagnose broken compilers, and finding out an intuition
! # of exeext.
! echo "$as_me:1391: checking for C compiler default output" >&5
! echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
! ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
! if { (eval echo "$as_me:1394: \"$ac_link_default\"") >&5
!   (eval $ac_link_default) 2>&5
!   ac_status=$?
!   echo "$as_me:1397: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   # Find the output, starting from the most likely.  This scheme is
! # not robust to junk in `.', hence go to wildcards (a.*) only as a last
! # resort.
! for ac_file in `ls a.exe conftest.exe 2>/dev/null;
!                 ls a.out conftest 2>/dev/null;
!                 ls a.* conftest.* 2>/dev/null`; do
!   case $ac_file in
!     *.$ac_ext | *.o | *.obj | *.xcoff | *.tds | *.d | *.pdb ) ;;
!     a.out ) # We found the default executable, but exeext='' is most
!             # certainly right.
!             break;;
!     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
!           # FIXME: I believe we export ac_cv_exeext for Libtool --akim.
!           export ac_cv_exeext
!           break;;
!     * ) break;;
!   esac
! done
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! { { echo "$as_me:1420: error: C compiler cannot create executables" >&5
! echo "$as_me: error: C compiler cannot create executables" >&2;}
!    { (exit 77); exit 77; }; }
! fi
! 
! ac_exeext=$ac_cv_exeext
! echo "$as_me:1426: result: $ac_file" >&5
! echo "${ECHO_T}$ac_file" >&6
! 
! # Check the compiler produces executables we can run.  If not, either
! # the compiler is broken, or we cross compile.
! echo "$as_me:1431: checking whether the C compiler works" >&5
! echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
! # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
! # If not cross compiling, check that we can run a simple program.
! if test "$cross_compiling" != yes; then
!   if { ac_try='./$ac_file'
!   { (eval echo "$as_me:1437: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:1440: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!     cross_compiling=no
    else
!     if test "$cross_compiling" = maybe; then
! 	cross_compiling=yes
!     else
! 	{ { echo "$as_me:1447: error: cannot run C compiled programs.
! If you meant to cross compile, use \`--host'." >&5
! echo "$as_me: error: cannot run C compiled programs.
! If you meant to cross compile, use \`--host'." >&2;}
!    { (exit 1); exit 1; }; }
!     fi
    fi
- fi
- echo "$as_me:1455: result: yes" >&5
- echo "${ECHO_T}yes" >&6
- 
- rm -f a.out a.exe conftest$ac_cv_exeext
- ac_clean_files=$ac_clean_files_save
- # Check the compiler produces executables we can run.  If not, either
- # the compiler is broken, or we cross compile.
- echo "$as_me:1462: checking whether we are cross compiling" >&5
- echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
- echo "$as_me:1464: result: $cross_compiling" >&5
- echo "${ECHO_T}$cross_compiling" >&6
- 
- echo "$as_me:1467: checking for executable suffix" >&5
- echo $ECHO_N "checking for executable suffix... $ECHO_C" >&6
- if { (eval echo "$as_me:1469: \"$ac_link\"") >&5
-   (eval $ac_link) 2>&5
-   ac_status=$?
-   echo "$as_me:1472: \$? = $ac_status" >&5
-   (exit $ac_status); }; then
-   # If both `conftest.exe' and `conftest' are `present' (well, observable)
- # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
- # work properly (i.e., refer to `conftest.exe'), while it won't with
- # `rm'.
- for ac_file in `(ls conftest.exe; ls conftest; ls conftest.*) 2>/dev/null`; do
-   case $ac_file in
-     *.$ac_ext | *.o | *.obj | *.xcoff | *.tds | *.d | *.pdb ) ;;
-     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-           export ac_cv_exeext
-           break;;
-     * ) break;;
-   esac
- done
- else
-   { { echo "$as_me:1488: error: cannot compute EXEEXT: cannot compile and link" >&5
- echo "$as_me: error: cannot compute EXEEXT: cannot compile and link" >&2;}
-    { (exit 1); exit 1; }; }
- fi
- 
- rm -f conftest$ac_cv_exeext
- echo "$as_me:1494: result: $ac_cv_exeext" >&5
- echo "${ECHO_T}$ac_cv_exeext" >&6
- 
- rm -f conftest.$ac_ext
- EXEEXT=$ac_cv_exeext
- ac_exeext=$EXEEXT
- echo "$as_me:1500: checking for object suffix" >&5
- echo $ECHO_N "checking for object suffix... $ECHO_C" >&6
- if test "${ac_cv_objext+set}" = set; then
-   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1506 "configure"
! #include "confdefs.h"
  
! int
! main ()
! {
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.o conftest.obj
! if { (eval echo "$as_me:1518: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:1521: \$? = $ac_status" >&5
!   (exit $ac_status); }; then
!   for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
!   case $ac_file in
!     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb ) ;;
!     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
!        break;;
!   esac
! done
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! { { echo "$as_me:1533: error: cannot compute OBJEXT: cannot compile" >&5
! echo "$as_me: error: cannot compute OBJEXT: cannot compile" >&2;}
!    { (exit 1); exit 1; }; }
! fi
! 
! rm -f conftest.$ac_cv_objext conftest.$ac_ext
! fi
! echo "$as_me:1540: result: $ac_cv_objext" >&5
! echo "${ECHO_T}$ac_cv_objext" >&6
! OBJEXT=$ac_cv_objext
! ac_objext=$OBJEXT
! echo "$as_me:1544: checking whether we are using the GNU C compiler" >&5
! echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
! if test "${ac_cv_c_compiler_gnu+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1550 "configure"
! #include "confdefs.h"
  
! int
! main ()
! {
! #ifndef __GNUC__
!        choke me
! #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:1565: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:1568: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:1571: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:1574: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_compiler_gnu=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_compiler_gnu=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! ac_cv_c_compiler_gnu=$ac_compiler_gnu
! 
! fi
! echo "$as_me:1586: result: $ac_cv_c_compiler_gnu" >&5
! echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
! GCC=`test $ac_compiler_gnu = yes && echo yes`
! ac_test_CFLAGS=${CFLAGS+set}
! ac_save_CFLAGS=$CFLAGS
! CFLAGS="-g"
! echo "$as_me:1592: checking whether $CC accepts -g" >&5
! echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
! if test "${ac_cv_prog_cc_g+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1598 "configure"
! #include "confdefs.h"
! 
! int
! main ()
! {
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:1610: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:1613: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:1616: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:1619: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_prog_cc_g=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_prog_cc_g=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:1629: result: $ac_cv_prog_cc_g" >&5
! echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
  if test "$ac_test_CFLAGS" = set; then
!   CFLAGS=$ac_save_CFLAGS
  elif test $ac_cv_prog_cc_g = yes; then
    if test "$GCC" = yes; then
      CFLAGS="-g -O2"
--- 557,868 ----
      ac_aux_dir=$ac_dir
      ac_install_sh="$ac_aux_dir/install.sh -c"
      break
    fi
  done
  if test -z "$ac_aux_dir"; then
!   { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
! fi
! ac_config_guess=$ac_aux_dir/config.guess
! ac_config_sub=$ac_aux_dir/config.sub
! ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
  
! 
! # Do some error checking and defaulting for the host and target type.
! # The inputs are:
! #    configure --host=HOST --target=TARGET --build=BUILD NONOPT
! #
! # The rules are:
! # 1. You are not allowed to specify --host, --target, and nonopt at the
! #    same time.
! # 2. Host defaults to nonopt.
! # 3. If nonopt is not specified, then host defaults to the current host,
! #    as determined by config.guess.
! # 4. Target and build default to nonopt.
! # 5. If nonopt is not specified, then target and build default to host.
  
  # The aliases save the names the user supplied, while $host etc.
  # will get canonicalized.
! case $host---$target---$nonopt in
! NONE---*---* | *---NONE---* | *---*---NONE) ;;
! *) { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; } ;;
! esac
  
  
+ # Make sure we can run config.sub.
+ if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
+ else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
  fi
  
! echo $ac_n "checking host system type""... $ac_c" 1>&6
! echo "configure:598: checking host system type" >&5
  
! host_alias=$host
! case "$host_alias" in
! NONE)
!   case $nonopt in
!   NONE)
!     if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :
!     else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
!     fi ;;
!   *) host_alias=$nonopt ;;
!   esac ;;
! esac
  
! host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`
! host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! echo "$ac_t""$host" 1>&6
! 
! echo $ac_n "checking target system type""... $ac_c" 1>&6
! echo "configure:619: checking target system type" >&5
! 
! target_alias=$target
! case "$target_alias" in
! NONE)
!   case $nonopt in
!   NONE) target_alias=$host_alias ;;
!   *) target_alias=$nonopt ;;
!   esac ;;
! esac
! 
! target=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $target_alias`
! target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! echo "$ac_t""$target" 1>&6
! 
! echo $ac_n "checking build system type""... $ac_c" 1>&6
! echo "configure:637: checking build system type" >&5
! 
! build_alias=$build
! case "$build_alias" in
! NONE)
!   case $nonopt in
!   NONE) build_alias=$host_alias ;;
!   *) build_alias=$nonopt ;;
!   esac ;;
! esac
! 
! build=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $build_alias`
! build_cpu=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
! build_vendor=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
! build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
! echo "$ac_t""$build" 1>&6
! 
! test "$host_alias" != "$target_alias" &&
!   test "$program_prefix$program_suffix$program_transform_name" = \
!     NONENONEs,x,x, &&
!   program_prefix=${target_alias}-
! 
! # Extract the first word of "gcc", so it can be a program name with args.
! set dummy gcc; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:662: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_CC="gcc"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! CC="$ac_cv_prog_CC"
  if test -n "$CC"; then
!   echo "$ac_t""$CC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  if test -z "$CC"; then
    # Extract the first word of "cc", so it can be a program name with args.
  set dummy cc; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:692: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
+   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
    ac_prog_rejected=no
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
!         ac_prog_rejected=yes
! 	continue
!       fi
!       ac_cv_prog_CC="cc"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  if test $ac_prog_rejected = yes; then
    # We found a bogon in the path, so make sure we never use it.
    set dummy $ac_cv_prog_CC
    shift
!   if test $# -gt 0; then
      # We chose a different compiler from the bogus one.
      # However, it has the same basename, so the bogon will be chosen
      # first if we set CC to just the basename; use the full file name.
      shift
!     set dummy "$ac_dir/$ac_word" "$@"
      shift
      ac_cv_prog_CC="$@"
    fi
  fi
  fi
  fi
! CC="$ac_cv_prog_CC"
  if test -n "$CC"; then
!   echo "$ac_t""$CC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
!   if test -z "$CC"; then
!     case "`uname -s`" in
!     *win32* | *WIN32*)
!       # Extract the first word of "cl", so it can be a program name with args.
! set dummy cl; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:743: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CC"; then
    ac_cv_prog_CC="$CC" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_CC="cl"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! CC="$ac_cv_prog_CC"
  if test -n "$CC"; then
!   echo "$ac_t""$CC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
!  ;;
!     esac
!   fi
!   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
  fi
  
! echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:775: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
! ac_ext=c
! # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cc_cross
  
! cat > conftest.$ac_ext << EOF
  
! #line 786 "configure"
  #include "confdefs.h"
  
! main(){return(0);}
! EOF
! if { (eval echo configure:791: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   ac_cv_prog_cc_works=yes
!   # If we can't run a trivial program, we are probably using a cross compiler.
!   if (./conftest; exit) 2>/dev/null; then
!     ac_cv_prog_cc_cross=no
    else
!     ac_cv_prog_cc_cross=yes
    fi
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   ac_cv_prog_cc_works=no
! fi
! rm -fr conftest*
! ac_ext=c
! # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cc_cross
  
! echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
! if test $ac_cv_prog_cc_works = no; then
!   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
! fi
! echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:817: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
! echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
! cross_compiling=$ac_cv_prog_cc_cross
  
! echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:822: checking whether we are using GNU C" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.c <<EOF
! #ifdef __GNUC__
!   yes;
! #endif
! EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:831: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
!   ac_cv_prog_gcc=yes
  else
!   ac_cv_prog_gcc=no
! fi
! fi
  
! echo "$ac_t""$ac_cv_prog_gcc" 1>&6
  
! if test $ac_cv_prog_gcc = yes; then
!   GCC=yes
  else
!   GCC=
! fi
  
! ac_test_CFLAGS="${CFLAGS+set}"
! ac_save_CFLAGS="$CFLAGS"
! CFLAGS=
! echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:850: checking whether ${CC-cc} accepts -g" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   echo 'void f(){}' > conftest.c
! if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
    ac_cv_prog_cc_g=yes
  else
!   ac_cv_prog_cc_g=no
  fi
! rm -f conftest*
! 
  fi
! 
! echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
  if test "$ac_test_CFLAGS" = set; then
!   CFLAGS="$ac_save_CFLAGS"
  elif test $ac_cv_prog_cc_g = yes; then
    if test "$GCC" = yes; then
      CFLAGS="-g -O2"
***************
*** 1643,1954 ****
      CFLAGS=
    fi
  fi
- # Some people use a C++ compiler to compile C.  Since we use `exit',
- # in C++ we need to declare it.  In case someone uses the same compiler
- # for both compiling C and C++ we need to have the C++ compiler decide
- # the declaration of exit, since it's the most demanding environment.
- cat >conftest.$ac_ext <<_ACEOF
- #ifndef __cplusplus
-   choke me
- #endif
- _ACEOF
- rm -f conftest.$ac_objext
- if { (eval echo "$as_me:1656: \"$ac_compile\"") >&5
-   (eval $ac_compile) 2>&5
-   ac_status=$?
-   echo "$as_me:1659: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest.$ac_objext'
-   { (eval echo "$as_me:1662: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:1665: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   for ac_declaration in \
-    ''\
-    '#include <stdlib.h>' \
-    'extern "C" void std::exit (int) throw (); using std::exit;' \
-    'extern "C" void std::exit (int); using std::exit;' \
-    'extern "C" void exit (int) throw ();' \
-    'extern "C" void exit (int);' \
-    'void exit (int);'
- do
-   cat >conftest.$ac_ext <<_ACEOF
- #line 1677 "configure"
- #include "confdefs.h"
- #include <stdlib.h>
- $ac_declaration
- int
- main ()
- {
- exit (42);
-   ;
-   return 0;
- }
- _ACEOF
- rm -f conftest.$ac_objext
- if { (eval echo "$as_me:1690: \"$ac_compile\"") >&5
-   (eval $ac_compile) 2>&5
-   ac_status=$?
-   echo "$as_me:1693: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest.$ac_objext'
-   { (eval echo "$as_me:1696: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:1699: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   :
- else
-   echo "$as_me: failed program was:" >&5
- cat conftest.$ac_ext >&5
- continue
- fi
- rm -f conftest.$ac_objext conftest.$ac_ext
-   cat >conftest.$ac_ext <<_ACEOF
- #line 1709 "configure"
- #include "confdefs.h"
- $ac_declaration
- int
- main ()
- {
- exit (42);
-   ;
-   return 0;
- }
- _ACEOF
- rm -f conftest.$ac_objext
- if { (eval echo "$as_me:1721: \"$ac_compile\"") >&5
-   (eval $ac_compile) 2>&5
-   ac_status=$?
-   echo "$as_me:1724: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest.$ac_objext'
-   { (eval echo "$as_me:1727: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:1730: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   break
- else
-   echo "$as_me: failed program was:" >&5
- cat conftest.$ac_ext >&5
- fi
- rm -f conftest.$ac_objext conftest.$ac_ext
- done
- rm -f conftest*
- if test -n "$ac_declaration"; then
-   echo '#ifdef __cplusplus' >>confdefs.h
-   echo $ac_declaration      >>confdefs.h
-   echo '#endif'             >>confdefs.h
- fi
  
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! 
! ac_ext=cc
! ac_cpp='$CXXCPP $CPPFLAGS'
! ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
! if test -n "$ac_tool_prefix"; then
!   for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
!   do
!     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
! set dummy $ac_tool_prefix$ac_prog; ac_word=$2
! echo "$as_me:1767: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_CXX+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$CXX"; then
    ac_cv_prog_CXX="$CXX" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
! echo "$as_me:1782: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! CXX=$ac_cv_prog_CXX
  if test -n "$CXX"; then
!   echo "$as_me:1790: result: $CXX" >&5
! echo "${ECHO_T}$CXX" >&6
  else
!   echo "$as_me:1793: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
!     test -n "$CXX" && break
!   done
! fi
! if test -z "$CXX"; then
!   ac_ct_CXX=$CXX
!   for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
! do
!   # Extract the first word of "$ac_prog", so it can be a program name with args.
! set dummy $ac_prog; ac_word=$2
! echo "$as_me:1806: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   if test -n "$ac_ct_CXX"; then
!   ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
! else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_ac_ct_CXX="$ac_prog"
! echo "$as_me:1821: found $ac_dir/$ac_word" >&5
! break
  done
  
! fi
! fi
! ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
! if test -n "$ac_ct_CXX"; then
!   echo "$as_me:1829: result: $ac_ct_CXX" >&5
! echo "${ECHO_T}$ac_ct_CXX" >&6
  else
!   echo "$as_me:1832: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
! 
!   test -n "$ac_ct_CXX" && break
! done
! test -n "$ac_ct_CXX" || ac_ct_CXX="g++"
  
!   CXX=$ac_ct_CXX
  fi
  
! # Provide some information about the compiler.
! echo "$as_me:1844:" \
!      "checking for C++ compiler version" >&5
! ac_compiler=`set X $ac_compile; echo $2`
! { (eval echo "$as_me:1847: \"$ac_compiler --version </dev/null >&5\"") >&5
!   (eval $ac_compiler --version </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1850: \$? = $ac_status" >&5
!   (exit $ac_status); }
! { (eval echo "$as_me:1852: \"$ac_compiler -v </dev/null >&5\"") >&5
!   (eval $ac_compiler -v </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1855: \$? = $ac_status" >&5
!   (exit $ac_status); }
! { (eval echo "$as_me:1857: \"$ac_compiler -V </dev/null >&5\"") >&5
!   (eval $ac_compiler -V </dev/null >&5) 2>&5
!   ac_status=$?
!   echo "$as_me:1860: \$? = $ac_status" >&5
!   (exit $ac_status); }
! 
! echo "$as_me:1863: checking whether we are using the GNU C++ compiler" >&5
! echo $ECHO_N "checking whether we are using the GNU C++ compiler... $ECHO_C" >&6
! if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1869 "configure"
! #include "confdefs.h"
! 
! int
! main ()
! {
! #ifndef __GNUC__
!        choke me
  #endif
! 
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:1884: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:1887: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:1890: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:1893: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_compiler_gnu=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_compiler_gnu=no
! fi
! rm -f conftest.$ac_objext conftest.$ac_ext
! ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
! 
! fi
! echo "$as_me:1905: result: $ac_cv_cxx_compiler_gnu" >&5
! echo "${ECHO_T}$ac_cv_cxx_compiler_gnu" >&6
! GXX=`test $ac_compiler_gnu = yes && echo yes`
! ac_test_CXXFLAGS=${CXXFLAGS+set}
! ac_save_CXXFLAGS=$CXXFLAGS
! CXXFLAGS="-g"
! echo "$as_me:1911: checking whether $CXX accepts -g" >&5
! echo $ECHO_N "checking whether $CXX accepts -g... $ECHO_C" >&6
! if test "${ac_cv_prog_cxx_g+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 1917 "configure"
! #include "confdefs.h"
  
! int
! main ()
! {
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:1929: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:1932: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:1935: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:1938: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_prog_cxx_g=yes
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_prog_cxx_g=no
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  fi
! echo "$as_me:1948: result: $ac_cv_prog_cxx_g" >&5
! echo "${ECHO_T}$ac_cv_prog_cxx_g" >&6
  if test "$ac_test_CXXFLAGS" = set; then
!   CXXFLAGS=$ac_save_CXXFLAGS
  elif test $ac_cv_prog_cxx_g = yes; then
    if test "$GXX" = yes; then
      CXXFLAGS="-g -O2"
--- 876,1011 ----
      CFLAGS=
    fi
  fi
  
! for ac_prog in $CCC c++ g++ gcc CC cxx cc++ cl
! do
! # Extract the first word of "$ac_prog", so it can be a program name with args.
! set dummy $ac_prog; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:886: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$CXX"; then
    ac_cv_prog_CXX="$CXX" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_CXX="$ac_prog"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! CXX="$ac_cv_prog_CXX"
  if test -n "$CXX"; then
!   echo "$ac_t""$CXX" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
! test -n "$CXX" && break
  done
+ test -n "$CXX" || CXX="gcc"
  
! 
! echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:918: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
! 
! ac_ext=C
! # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
! ac_cpp='$CXXCPP $CPPFLAGS'
! ac_compile='${CXX-g++} -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cxx_cross
! 
! cat > conftest.$ac_ext << EOF
! 
! #line 929 "configure"
! #include "confdefs.h"
! 
! int main(){return(0);}
! EOF
! if { (eval echo configure:934: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   ac_cv_prog_cxx_works=yes
!   # If we can't run a trivial program, we are probably using a cross compiler.
!   if (./conftest; exit) 2>/dev/null; then
!     ac_cv_prog_cxx_cross=no
!   else
!     ac_cv_prog_cxx_cross=yes
!   fi
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   ac_cv_prog_cxx_works=no
  fi
! rm -fr conftest*
! ac_ext=c
! # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
! ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
! cross_compiling=$ac_cv_prog_cc_cross
  
! echo "$ac_t""$ac_cv_prog_cxx_works" 1>&6
! if test $ac_cv_prog_cxx_works = no; then
!   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
  fi
+ echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+ echo "configure:960: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+ echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
+ cross_compiling=$ac_cv_prog_cxx_cross
  
! echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
! echo "configure:965: checking whether we are using GNU C++" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.C <<EOF
! #ifdef __GNUC__
!   yes;
  #endif
! EOF
! if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:974: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
!   ac_cv_prog_gxx=yes
  else
!   ac_cv_prog_gxx=no
! fi
! fi
  
! echo "$ac_t""$ac_cv_prog_gxx" 1>&6
  
! if test $ac_cv_prog_gxx = yes; then
!   GXX=yes
! else
!   GXX=
! fi
! 
! ac_test_CXXFLAGS="${CXXFLAGS+set}"
! ac_save_CXXFLAGS="$CXXFLAGS"
! CXXFLAGS=
! echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
! echo "configure:993: checking whether ${CXX-g++} accepts -g" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   echo 'void f(){}' > conftest.cc
! if test -z "`${CXX-g++} -g -c conftest.cc 2>&1`"; then
    ac_cv_prog_cxx_g=yes
  else
!   ac_cv_prog_cxx_g=no
  fi
! rm -f conftest*
! 
  fi
! 
! echo "$ac_t""$ac_cv_prog_cxx_g" 1>&6
  if test "$ac_test_CXXFLAGS" = set; then
!   CXXFLAGS="$ac_save_CXXFLAGS"
  elif test $ac_cv_prog_cxx_g = yes; then
    if test "$GXX" = yes; then
      CXXFLAGS="-g -O2"
***************
*** 1962,2052 ****
      CXXFLAGS=
    fi
  fi
- for ac_declaration in \
-    ''\
-    '#include <stdlib.h>' \
-    'extern "C" void std::exit (int) throw (); using std::exit;' \
-    'extern "C" void std::exit (int); using std::exit;' \
-    'extern "C" void exit (int) throw ();' \
-    'extern "C" void exit (int);' \
-    'void exit (int);'
- do
-   cat >conftest.$ac_ext <<_ACEOF
- #line 1975 "configure"
- #include "confdefs.h"
- #include <stdlib.h>
- $ac_declaration
- int
- main ()
- {
- exit (42);
-   ;
-   return 0;
- }
- _ACEOF
- rm -f conftest.$ac_objext
- if { (eval echo "$as_me:1988: \"$ac_compile\"") >&5
-   (eval $ac_compile) 2>&5
-   ac_status=$?
-   echo "$as_me:1991: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest.$ac_objext'
-   { (eval echo "$as_me:1994: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:1997: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   :
- else
-   echo "$as_me: failed program was:" >&5
- cat conftest.$ac_ext >&5
- continue
- fi
- rm -f conftest.$ac_objext conftest.$ac_ext
-   cat >conftest.$ac_ext <<_ACEOF
- #line 2007 "configure"
- #include "confdefs.h"
- $ac_declaration
- int
- main ()
- {
- exit (42);
-   ;
-   return 0;
- }
- _ACEOF
- rm -f conftest.$ac_objext
- if { (eval echo "$as_me:2019: \"$ac_compile\"") >&5
-   (eval $ac_compile) 2>&5
-   ac_status=$?
-   echo "$as_me:2022: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest.$ac_objext'
-   { (eval echo "$as_me:2025: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:2028: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   break
- else
-   echo "$as_me: failed program was:" >&5
- cat conftest.$ac_ext >&5
- fi
- rm -f conftest.$ac_objext conftest.$ac_ext
- done
- rm -f conftest*
- if test -n "$ac_declaration"; then
-   echo '#ifdef __cplusplus' >>confdefs.h
-   echo $ac_declaration      >>confdefs.h
-   echo '#endif'             >>confdefs.h
- fi
  
- ac_ext=c
- ac_cpp='$CPP $CPPFLAGS'
- ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
- ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
- ac_compiler_gnu=$ac_cv_c_compiler_gnu
- 
  # Find a good install program.  We prefer a C program (faster),
  # so one script is as good as another.  But avoid the broken or
  # incompatible versions:
--- 1019,1025 ----
***************
*** 2054,2092 ****
  # SunOS /usr/etc/install
  # IRIX /sbin/install
  # AIX /bin/install
- # AmigaOS /C/install, which installs bootblocks on floppy discs
  # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
  # AFS /usr/afsws/bin/install, which mishandles nonexistent args
  # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
  # ./install, which can be erroneously created by make from ./install.sh.
! echo "$as_me:2062: checking for a BSD compatible install" >&5
! echo $ECHO_N "checking for a BSD compatible install... $ECHO_C" >&6
  if test -z "$INSTALL"; then
! if test "${ac_cv_path_install+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!     ac_save_IFS=$IFS; IFS=$ac_path_separator
    for ac_dir in $PATH; do
-     IFS=$ac_save_IFS
      # Account for people who put trailing slashes in PATH elements.
!     case $ac_dir/ in
!     / | ./ | .// | /cC/* \
!     | /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* \
!     | /usr/ucb/* ) ;;
      *)
        # OSF1 and SCO ODT 3.0 have their own names for install.
        # Don't use installbsd from OSF since it installs stuff as root
        # by default.
        for ac_prog in ginstall scoinst install; do
!         if $as_executable_p "$ac_dir/$ac_prog"; then
  	  if test $ac_prog = install &&
!             grep dspmsg "$ac_dir/$ac_prog" >/dev/null 2>&1; then
  	    # AIX install.  It has an incompatible calling convention.
  	    :
- 	  elif test $ac_prog = install &&
- 	    grep pwplus "$ac_dir/$ac_prog" >/dev/null 2>&1; then
- 	    # program-specific install script used by HP pwplus--don't use.
- 	    :
  	  else
  	    ac_cv_path_install="$ac_dir/$ac_prog -c"
  	    break 2
--- 1027,1057 ----
  # SunOS /usr/etc/install
  # IRIX /sbin/install
  # AIX /bin/install
  # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
  # AFS /usr/afsws/bin/install, which mishandles nonexistent args
  # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
  # ./install, which can be erroneously created by make from ./install.sh.
! echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
! echo "configure:1036: checking for a BSD compatible install" >&5
  if test -z "$INSTALL"; then
! if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!     IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
    for ac_dir in $PATH; do
      # Account for people who put trailing slashes in PATH elements.
!     case "$ac_dir/" in
!     /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
      *)
        # OSF1 and SCO ODT 3.0 have their own names for install.
        # Don't use installbsd from OSF since it installs stuff as root
        # by default.
        for ac_prog in ginstall scoinst install; do
!         if test -f $ac_dir/$ac_prog; then
  	  if test $ac_prog = install &&
!             grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
  	    # AIX install.  It has an incompatible calling convention.
  	    :
  	  else
  	    ac_cv_path_install="$ac_dir/$ac_prog -c"
  	    break 2
***************
*** 2096,2750 ****
        ;;
      esac
    done
  
  fi
    if test "${ac_cv_path_install+set}" = set; then
!     INSTALL=$ac_cv_path_install
    else
      # As a last resort, use the slow shell script.  We don't cache a
      # path for INSTALL within a source directory, because that will
      # break other packages using the cache if that directory is
      # removed, or if the path is relative.
!     INSTALL=$ac_install_sh
    fi
  fi
! echo "$as_me:2111: result: $INSTALL" >&5
! echo "${ECHO_T}$INSTALL" >&6
  
  # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
  # It thinks the first close brace ends the variable substitution.
  test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
  
! test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
  
  test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
  
! for ac_prog in flex lex
! do
!   # Extract the first word of "$ac_prog", so it can be a program name with args.
! set dummy $ac_prog; ac_word=$2
! echo "$as_me:2126: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_LEX+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$LEX"; then
    ac_cv_prog_LEX="$LEX" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_LEX="$ac_prog"
! echo "$as_me:2141: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! LEX=$ac_cv_prog_LEX
  if test -n "$LEX"; then
!   echo "$as_me:2149: result: $LEX" >&5
! echo "${ECHO_T}$LEX" >&6
  else
!   echo "$as_me:2152: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
-   test -n "$LEX" && break
- done
- test -n "$LEX" || LEX=":"
- 
  if test -z "$LEXLIB"
  then
!   echo "$as_me:2162: checking for yywrap in -lfl" >&5
! echo $ECHO_N "checking for yywrap in -lfl... $ECHO_C" >&6
! if test "${ac_cv_lib_fl_yywrap+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-lfl  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 2170 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char yywrap ();
! int
! main ()
! {
! yywrap ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:2189: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:2192: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:2195: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2198: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_fl_yywrap=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_fl_yywrap=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:2209: result: $ac_cv_lib_fl_yywrap" >&5
! echo "${ECHO_T}$ac_cv_lib_fl_yywrap" >&6
! if test $ac_cv_lib_fl_yywrap = yes; then
!   LEXLIB="-lfl"
! else
!   echo "$as_me:2214: checking for yywrap in -ll" >&5
! echo $ECHO_N "checking for yywrap in -ll... $ECHO_C" >&6
! if test "${ac_cv_lib_l_yywrap+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   ac_check_lib_save_LIBS=$LIBS
! LIBS="-ll  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 2222 "configure"
! #include "confdefs.h"
  
! /* Override any gcc2 internal prototype to avoid an error.  */
! #ifdef __cplusplus
! extern "C"
! #endif
! /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char yywrap ();
! int
! main ()
! {
! yywrap ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:2241: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:2244: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:2247: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2250: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_l_yywrap=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_l_yywrap=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:2261: result: $ac_cv_lib_l_yywrap" >&5
! echo "${ECHO_T}$ac_cv_lib_l_yywrap" >&6
! if test $ac_cv_lib_l_yywrap = yes; then
!   LEXLIB="-ll"
  fi
  
  fi
! 
  fi
  
- if test "x$LEX" != "x:"; then
-   echo "$as_me:2272: checking lex output file root" >&5
- echo $ECHO_N "checking lex output file root... $ECHO_C" >&6
- if test "${ac_cv_prog_lex_root+set}" = set; then
-   echo $ECHO_N "(cached) $ECHO_C" >&6
- else
-   # The minimal lex program is just a single line: %%.  But some broken lexes
- # (Solaris, I think it was) want two %% lines, so accommodate them.
- echo '%%
- %%' | $LEX
- if test -f lex.yy.c; then
-   ac_cv_prog_lex_root=lex.yy
- elif test -f lexyy.c; then
-   ac_cv_prog_lex_root=lexyy
- else
-   { { echo "$as_me:2286: error: cannot find output from $LEX; giving up" >&5
- echo "$as_me: error: cannot find output from $LEX; giving up" >&2;}
-    { (exit 1); exit 1; }; }
- fi
- fi
- echo "$as_me:2291: result: $ac_cv_prog_lex_root" >&5
- echo "${ECHO_T}$ac_cv_prog_lex_root" >&6
- LEX_OUTPUT_ROOT=$ac_cv_prog_lex_root
- 
- echo "$as_me:2295: checking whether yytext is a pointer" >&5
- echo $ECHO_N "checking whether yytext is a pointer... $ECHO_C" >&6
- if test "${ac_cv_prog_lex_yytext_pointer+set}" = set; then
-   echo $ECHO_N "(cached) $ECHO_C" >&6
- else
-   # POSIX says lex can declare yytext either as a pointer or an array; the
- # default is implementation-dependent. Figure out which it is, since
- # not all implementations provide the %pointer and %array declarations.
- ac_cv_prog_lex_yytext_pointer=no
- echo 'extern char *yytext;' >>$LEX_OUTPUT_ROOT.c
- ac_save_LIBS=$LIBS
- LIBS="$LIBS $LEXLIB"
- cat >conftest.$ac_ext <<_ACEOF
- `cat $LEX_OUTPUT_ROOT.c`
- _ACEOF
- rm -f conftest.$ac_objext conftest$ac_exeext
- if { (eval echo "$as_me:2311: \"$ac_link\"") >&5
-   (eval $ac_link) 2>&5
-   ac_status=$?
-   echo "$as_me:2314: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest$ac_exeext'
-   { (eval echo "$as_me:2317: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:2320: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   ac_cv_prog_lex_yytext_pointer=yes
- else
-   echo "$as_me: failed program was:" >&5
- cat conftest.$ac_ext >&5
- fi
- rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
- LIBS=$ac_save_LIBS
- rm -f "${LEX_OUTPUT_ROOT}.c"
- 
- fi
- echo "$as_me:2332: result: $ac_cv_prog_lex_yytext_pointer" >&5
- echo "${ECHO_T}$ac_cv_prog_lex_yytext_pointer" >&6
- if test $ac_cv_prog_lex_yytext_pointer = yes; then
- 
- cat >>confdefs.h <<\EOF
- #define YYTEXT_POINTER 1
- EOF
- 
  fi
  
- fi
  for ac_prog in 'bison -y' byacc
  do
!   # Extract the first word of "$ac_prog", so it can be a program name with args.
  set dummy $ac_prog; ac_word=$2
! echo "$as_me:2347: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_prog_YACC+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    if test -n "$YACC"; then
    ac_cv_prog_YACC="$YACC" # Let the user override the test.
  else
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   $as_executable_p "$ac_dir/$ac_word" || continue
! ac_cv_prog_YACC="$ac_prog"
! echo "$as_me:2362: found $ac_dir/$ac_word" >&5
! break
! done
! 
  fi
  fi
! YACC=$ac_cv_prog_YACC
  if test -n "$YACC"; then
!   echo "$as_me:2370: result: $YACC" >&5
! echo "${ECHO_T}$YACC" >&6
  else
!   echo "$as_me:2373: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
!   test -n "$YACC" && break
  done
  test -n "$YACC" || YACC="yacc"
  
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! echo "$as_me:2386: checking how to run the C preprocessor" >&5
! echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
    CPP=
  fi
  if test -z "$CPP"; then
!   if test "${ac_cv_prog_CPP+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!       # Double quotes because CPP needs to be expanded
!     for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
!     do
!       ac_preproc_ok=false
! for ac_c_preproc_warn_flag in '' yes
! do
!   # Use a header file that comes with gcc, so configuring glibc
!   # with a fresh cross-compiler works.
    # On the NeXT, cc -E runs the code through the compiler's parser,
!   # not just through cpp. "Syntax error" is here to catch this case.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2407 "configure"
  #include "confdefs.h"
  #include <assert.h>
!                      Syntax error
! _ACEOF
! if { (eval echo "$as_me:2412: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2418: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
    :
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   # Broken: fails on valid input.
! continue
! fi
! rm -f conftest.err conftest.$ac_ext
! 
!   # OK, works on sane cases.  Now check whether non-existent headers
!   # can be detected and how.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2441 "configure"
  #include "confdefs.h"
! #include <ac_nonexistent.h>
! _ACEOF
! if { (eval echo "$as_me:2445: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2451: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   # Broken: success on invalid input.
! continue
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   # Passes both tests.
! ac_preproc_ok=:
! break
! fi
! rm -f conftest.err conftest.$ac_ext
! 
! done
! # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
! rm -f conftest.err conftest.$ac_ext
! if $ac_preproc_ok; then
!   break
! fi
! 
!     done
!     ac_cv_prog_CPP=$CPP
! 
! fi
!   CPP=$ac_cv_prog_CPP
! else
!   ac_cv_prog_CPP=$CPP
! fi
! echo "$as_me:2488: result: $CPP" >&5
! echo "${ECHO_T}$CPP" >&6
! ac_preproc_ok=false
! for ac_c_preproc_warn_flag in '' yes
! do
!   # Use a header file that comes with gcc, so configuring glibc
!   # with a fresh cross-compiler works.
!   # On the NeXT, cc -E runs the code through the compiler's parser,
!   # not just through cpp. "Syntax error" is here to catch this case.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2498 "configure"
  #include "confdefs.h"
  #include <assert.h>
!                      Syntax error
! _ACEOF
! if { (eval echo "$as_me:2503: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2509: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
    :
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   # Broken: fails on valid input.
! continue
  fi
! rm -f conftest.err conftest.$ac_ext
! 
!   # OK, works on sane cases.  Now check whether non-existent headers
!   # can be detected and how.
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2532 "configure"
! #include "confdefs.h"
! #include <ac_nonexistent.h>
! _ACEOF
! if { (eval echo "$as_me:2536: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2542: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
  fi
! if test -z "$ac_cpp_err"; then
!   # Broken: success on invalid input.
! continue
! else
!   echo "$as_me: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   # Passes both tests.
! ac_preproc_ok=:
! break
  fi
! rm -f conftest.err conftest.$ac_ext
! 
! done
! # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
! rm -f conftest.err conftest.$ac_ext
! if $ac_preproc_ok; then
!   :
  else
!   { { echo "$as_me:2570: error: C preprocessor \"$CPP\" fails sanity check" >&5
! echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check" >&2;}
!    { (exit 1); exit 1; }; }
  fi
  
! ac_ext=c
! ac_cpp='$CPP $CPPFLAGS'
! ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
! ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
! ac_compiler_gnu=$ac_cv_c_compiler_gnu
! 
! echo "$as_me:2581: checking for AIX" >&5
! echo $ECHO_N "checking for AIX... $ECHO_C" >&6
! cat >conftest.$ac_ext <<_ACEOF
! #line 2584 "configure"
  #include "confdefs.h"
  #ifdef _AIX
    yes
  #endif
  
! _ACEOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "yes" >/dev/null 2>&1; then
!   echo "$as_me:2593: result: yes" >&5
! echo "${ECHO_T}yes" >&6
! cat >>confdefs.h <<\EOF
  #define _ALL_SOURCE 1
  EOF
  
  else
!   echo "$as_me:2600: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  rm -f conftest*
  
- echo "$as_me:2605: checking for $CC option to accept ANSI C" >&5
- echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
- if test "${ac_cv_prog_cc_stdc+set}" = set; then
-   echo $ECHO_N "(cached) $ECHO_C" >&6
- else
-   ac_cv_prog_cc_stdc=no
- ac_save_CC=$CC
- cat >conftest.$ac_ext <<_ACEOF
- #line 2613 "configure"
- #include "confdefs.h"
- #include <stdarg.h>
- #include <stdio.h>
- #include <sys/types.h>
- #include <sys/stat.h>
- /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
- struct buf { int x; };
- FILE * (*rcsopen) (struct buf *, struct stat *, int);
- static char *e (p, i)
-      char **p;
-      int i;
- {
-   return p[i];
- }
- static char *f (char * (*g) (char **, int), char **p, ...)
- {
-   char *s;
-   va_list v;
-   va_start (v,p);
-   s = g (p, va_arg (v,int));
-   va_end (v);
-   return s;
- }
- int test (int i, double x);
- struct s1 {int (*f) (int a);};
- struct s2 {int (*f) (double a);};
- int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
- int argc;
- char **argv;
- int
- main ()
- {
- return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-   ;
-   return 0;
- }
- _ACEOF
- # Don't try gcc -ansi; that turns off useful extensions and
- # breaks some systems' header files.
- # AIX			-qlanglvl=ansi
- # Ultrix and OSF/1	-std1
- # HP-UX 10.20 and later	-Ae
- # HP-UX older versions	-Aa -D_HPUX_SOURCE
- # SVR4			-Xc -D__EXTENSIONS__
- for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
- do
-   CC="$ac_save_CC $ac_arg"
-   rm -f conftest.$ac_objext
- if { (eval echo "$as_me:2662: \"$ac_compile\"") >&5
-   (eval $ac_compile) 2>&5
-   ac_status=$?
-   echo "$as_me:2665: \$? = $ac_status" >&5
-   (exit $ac_status); } &&
-          { ac_try='test -s conftest.$ac_objext'
-   { (eval echo "$as_me:2668: \"$ac_try\"") >&5
-   (eval $ac_try) 2>&5
-   ac_status=$?
-   echo "$as_me:2671: \$? = $ac_status" >&5
-   (exit $ac_status); }; }; then
-   ac_cv_prog_cc_stdc=$ac_arg
- break
- else
-   echo "$as_me: failed program was:" >&5
- cat conftest.$ac_ext >&5
- fi
- rm -f conftest.$ac_objext
- done
- rm -f conftest.$ac_ext conftest.$ac_objext
- CC=$ac_save_CC
- 
- fi
- 
- case "x$ac_cv_prog_cc_stdc" in
-   x|xno)
-     echo "$as_me:2688: result: none needed" >&5
- echo "${ECHO_T}none needed" >&6 ;;
-   *)
-     echo "$as_me:2691: result: $ac_cv_prog_cc_stdc" >&5
- echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
-     CC="$CC $ac_cv_prog_cc_stdc" ;;
- esac
  
! echo "$as_me:2696: checking for inline" >&5
! echo $ECHO_N "checking for inline... $ECHO_C" >&6
! if test "${ac_cv_c_inline+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
    ac_cv_c_inline=no
  for ac_kw in inline __inline__ __inline; do
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2704 "configure"
  #include "confdefs.h"
- #ifndef __cplusplus
- static $ac_kw int static_foo () {return 0; }
- $ac_kw int foo () {return 0; }
- #endif
  
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:2713: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:2716: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:2719: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:2722: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    ac_cv_c_inline=$ac_kw; break
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  done
  
  fi
! echo "$as_me:2733: result: $ac_cv_c_inline" >&5
! echo "${ECHO_T}$ac_cv_c_inline" >&6
! case $ac_cv_c_inline in
    inline | yes) ;;
!   no)
! cat >>confdefs.h <<\EOF
! #define inline
  EOF
   ;;
!   *)  cat >>confdefs.h <<EOF
  #define inline $ac_cv_c_inline
  EOF
   ;;
  esac
  
  sed_script='s/,/.so /g'
  
  # Check whether --enable-opt-modules or --disable-opt-modules was given.
--- 1061,1347 ----
        ;;
      esac
    done
+   IFS="$ac_save_IFS"
  
  fi
    if test "${ac_cv_path_install+set}" = set; then
!     INSTALL="$ac_cv_path_install"
    else
      # As a last resort, use the slow shell script.  We don't cache a
      # path for INSTALL within a source directory, because that will
      # break other packages using the cache if that directory is
      # removed, or if the path is relative.
!     INSTALL="$ac_install_sh"
    fi
  fi
! echo "$ac_t""$INSTALL" 1>&6
  
  # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
  # It thinks the first close brace ends the variable substitution.
  test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
  
! test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
  
  test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
  
! # Extract the first word of "flex", so it can be a program name with args.
! set dummy flex; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1091: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_LEX'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$LEX"; then
    ac_cv_prog_LEX="$LEX" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_LEX="flex"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
!   test -z "$ac_cv_prog_LEX" && ac_cv_prog_LEX="lex"
  fi
  fi
! LEX="$ac_cv_prog_LEX"
  if test -n "$LEX"; then
!   echo "$ac_t""$LEX" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
  if test -z "$LEXLIB"
  then
!   case "$LEX" in
!   flex*) ac_lib=fl ;;
!   *) ac_lib=l ;;
!   esac
!   echo $ac_n "checking for yywrap in -l$ac_lib""... $ac_c" 1>&6
! echo "configure:1125: checking for yywrap in -l$ac_lib" >&5
! ac_lib_var=`echo $ac_lib'_'yywrap | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   ac_save_LIBS="$LIBS"
! LIBS="-l$ac_lib  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1133 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char yywrap();
  
! int main() {
! yywrap()
! ; return 0; }
! EOF
! if { (eval echo configure:1144: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
  fi
+ rm -f conftest*
+ LIBS="$ac_save_LIBS"
  
  fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   LEXLIB="-l$ac_lib"
! else
!   echo "$ac_t""no" 1>&6
  fi
  
  fi
  
  for ac_prog in 'bison -y' byacc
  do
! # Extract the first word of "$ac_prog", so it can be a program name with args.
  set dummy $ac_prog; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1171: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    if test -n "$YACC"; then
    ac_cv_prog_YACC="$YACC" # Let the user override the test.
  else
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH"
!   for ac_dir in $ac_dummy; do
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_prog_YACC="$ac_prog"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
  fi
  fi
! YACC="$ac_cv_prog_YACC"
  if test -n "$YACC"; then
!   echo "$ac_t""$YACC" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
! test -n "$YACC" && break
  done
  test -n "$YACC" || YACC="yacc"
  
! echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:1202: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
    CPP=
  fi
  if test -z "$CPP"; then
! if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!     # This must be in double quotes, not single quotes, because CPP may get
!   # substituted into the Makefile and "${CC-cc}" will confuse make.
!   CPP="${CC-cc} -E"
    # On the NeXT, cc -E runs the code through the compiler's parser,
!   # not just through cpp.
!   cat > conftest.$ac_ext <<EOF
! #line 1217 "configure"
  #include "confdefs.h"
  #include <assert.h>
! Syntax Error
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1223: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
    :
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   CPP="${CC-cc} -E -traditional-cpp"
!   cat > conftest.$ac_ext <<EOF
! #line 1234 "configure"
  #include "confdefs.h"
! #include <assert.h>
! Syntax Error
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1240: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   :
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   CPP="${CC-cc} -nologo -E"
!   cat > conftest.$ac_ext <<EOF
! #line 1251 "configure"
  #include "confdefs.h"
  #include <assert.h>
! Syntax Error
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1257: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
    :
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   CPP=/lib/cpp
  fi
! rm -f conftest*
  fi
! rm -f conftest*
  fi
! rm -f conftest*
!   ac_cv_prog_CPP="$CPP"
! fi
!   CPP="$ac_cv_prog_CPP"
  else
!   ac_cv_prog_CPP="$CPP"
  fi
+ echo "$ac_t""$CPP" 1>&6
  
! echo $ac_n "checking for AIX""... $ac_c" 1>&6
! echo "configure:1282: checking for AIX" >&5
! cat > conftest.$ac_ext <<EOF
! #line 1284 "configure"
  #include "confdefs.h"
  #ifdef _AIX
    yes
  #endif
  
! EOF
  if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
    egrep "yes" >/dev/null 2>&1; then
!   rm -rf conftest*
!   echo "$ac_t""yes" 1>&6; cat >> confdefs.h <<\EOF
  #define _ALL_SOURCE 1
  EOF
  
  else
!   rm -rf conftest*
!   echo "$ac_t""no" 1>&6
  fi
  rm -f conftest*
  
  
! echo $ac_n "checking for inline""... $ac_c" 1>&6
! echo "configure:1306: checking for inline" >&5
! if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
    ac_cv_c_inline=no
  for ac_kw in inline __inline__ __inline; do
!   cat > conftest.$ac_ext <<EOF
! #line 1313 "configure"
  #include "confdefs.h"
  
! int main() {
! } $ac_kw foo() {
! ; return 0; }
! EOF
! if { (eval echo configure:1320: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
    ac_cv_c_inline=$ac_kw; break
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
  fi
! rm -f conftest*
  done
  
  fi
! 
! echo "$ac_t""$ac_cv_c_inline" 1>&6
! case "$ac_cv_c_inline" in
    inline | yes) ;;
!   no) cat >> confdefs.h <<\EOF
! #define inline 
  EOF
   ;;
!   *)  cat >> confdefs.h <<EOF
  #define inline $ac_cv_c_inline
  EOF
   ;;
  esac
  
+ 
  sed_script='s/,/.so /g'
  
  # Check whether --enable-opt-modules or --disable-opt-modules was given.
***************
*** 2752,2799 ****
    enableval="$enable_opt_modules"
    \
  OPT_MODS=`echo $enable_opt_modules | sed "$sed_script"`.so
! fi;
  
  # Check whether --enable-large-files or --disable-large-files was given.
  if test "${enable_large_files+set}" = set; then
    enableval="$enable_large_files"
    \
  large_files="yes"
! fi;
  
  # Check whether --enable-static-modules or --disable-static-modules was given.
  if test "${enable_static_modules+set}" = set; then
    enableval="$enable_static_modules"
    \
  static_modules="yes"
! fi;
  
  # Check whether --enable-db-locks or --disable-db-locks was given.
  if test "${enable_db_locks+set}" = set; then
    enableval="$enable_db_locks"
    \
! cat >>confdefs.h <<\EOF
  #define USE_INTERNAL_DB_LOCKS 1
  EOF
  
! fi;
  
  # Check whether --enable-oops-user or --disable-oops-user was given.
  if test "${enable_oops_user+set}" = set; then
    enableval="$enable_oops_user"
    \
  OOPS_USER="$enableval"
! fi;
  
  # Check whether --enable-tnf-probes or --disable-tnf-probes was given.
  if test "${enable_tnf_probes+set}" = set; then
    enableval="$enable_tnf_probes"
    \
! cat >>confdefs.h <<\EOF
  #define TNF_ENABLED 1
  EOF
  
- fi;
  
  # Check whether --with-DB or --without-DB was given.
  if test "${with_DB+set}" = set; then
--- 1349,1402 ----
    enableval="$enable_opt_modules"
    \
  OPT_MODS=`echo $enable_opt_modules | sed "$sed_script"`.so
! fi
! 
  
  # Check whether --enable-large-files or --disable-large-files was given.
  if test "${enable_large_files+set}" = set; then
    enableval="$enable_large_files"
    \
  large_files="yes"
! fi
! 
  
  # Check whether --enable-static-modules or --disable-static-modules was given.
  if test "${enable_static_modules+set}" = set; then
    enableval="$enable_static_modules"
    \
  static_modules="yes"
! fi
! 
  
  # Check whether --enable-db-locks or --disable-db-locks was given.
  if test "${enable_db_locks+set}" = set; then
    enableval="$enable_db_locks"
    \
! cat >> confdefs.h <<\EOF
  #define USE_INTERNAL_DB_LOCKS 1
  EOF
  
! fi
! 
  
  # Check whether --enable-oops-user or --disable-oops-user was given.
  if test "${enable_oops_user+set}" = set; then
    enableval="$enable_oops_user"
    \
  OOPS_USER="$enableval"
! fi
  
+ 
  # Check whether --enable-tnf-probes or --disable-tnf-probes was given.
  if test "${enable_tnf_probes+set}" = set; then
    enableval="$enable_tnf_probes"
    \
! cat >> confdefs.h <<\EOF
  #define TNF_ENABLED 1
  EOF
+ 
+ fi
  
  
  # Check whether --with-DB or --without-DB was given.
  if test "${with_DB+set}" = set; then
***************
*** 2802,2809 ****
  LIBDB_PATH=$withval
  else
    LIBDB_PATH=""
! fi;
  
  # Check whether --with-GB or --without-GB was given.
  if test "${with_GB+set}" = set; then
    withval="$with_GB"
--- 1405,1413 ----
  LIBDB_PATH=$withval
  else
    LIBDB_PATH=""
! fi
  
+ 
  # Check whether --with-GB or --without-GB was given.
  if test "${with_GB+set}" = set; then
    withval="$with_GB"
***************
*** 2811,2817 ****
  LIBGB_PATH=$withval
  else
    LIBGB_PATH=""
! fi;
  
  # Check whether --with-MYSQL or --without-MYSQL was given.
  if test "${with_MYSQL+set}" = set; then
--- 1415,1422 ----
  LIBGB_PATH=$withval
  else
    LIBGB_PATH=""
! fi
! 
  
  # Check whether --with-MYSQL or --without-MYSQL was given.
  if test "${with_MYSQL+set}" = set; then
***************
*** 2820,2826 ****
  MYSQL_PATH=$withval
  else
    MYSQL_PATH=""
! fi;
  
  # Check whether --with-PGSQL or --without-PGSQL was given.
  if test "${with_PGSQL+set}" = set; then
--- 1425,1432 ----
  MYSQL_PATH=$withval
  else
    MYSQL_PATH=""
! fi
! 
  
  # Check whether --with-PGSQL or --without-PGSQL was given.
  if test "${with_PGSQL+set}" = set; then
***************
*** 2829,2835 ****
  LIBPG_PATH=$withval
  else
    LIBPG_PATH=""
! fi;
  
  # Check whether --with-regexp or --without-regexp was given.
  if test "${with_regexp+set}" = set; then
--- 1435,1442 ----
  LIBPG_PATH=$withval
  else
    LIBPG_PATH=""
! fi
! 
  
  # Check whether --with-regexp or --without-regexp was given.
  if test "${with_regexp+set}" = set; then
***************
*** 2837,2843 ****
    regexp_val="$withval"
  else
    regexp_val="builtin"
! fi;
  
  # Check whether --with-malloc or --without-malloc was given.
  if test "${with_malloc+set}" = set; then
--- 1444,1451 ----
    regexp_val="$withval"
  else
    regexp_val="builtin"
! fi
! 
  
  # Check whether --with-malloc or --without-malloc was given.
  if test "${with_malloc+set}" = set; then
***************
*** 2845,3014 ****
    with_malloc="$withval"
  else
    with_malloc=""
! fi;
  
  # Check whether --with-zlib or --without-zlib was given.
  if test "${with_zlib+set}" = set; then
    withval="$with_zlib"
    with_zlib="$withval"
  else
    with_zlib=""
! fi;
  
! for ac_header in crypt.h getopt.h pthread.h stdlib.h string.h strings.h unistd.h sys/inttypes.h
  do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:2861: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
! else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2867 "configure"
! #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:2871: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2877: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
  else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
! else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
  fi
! rm -f conftest.err conftest.$ac_ext
  fi
! echo "$as_me:2896: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
! 
  fi
  done
  
! for ac_header in netinet/ip_fil.h
  do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:2909: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2915 "configure"
  #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:2919: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2925: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
  fi
! rm -f conftest.err conftest.$ac_ext
  fi
! echo "$as_me:2944: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
!  cat >>confdefs.h <<\EOF
  #define HAVE_IPF 1
  EOF
  
  fi
  done
  
! for ac_header in netinet/ip6.h
  do
! as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
! echo "$as_me:2960: checking for $ac_header" >&5
! echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
! if eval "test \"\${$as_ac_Header+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 2966 "configure"
  #include "confdefs.h"
! #include <$ac_header>
! _ACEOF
! if { (eval echo "$as_me:2970: \"$ac_cpp conftest.$ac_ext\"") >&5
!   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
!   ac_status=$?
!   egrep -v '^ *\+' conftest.er1 >conftest.err
!   rm -f conftest.er1
!   cat conftest.err >&5
!   echo "$as_me:2976: \$? = $ac_status" >&5
!   (exit $ac_status); } >/dev/null; then
!   if test -s conftest.err; then
!     ac_cpp_err=$ac_c_preproc_warn_flag
!   else
!     ac_cpp_err=
!   fi
! else
!   ac_cpp_err=yes
! fi
! if test -z "$ac_cpp_err"; then
!   eval "$as_ac_Header=yes"
  else
!   echo "$as_me: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   eval "$as_ac_Header=no"
  fi
! rm -f conftest.err conftest.$ac_ext
  fi
! echo "$as_me:2995: result: `eval echo '${'$as_ac_Header'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
! if test `eval echo '${'$as_ac_Header'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
  EOF
!  cat >>confdefs.h <<\EOF
  #define HAVE_IP6_H 1
  EOF
  
  fi
  done
  
  pwd=`pwd`
  LIBDB_NAME=-ldb
! echo "$as_me:3010: checking for libdb.a" >&5
! echo $ECHO_N "checking for libdb.a... $ECHO_C" >&6
  if test "X$LIBDB_PATH" != "X" ; then
      LIBDB_PATH=$LIBDB_PATH
  elif test -r "/usr/local/BerkeleyDB/lib/libdb.a"; then
--- 1453,1601 ----
    with_malloc="$withval"
  else
    with_malloc=""
! fi
  
+ 
  # Check whether --with-zlib or --without-zlib was given.
  if test "${with_zlib+set}" = set; then
    withval="$with_zlib"
    with_zlib="$withval"
  else
    with_zlib=""
! fi
  
! 
! for ac_hdr in crypt.h getopt.h pthread.h stdlib.h string.h strings.h unistd.h sys/inttypes.h
  do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:1473: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
! else
!   cat > conftest.$ac_ext <<EOF
! #line 1478 "configure"
! #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1483: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  
! else
!   echo "$ac_t""no" 1>&6
  fi
  done
  
! for ac_hdr in netinet/ip_fil.h
  do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:1513: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 1518 "configure"
  #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1523: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  cat >> confdefs.h <<\EOF
  #define HAVE_IPF 1
  EOF
  
+ else
+   echo "$ac_t""no" 1>&6
  fi
  done
  
! for ac_hdr in netinet/ip6.h
  do
! ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
! echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:1556: checking for $ac_hdr" >&5
! if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 1561 "configure"
  #include "confdefs.h"
! #include <$ac_hdr>
! EOF
! ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1566: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
! ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
! if test -z "$ac_err"; then
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=yes"
  else
!   echo "$ac_err" >&5
!   echo "configure: failed program was:" >&5
    cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_header_$ac_safe=no"
  fi
! rm -f conftest*
  fi
! if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_hdr 1
  EOF
!  cat >> confdefs.h <<\EOF
  #define HAVE_IP6_H 1
  EOF
  
+ else
+   echo "$ac_t""no" 1>&6
  fi
  done
  
+ 
  pwd=`pwd`
  LIBDB_NAME=-ldb
! echo $ac_n "checking for libdb.a""... $ac_c" 1>&6
! echo "configure:1599: checking for libdb.a" >&5
  if test "X$LIBDB_PATH" != "X" ; then
      LIBDB_PATH=$LIBDB_PATH
  elif test -r "/usr/local/BerkeleyDB/lib/libdb.a"; then
***************
*** 3021,3029 ****
      LIBDB_PATH="$pwd"
  elif test -r "/usr/local/lib/libdb.a"; then
      LIBDB_PATH="/usr/local"
! elif test -r "/usr/lib/libdb2.a"; then
!     LIBDB_PATH="/usr"
!     LIBDB_NAME=-ldb2
  elif test -r "/usr/lib/libdb.a"; then
      LIBDB_PATH="/usr"
  elif test -r "/usr/local/lib/libdb2.a"; then
--- 1608,1616 ----
      LIBDB_PATH="$pwd"
  elif test -r "/usr/local/lib/libdb.a"; then
      LIBDB_PATH="/usr/local"
! elif test -r "/usr/lib/libdb2.a"; then                                         
!     LIBDB_PATH="/usr"                                                          
!     LIBDB_NAME=-ldb2                                                           
  elif test -r "/usr/lib/libdb.a"; then
      LIBDB_PATH="/usr"
  elif test -r "/usr/local/lib/libdb2.a"; then
***************
*** 3048,3061 ****
      LIBDB_PATH="no"
  fi
  
! echo "$as_me:3051: result: $LIBDB_PATH" >&5
! echo "${ECHO_T}$LIBDB_PATH" >&6
  
  if test "X$LIBDB_PATH" = "Xno" ; then
      LIBDB_PATH=""
      LIBDB_NAME=""
  else
!     cat >>confdefs.h <<\EOF
  #define HAVE_BERKELEYDB 1
  EOF
  
--- 1635,1647 ----
      LIBDB_PATH="no"
  fi
  
! echo "$ac_t""$LIBDB_PATH" 1>&6
  
  if test "X$LIBDB_PATH" = "Xno" ; then
      LIBDB_PATH=""
      LIBDB_NAME=""
  else
!     cat >> confdefs.h <<\EOF
  #define HAVE_BERKELEYDB 1
  EOF
  
***************
*** 3081,3096 ****
  
  CFLAGS="$CFLAGS $LIBDB_INCL"
  
! echo "$as_me:3084: checking for GigaBASE" >&5
! echo $ECHO_N "checking for GigaBASE... $ECHO_C" >&6
  if test "$LIBGB_PATH" = "no" ; then
!     echo "$as_me:3087: result: disabled" >&5
! echo "${ECHO_T}disabled" >&6
      LIBGB_PATH=""
      LIBGB_NAME=""
  elif test "X$LIBGB_PATH" != "X" ; then
!     echo "$as_me:3092: result: $LIBGB_PATH" >&5
! echo "${ECHO_T}$LIBGB_PATH" >&6
  elif test -r "/usr/local/lib/libgigabase_r.a"; then
      LIBGB_INCL="-I/usr/local/include -I/usr/local/include/gigabase"
      LIBGB_NAME="-lgigabase_r"
--- 1667,1680 ----
  
  CFLAGS="$CFLAGS $LIBDB_INCL"
  
! echo $ac_n "checking for GigaBASE""... $ac_c" 1>&6
! echo "configure:1672: checking for GigaBASE" >&5
  if test "$LIBGB_PATH" = "no" ; then
!     echo "$ac_t""disabled" 1>&6
      LIBGB_PATH=""
      LIBGB_NAME=""
  elif test "X$LIBGB_PATH" != "X" ; then
!     echo "$ac_t""$LIBGB_PATH" 1>&6
  elif test -r "/usr/local/lib/libgigabase_r.a"; then
      LIBGB_INCL="-I/usr/local/include -I/usr/local/include/gigabase"
      LIBGB_NAME="-lgigabase_r"
***************
*** 3121,3679 ****
      if test "X$LIBGB_PATH" = "X$LIBDB_PATH" ; then
  	LIBGB_PATH=""
      fi
!     cat >>confdefs.h <<\EOF
  #define HAVE_GIGABASE 1
  EOF
  
!     echo "$as_me:3128: result: $LIBGB_NAME" >&5
! echo "${ECHO_T}$LIBGB_NAME" >&6
  else
!     echo "$as_me:3131: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
! echo "$as_me:3135: checking for libz" >&5
! echo $ECHO_N "checking for libz... $ECHO_C" >&6
  LIBZ_NAME=""
  if  test "$with_zlib" = "no" ; then
!     echo "$as_me:3139: result: disabled" >&5
! echo "${ECHO_T}disabled" >&6
  elif test "X$with_zlib" != "X" ; then
      LIBZ_NAME="$with_zlib"
  elif test -r "/usr/local/lib/libz.a"; then
      LIBZ_NAME="/usr/local/lib/libz.a"
!     cat >>confdefs.h <<\EOF
  #define HAVE_ZLIB 1
  EOF
  
!     echo "$as_me:3149: result: /usr/local/lib/libz.a" >&5
! echo "${ECHO_T}/usr/local/lib/libz.a" >&6
      if test "X`echo $CFLAGS | grep '\-I/usr/local/include'`" = "X"; then
  	CFLAGS="$CFLAGS -I/usr/local/include"
      fi
  elif test -r "/usr/lib/libz.a"; then
      LIBZ_NAME="/usr/lib/libz.a"
!     cat >>confdefs.h <<\EOF
  #define HAVE_ZLIB 1
  EOF
  
!     echo "$as_me:3160: result: /usr/lib/libz.a" >&5
! echo "${ECHO_T}/usr/lib/libz.a" >&6
  else
      LIBZ_NAME=""
!     echo "$as_me:3164: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
! echo "$as_me:3168: checking for pthread_create in -lpthread" >&5
! echo $ECHO_N "checking for pthread_create in -lpthread... $ECHO_C" >&6
! if test "${ac_cv_lib_pthread_pthread_create+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lpthread  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3176 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char pthread_create ();
! int
! main ()
! {
! pthread_create ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3195: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3198: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3201: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3204: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_pthread_pthread_create=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_pthread_pthread_create=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3215: result: $ac_cv_lib_pthread_pthread_create" >&5
! echo "${ECHO_T}$ac_cv_lib_pthread_pthread_create" >&6
! if test $ac_cv_lib_pthread_pthread_create = yes; then
    pthread_in=pthread
  else
!   pthread_in=no
  fi
  
  if test "$pthread_in" = no; then
! echo "$as_me:3224: checking for pthread_create in -lpthreads" >&5
! echo $ECHO_N "checking for pthread_create in -lpthreads... $ECHO_C" >&6
! if test "${ac_cv_lib_pthreads_pthread_create+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lpthreads  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3232 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char pthread_create ();
! int
! main ()
! {
! pthread_create ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3251: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3254: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3257: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3260: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_pthreads_pthread_create=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_pthreads_pthread_create=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3271: result: $ac_cv_lib_pthreads_pthread_create" >&5
! echo "${ECHO_T}$ac_cv_lib_pthreads_pthread_create" >&6
! if test $ac_cv_lib_pthreads_pthread_create = yes; then
    pthread_in=pthreads
  else
!   pthread_in=no
  fi
  
  fi
  
  if test "$static_modules" != "yes" ; then
!     echo "$as_me:3282: checking for dlopen in -ldl" >&5
! echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
! if test "${ac_cv_lib_dl_dlopen+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-ldl  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3290 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char dlopen ();
! int
! main ()
! {
! dlopen ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3309: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3312: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3315: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3318: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_dl_dlopen=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_dl_dlopen=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3329: result: $ac_cv_lib_dl_dlopen" >&5
! echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
! if test $ac_cv_lib_dl_dlopen = yes; then
    dlopen_in=dl
  else
!   dlopen_in=no
  fi
  
      if test "$dlopen_in" = no; then
!     echo "$as_me:3338: checking for dlopen in -lc" >&5
! echo $ECHO_N "checking for dlopen in -lc... $ECHO_C" >&6
! if test "${ac_cv_lib_c_dlopen+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lc  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3346 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char dlopen ();
! int
! main ()
! {
! dlopen ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3365: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3368: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3371: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3374: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_c_dlopen=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_c_dlopen=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3385: result: $ac_cv_lib_c_dlopen" >&5
! echo "${ECHO_T}$ac_cv_lib_c_dlopen" >&6
! if test $ac_cv_lib_c_dlopen = yes; then
    dlopen_in=c
  else
!   dlopen_in=no
  fi
  
      fi
      if test "$dlopen_in" = no; then
!     echo "$as_me:3395: checking for dlopen in -lposix" >&5
! echo $ECHO_N "checking for dlopen in -lposix... $ECHO_C" >&6
! if test "${ac_cv_lib_posix_dlopen+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lposix  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3403 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char dlopen ();
! int
! main ()
! {
! dlopen ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3422: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3425: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3428: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3431: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_posix_dlopen=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_posix_dlopen=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3442: result: $ac_cv_lib_posix_dlopen" >&5
! echo "${ECHO_T}$ac_cv_lib_posix_dlopen" >&6
! if test $ac_cv_lib_posix_dlopen = yes; then
    dlopen_in=posix
  else
!   dlopen=no
  fi
  
      fi
  fi
  
! echo "$as_me:3453: checking for yywrap in -lfl" >&5
! echo $ECHO_N "checking for yywrap in -lfl... $ECHO_C" >&6
! if test "${ac_cv_lib_fl_yywrap+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lfl  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3461 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char yywrap ();
! int
! main ()
! {
! yywrap ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3480: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3483: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3486: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3489: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_fl_yywrap=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_fl_yywrap=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3500: result: $ac_cv_lib_fl_yywrap" >&5
! echo "${ECHO_T}$ac_cv_lib_fl_yywrap" >&6
! if test $ac_cv_lib_fl_yywrap = yes; then
    need_lfl="-lfl"
  else
!   need_lfl=""
  fi
  
! echo "$as_me:3508: checking for crypt in -lcrypt" >&5
! echo $ECHO_N "checking for crypt in -lcrypt... $ECHO_C" >&6
! if test "${ac_cv_lib_crypt_crypt+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lcrypt  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3516 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char crypt ();
! int
! main ()
! {
! crypt ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3535: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3538: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3541: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3544: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_crypt_crypt=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_crypt_crypt=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3555: result: $ac_cv_lib_crypt_crypt" >&5
! echo "${ECHO_T}$ac_cv_lib_crypt_crypt" >&6
! if test $ac_cv_lib_crypt_crypt = yes; then
    LIBS="$LIBS -lcrypt"
  fi
  
! echo "$as_me:3561: checking for pam_end in -lpam" >&5
! echo $ECHO_N "checking for pam_end in -lpam... $ECHO_C" >&6
! if test "${ac_cv_lib_pam_pam_end+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-lpam  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3569 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char pam_end ();
! int
! main ()
! {
! pam_end ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3588: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3591: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3594: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3597: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_pam_pam_end=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_pam_pam_end=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3608: result: $ac_cv_lib_pam_pam_end" >&5
! echo "${ECHO_T}$ac_cv_lib_pam_pam_end" >&6
! if test $ac_cv_lib_pam_pam_end = yes; then
!   cat >>confdefs.h <<EOF
! #define HAVE_LIBPAM 1
  EOF
  
    LIBS="-lpam $LIBS"
  
  fi
  
  if test "$enable_tnf_probes" = "yes" ; then
! 
! echo "$as_me:3621: checking for tnf_probe_debug in -ltnfprobe" >&5
! echo $ECHO_N "checking for tnf_probe_debug in -ltnfprobe... $ECHO_C" >&6
! if test "${ac_cv_lib_tnfprobe_tnf_probe_debug+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   ac_check_lib_save_LIBS=$LIBS
  LIBS="-ltnfprobe  $LIBS"
! cat >conftest.$ac_ext <<_ACEOF
! #line 3629 "configure"
  #include "confdefs.h"
- 
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char tnf_probe_debug ();
! int
! main ()
! {
! tnf_probe_debug ();
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:3648: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:3651: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:3654: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3657: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_lib_tnfprobe_tnf_probe_debug=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_lib_tnfprobe_tnf_probe_debug=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! LIBS=$ac_check_lib_save_LIBS
! fi
! echo "$as_me:3668: result: $ac_cv_lib_tnfprobe_tnf_probe_debug" >&5
! echo "${ECHO_T}$ac_cv_lib_tnfprobe_tnf_probe_debug" >&6
! if test $ac_cv_lib_tnfprobe_tnf_probe_debug = yes; then
!   cat >>confdefs.h <<EOF
! #define HAVE_LIBTNFPROBE 1
  EOF
  
    LIBS="-ltnfprobe $LIBS"
  
  fi
  
  fi
--- 1705,2137 ----
      if test "X$LIBGB_PATH" = "X$LIBDB_PATH" ; then
  	LIBGB_PATH=""
      fi
!     cat >> confdefs.h <<\EOF
  #define HAVE_GIGABASE 1
  EOF
  
!     echo "$ac_t""$LIBGB_NAME" 1>&6
  else
!     echo "$ac_t""no" 1>&6
  fi
  
! echo $ac_n "checking for libz""... $ac_c" 1>&6
! echo "configure:1719: checking for libz" >&5
  LIBZ_NAME=""
  if  test "$with_zlib" = "no" ; then
!     echo "$ac_t""disabled" 1>&6
  elif test "X$with_zlib" != "X" ; then
      LIBZ_NAME="$with_zlib"
  elif test -r "/usr/local/lib/libz.a"; then
      LIBZ_NAME="/usr/local/lib/libz.a"
!     cat >> confdefs.h <<\EOF
  #define HAVE_ZLIB 1
  EOF
  
!     echo "$ac_t""/usr/local/lib/libz.a" 1>&6
      if test "X`echo $CFLAGS | grep '\-I/usr/local/include'`" = "X"; then
  	CFLAGS="$CFLAGS -I/usr/local/include"
      fi
  elif test -r "/usr/lib/libz.a"; then
      LIBZ_NAME="/usr/lib/libz.a"
!     cat >> confdefs.h <<\EOF
  #define HAVE_ZLIB 1
  EOF
  
!     echo "$ac_t""/usr/lib/libz.a" 1>&6
  else
      LIBZ_NAME=""
!     echo "$ac_t""no" 1>&6
  fi
  
! echo $ac_n "checking for pthread_create in -lpthread""... $ac_c" 1>&6
! echo "configure:1748: checking for pthread_create in -lpthread" >&5
! ac_lib_var=`echo pthread'_'pthread_create | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lpthread  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1756 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char pthread_create();
! 
! int main() {
! pthread_create()
! ; return 0; }
! EOF
! if { (eval echo configure:1767: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    pthread_in=pthread
  else
!   echo "$ac_t""no" 1>&6
! pthread_in=no
  fi
  
  if test "$pthread_in" = no; then
! echo $ac_n "checking for pthread_create in -lpthreads""... $ac_c" 1>&6
! echo "configure:1790: checking for pthread_create in -lpthreads" >&5
! ac_lib_var=`echo pthreads'_'pthread_create | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lpthreads  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1798 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char pthread_create();
! 
! int main() {
! pthread_create()
! ; return 0; }
! EOF
! if { (eval echo configure:1809: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    pthread_in=pthreads
  else
!   echo "$ac_t""no" 1>&6
! pthread_in=no
  fi
  
  fi
  
  if test "$static_modules" != "yes" ; then
!     echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
! echo "configure:1834: checking for dlopen in -ldl" >&5
! ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-ldl  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1842 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char dlopen();
! 
! int main() {
! dlopen()
! ; return 0; }
! EOF
! if { (eval echo configure:1853: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    dlopen_in=dl
  else
!   echo "$ac_t""no" 1>&6
! dlopen_in=no
  fi
  
      if test "$dlopen_in" = no; then
!     echo $ac_n "checking for dlopen in -lc""... $ac_c" 1>&6
! echo "configure:1876: checking for dlopen in -lc" >&5
! ac_lib_var=`echo c'_'dlopen | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lc  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1884 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char dlopen();
! 
! int main() {
! dlopen()
! ; return 0; }
! EOF
! if { (eval echo configure:1895: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    dlopen_in=c
  else
!   echo "$ac_t""no" 1>&6
! dlopen_in=no
  fi
  
      fi
      if test "$dlopen_in" = no; then
!     echo $ac_n "checking for dlopen in -lposix""... $ac_c" 1>&6
! echo "configure:1919: checking for dlopen in -lposix" >&5
! ac_lib_var=`echo posix'_'dlopen | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lposix  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1927 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char dlopen();
! 
! int main() {
! dlopen()
! ; return 0; }
! EOF
! if { (eval echo configure:1938: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    dlopen_in=posix
  else
!   echo "$ac_t""no" 1>&6
! dlopen=no
  fi
  
      fi
  fi
  
! echo $ac_n "checking for yywrap in -lfl""... $ac_c" 1>&6
! echo "configure:1963: checking for yywrap in -lfl" >&5
! ac_lib_var=`echo fl'_'yywrap | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lfl  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 1971 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char yywrap();
! 
! int main() {
! yywrap()
! ; return 0; }
! EOF
! if { (eval echo configure:1982: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    need_lfl="-lfl"
  else
!   echo "$ac_t""no" 1>&6
! need_lfl=""
  fi
  
! echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
! echo "configure:2004: checking for crypt in -lcrypt" >&5
! ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lcrypt  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 2012 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char crypt();
! 
! int main() {
! crypt()
! ; return 0; }
! EOF
! if { (eval echo configure:2023: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    LIBS="$LIBS -lcrypt"
+ else
+   echo "$ac_t""no" 1>&6
  fi
  
! echo $ac_n "checking for pam_end in -lpam""... $ac_c" 1>&6
! echo "configure:2044: checking for pam_end in -lpam" >&5
! ac_lib_var=`echo pam'_'pam_end | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-lpam  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 2052 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char pam_end();
! 
! int main() {
! pam_end()
! ; return 0; }
! EOF
! if { (eval echo configure:2063: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_lib=HAVE_LIB`echo pam | sed -e 's/[^a-zA-Z0-9_]/_/g' \
!     -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_lib 1
  EOF
  
    LIBS="-lpam $LIBS"
  
+ else
+   echo "$ac_t""no" 1>&6
  fi
  
  if test "$enable_tnf_probes" = "yes" ; then
!     echo $ac_n "checking for tnf_probe_debug in -ltnfprobe""... $ac_c" 1>&6
! echo "configure:2092: checking for tnf_probe_debug in -ltnfprobe" >&5
! ac_lib_var=`echo tnfprobe'_'tnf_probe_debug | sed 'y%./+-%__p_%'`
! if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   ac_save_LIBS="$LIBS"
  LIBS="-ltnfprobe  $LIBS"
! cat > conftest.$ac_ext <<EOF
! #line 2100 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char tnf_probe_debug();
! 
! int main() {
! tnf_probe_debug()
! ; return 0; }
! EOF
! if { (eval echo configure:2111: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_lib_$ac_lib_var=no"
! fi
! rm -f conftest*
! LIBS="$ac_save_LIBS"
! 
! fi
! if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_lib=HAVE_LIB`echo tnfprobe | sed -e 's/[^a-zA-Z0-9_]/_/g' \
!     -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_lib 1
  EOF
  
    LIBS="-ltnfprobe $LIBS"
  
+ else
+   echo "$ac_t""no" 1>&6
  fi
  
  fi
***************
*** 3681,3690 ****
  ##
  ## Check some typdefs
  ##
! echo "$as_me:3684: checking for socklen_t" >&5
! echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
! cat >conftest.$ac_ext <<_ACEOF
! #line 3687 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
--- 2139,2148 ----
  ##
  ## Check some typdefs
  ##
! echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
! echo "configure:2144: checking for socklen_t" >&5
! cat > conftest.$ac_ext <<EOF
! #line 2146 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
***************
*** 3694,3734 ****
  #include	<sys/socket.h>
  #include	<netinet/in.h>
  
! int
! main ()
! {
  
  socklen_t	test;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3707: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3710: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3713: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3716: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
! 
! cat >>confdefs.h <<\EOF
  #define HAVE_SOCKLEN_T 1
  EOF
!  echo "$as_me:3722: result: yes" >&5
! echo "${ECHO_T}yes" >&6
  
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! echo "$as_me:3728: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  ac_hdrs=""
  for ac_hdr in stdio.h errno.h
--- 2152,2177 ----
  #include	<sys/socket.h>
  #include	<netinet/in.h>
  
! int main() {
  
  socklen_t	test;
! ; return 0; }
! EOF
! if { (eval echo configure:2161: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   
! cat >> confdefs.h <<\EOF
  #define HAVE_SOCKLEN_T 1
  EOF
!  echo "$ac_t""yes" 1>&6
  
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   echo "$ac_t""no" 1>&6
  fi
! rm -f conftest*
  
  ac_hdrs=""
  for ac_hdr in stdio.h errno.h
***************
*** 3741,3788 ****
  ac_hdrs="$ac_hdrs
  extern float $ac_obj;"
  done
! cat >conftest.$ac_ext <<_ACEOF
! #line 3745 "configure"
  #include "confdefs.h"
  $ac_hdrs
! int
! main ()
! {
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3757: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3760: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3763: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3766: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
    :
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! cat >>confdefs.h <<\EOF
  #define HAVE_SYSERRLIST 1
  EOF
  
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  ##
  ## Check some typdefs
  ##
! echo "$as_me:3782: checking for uint32_t" >&5
! echo $ECHO_N "checking for uint32_t... $ECHO_C" >&6
! cat >conftest.$ac_ext <<_ACEOF
! #line 3785 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
--- 2184,2217 ----
  ac_hdrs="$ac_hdrs
  extern float $ac_obj;"
  done
! cat > conftest.$ac_ext <<EOF
! #line 2189 "configure"
  #include "confdefs.h"
  $ac_hdrs
! int main() {
  
! ; return 0; }
! EOF
! if { (eval echo configure:2196: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    :
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   cat >> confdefs.h <<\EOF
  #define HAVE_SYSERRLIST 1
  EOF
  
  fi
! rm -f conftest*
  
  ##
  ## Check some typdefs
  ##
! echo $ac_n "checking for uint32_t""... $ac_c" 1>&6
! echo "configure:2213: checking for uint32_t" >&5
! cat > conftest.$ac_ext <<EOF
! #line 2215 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
***************
*** 3799,3847 ****
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int
! main ()
! {
  
  uint32_t	test;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3812: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3815: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3818: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3821: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
! 
! cat >>confdefs.h <<\EOF
  #define HAVE_UINT32_T 1
  EOF
!  echo "$as_me:3827: result: yes" >&5
! echo "${ECHO_T}yes" >&6
  
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! echo "$as_me:3833: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  ##
  ## Check some typdefs
  ##
! echo "$as_me:3841: checking for uint16_t" >&5
! echo $ECHO_N "checking for uint16_t... $ECHO_C" >&6
! cat >conftest.$ac_ext <<_ACEOF
! #line 3844 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
--- 2228,2261 ----
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int main() {
  
  uint32_t	test;
! ; return 0; }
! EOF
! if { (eval echo configure:2237: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   
! cat >> confdefs.h <<\EOF
  #define HAVE_UINT32_T 1
  EOF
!  echo "$ac_t""yes" 1>&6
  
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   echo "$ac_t""no" 1>&6
  fi
! rm -f conftest*
  
  ##
  ## Check some typdefs
  ##
! echo $ac_n "checking for uint16_t""... $ac_c" 1>&6
! echo "configure:2257: checking for uint16_t" >&5
! cat > conftest.$ac_ext <<EOF
! #line 2259 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
***************
*** 3858,3906 ****
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int
! main ()
! {
  
  uint16_t	test;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3871: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3874: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3877: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3880: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
! 
! cat >>confdefs.h <<\EOF
  #define HAVE_UINT16_T 1
  EOF
!  echo "$as_me:3886: result: yes" >&5
! echo "${ECHO_T}yes" >&6
  
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! echo "$as_me:3892: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  ##
  ## Check some typdefs
  ##
! echo "$as_me:3900: checking for struct timespec" >&5
! echo $ECHO_N "checking for struct timespec... $ECHO_C" >&6
! cat >conftest.$ac_ext <<_ACEOF
! #line 3903 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
--- 2272,2305 ----
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int main() {
  
  uint16_t	test;
! ; return 0; }
! EOF
! if { (eval echo configure:2281: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   
! cat >> confdefs.h <<\EOF
  #define HAVE_UINT16_T 1
  EOF
!  echo "$ac_t""yes" 1>&6
  
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   echo "$ac_t""no" 1>&6
  fi
! rm -f conftest*
  
  ##
  ## Check some typdefs
  ##
! echo $ac_n "checking for struct timespec""... $ac_c" 1>&6
! echo "configure:2301: checking for struct timespec" >&5
! cat > conftest.$ac_ext <<EOF
! #line 2303 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
***************
*** 3915,3960 ****
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int
! main ()
! {
  
  struct timespec	test;
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3928: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3931: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3934: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3937: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
! 
! cat >>confdefs.h <<\EOF
  #define HAVE_STRUCT_TIMESPEC 1
  EOF
!  echo "$as_me:3943: result: yes" >&5
! echo "${ECHO_T}yes" >&6
  
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! echo "$as_me:3949: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
! echo "$as_me:3954: checking for __tm_gmtoff__" >&5
! echo $ECHO_N "checking for __tm_gmtoff__... $ECHO_C" >&6
! cat >conftest.$ac_ext <<_ACEOF
! #line 3957 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
--- 2314,2344 ----
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int main() {
  
  struct timespec	test;
! ; return 0; }
! EOF
! if { (eval echo configure:2323: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   
! cat >> confdefs.h <<\EOF
  #define HAVE_STRUCT_TIMESPEC 1
  EOF
!  echo "$ac_t""yes" 1>&6
  
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   echo "$ac_t""no" 1>&6
  fi
! rm -f conftest*
  
! echo $ac_n "checking for __tm_gmtoff__""... $ac_c" 1>&6
! echo "configure:2340: checking for __tm_gmtoff__" >&5
! cat > conftest.$ac_ext <<EOF
! #line 2342 "configure"
  #include "confdefs.h"
  
  #include	<stdio.h>
***************
*** 3968,4010 ****
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int
! main ()
! {
  
  struct	tm	tm;
  tm.__tm_gmtoff__ = tm.__tm_gmtoff__*2;
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext
! if { (eval echo "$as_me:3983: \"$ac_compile\"") >&5
!   (eval $ac_compile) 2>&5
!   ac_status=$?
!   echo "$as_me:3986: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest.$ac_objext'
!   { (eval echo "$as_me:3989: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:3992: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
! 
! cat >>confdefs.h <<\EOF
  #define HAVE__GMTOFF__ 1
  EOF
!  echo "$as_me:3998: result: yes" >&5
! echo "${ECHO_T}yes" >&6
  
  else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! echo "$as_me:4004: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
! rm -f conftest.$ac_objext conftest.$ac_ext
  
  LD=ld
  
--- 2352,2379 ----
  #include	<sys/types.h>
  #include	<netinet/in.h>
  
! int main() {
  
  struct	tm	tm;
  tm.__tm_gmtoff__ = tm.__tm_gmtoff__*2;
  
! ; return 0; }
! EOF
! if { (eval echo configure:2363: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
!   rm -rf conftest*
!   
! cat >> confdefs.h <<\EOF
  #define HAVE__GMTOFF__ 1
  EOF
!  echo "$ac_t""yes" 1>&6
  
  else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   echo "$ac_t""no" 1>&6
  fi
! rm -f conftest*
  
  LD=ld
  
***************
*** 4026,4033 ****
  fi
  
  if test "$MODULES" = 1; then
! 	echo "$as_me:4029: checking flags to link shared objects." >&5
! echo $ECHO_N "checking flags to link shared objects.... $ECHO_C" >&6
  	SAVED_LDFLAGS=$LDFLAGS
  	MOD_EXT=so
  cat>conftest.c << EOF
--- 2395,2402 ----
  fi
  
  if test "$MODULES" = 1; then
! 	echo $ac_n "checking flags to link shared objects.""... $ac_c" 1>&6
! echo "configure:2400: checking flags to link shared objects." >&5
  	SAVED_LDFLAGS=$LDFLAGS
  	MOD_EXT=so
  cat>conftest.c << EOF
***************
*** 4098,4114 ****
  	    fi
  	fi
  	rm -f conftest* confmain*
! 	echo "$as_me:4101: result: $SOFLAGS" >&5
! echo "${ECHO_T}$SOFLAGS" >&6
  	if test "$SOFLAGS" != ""; then
! 		cat >>confdefs.h <<\EOF
  #define MODULES 1
  EOF
  
  		LIBS="$LIBS $DLLIB"
  	fi
!     echo "$as_me:4110: checking for -export-dynamic" >&5
! echo $ECHO_N "checking for -export-dynamic... $ECHO_C" >&6
  cat>confmain.c << EOF
  #include <stdio.h>
  main()
--- 2467,2482 ----
  	    fi
  	fi
  	rm -f conftest* confmain*
! 	echo "$ac_t""$SOFLAGS" 1>&6
  	if test "$SOFLAGS" != ""; then
! 		cat >> confdefs.h <<\EOF
  #define MODULES 1
  EOF
  
  		LIBS="$LIBS $DLLIB"
  	fi
!     echo $ac_n "checking for -export-dynamic""... $ac_c" 1>&6
! echo "configure:2480: checking for -export-dynamic" >&5
  cat>confmain.c << EOF
  #include <stdio.h>
  main()
***************
*** 4123,4133 ****
      fi
      if test "$res" = "yes"; then
  	    LDFLAGS="$LDFLAGS -export-dynamic"
! 	    echo "$as_me:4126: result: yes" >&5
! echo "${ECHO_T}yes" >&6
      else
! 	    echo "$as_me:4129: result: no" >&5
! echo "${ECHO_T}no" >&6
      fi
  fi
  rm -f confmain*
--- 2491,2499 ----
      fi
      if test "$res" = "yes"; then
  	    LDFLAGS="$LDFLAGS -export-dynamic"
! 	    echo "$ac_t""yes" 1>&6
      else
! 	    echo "$ac_t""no" 1>&6
      fi
  fi
  rm -f confmain*
***************
*** 4171,4178 ****
  	  LIBS="$LIBS $LIBDB_PATH $LIBDB_NAME"
  	  if test "$large_files" = "yes" ; then
  		## Linux ext2fs does'nt support large files yet.
! 		echo "$as_me:4174: result: Warning: Linux ext2fs doesn't support large files." >&5
! echo "${ECHO_T}Warning: Linux ext2fs doesn't support large files." >&6
  		CFLAGS="$CFLAGS -DWITH_LARGE_FILES -D_FILE_OFFSET_BITS=64 -D__USE_LARGEFILE64 -D__USE_FILE_OFFSET64"
  	  fi
  	  ;;
--- 2537,2543 ----
  	  LIBS="$LIBS $LIBDB_PATH $LIBDB_NAME"
  	  if test "$large_files" = "yes" ; then
  		## Linux ext2fs does'nt support large files yet.
! 		echo "$ac_t""Warning: Linux ext2fs doesn't support large files." 1>&6
  		CFLAGS="$CFLAGS -DWITH_LARGE_FILES -D_FILE_OFFSET_BITS=64 -D__USE_LARGEFILE64 -D__USE_FILE_OFFSET64"
  	  fi
  	  ;;
***************
*** 4204,4210 ****
  		CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -DWITH_LARGE_FILES"
  	  fi
  	  ;;
! aix4*)    cat >>confdefs.h <<\EOF
  #define MODULES 1
  EOF
  
--- 2569,2575 ----
  		CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -DWITH_LARGE_FILES"
  	  fi
  	  ;;
! aix4*)    cat >> confdefs.h <<\EOF
  #define MODULES 1
  EOF
  
***************
*** 4228,4234 ****
  
  if test "X$MYSQL_PATH" != "X" ; then
      LIBS="-L$MYSQL_PATH/lib -lmysqlclient $LIBS"
!     cat >>confdefs.h <<\EOF
  #define HAVE_MYSQL 1
  EOF
  
--- 2593,2599 ----
  
  if test "X$MYSQL_PATH" != "X" ; then
      LIBS="-L$MYSQL_PATH/lib -lmysqlclient $LIBS"
!     cat >> confdefs.h <<\EOF
  #define HAVE_MYSQL 1
  EOF
  
***************
*** 4238,4244 ****
  
  if test "X$PGSQL_PATH" != "X" ; then
      LIBS="$LIBS -L$PGSQL_PATH/lib -lpg"
!     cat >>confdefs.h <<\EOF
  #define HAVE_PGSQL 1
  EOF
  
--- 2603,2609 ----
  
  if test "X$PGSQL_PATH" != "X" ; then
      LIBS="$LIBS -L$PGSQL_PATH/lib -lpg"
!     cat >> confdefs.h <<\EOF
  #define HAVE_PGSQL 1
  EOF
  
***************
*** 4246,4523 ****
      PGSQL_LIB="-L$PGSQL_PATH/lib -lpg"
  fi
  
  for ac_func in atoll bzero chroot ctime_r daemon getdomainname gethostbyname_r
  do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:4252: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4258 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! f = $ac_func;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4289: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4292: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4295: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4298: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4308: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  fi
  done
  
! echo "$as_me:4318: checking for getopt" >&5
! echo $ECHO_N "checking for getopt... $ECHO_C" >&6
! if test "${ac_cv_func_getopt+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4324 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char getopt (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char getopt ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_getopt) || defined (__stub___getopt)
  choke me
  #else
! f = getopt;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4355: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4358: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4361: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4364: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_getopt=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_getopt=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4374: result: $ac_cv_func_getopt" >&5
! echo "${ECHO_T}$ac_cv_func_getopt" >&6
! if test $ac_cv_func_getopt = yes; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_GETOPT 1
  EOF
  
  else
!   EXTRASRC="$EXTRASRC getopt.c" ; cd src; cp -f lib/getopt/getopt.c ./; cp -f lib/getopt/getopt.h ./; cp -f lib/getopt/getopt1.c ./;cd ..
  fi
  
  for ac_func in getrlimit getrusage gmtime_r localtime_r poll pread pwrite directio
  do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:4388: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4394 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! f = $ac_func;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4425: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4428: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4431: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4434: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4444: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
! 
  fi
  done
  
  case "$regexp_val" in
    system)
!     echo "$as_me:4456: checking for regcomp" >&5
! echo $ECHO_N "checking for regcomp... $ECHO_C" >&6
! if test "${ac_cv_func_regcomp+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4462 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char regcomp (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char regcomp ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_regcomp) || defined (__stub___regcomp)
  choke me
  #else
! f = regcomp;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4493: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4496: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4499: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4502: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_regcomp=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_regcomp=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4512: result: $ac_cv_func_regcomp" >&5
! echo "${ECHO_T}$ac_cv_func_regcomp" >&6
! if test $ac_cv_func_regcomp = yes; then
    :
  else
!   echo "regcomp not found in system libraries" 2>&1; exit 1
  fi
  
!     cat >>confdefs.h <<\EOF
  #define REGEX_H <regex.h>
  EOF
  
--- 2611,2832 ----
      PGSQL_LIB="-L$PGSQL_PATH/lib -lpg"
  fi
  
+ 
  for ac_func in atoll bzero chroot ctime_r daemon getdomainname gethostbyname_r
  do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2619: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2624 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
  EOF
+ if { (eval echo configure:2647: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=yes"
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=no"
+ fi
+ rm -f conftest*
+ fi
  
+ if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+   echo "$ac_t""yes" 1>&6
+     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+   cat >> confdefs.h <<EOF
+ #define $ac_tr_func 1
+ EOF
+  
+ else
+   echo "$ac_t""no" 1>&6
  fi
  done
  
! echo $ac_n "checking for getopt""... $ac_c" 1>&6
! echo "configure:2672: checking for getopt" >&5
! if eval "test \"`echo '$''{'ac_cv_func_getopt'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2677 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char getopt(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char getopt();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_getopt) || defined (__stub___getopt)
  choke me
  #else
! getopt();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:2700: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_getopt=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_getopt=no"
! fi
! rm -f conftest*
! fi
! 
! if eval "test \"`echo '$ac_cv_func_'getopt`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<\EOF
  #define HAVE_GETOPT 1
  EOF
  
  else
!   echo "$ac_t""no" 1>&6
! EXTRASRC="$EXTRASRC getopt.c" ; cd src; cp -f lib/getopt/getopt.c ./; cp -f lib/getopt/getopt.h ./; cp -f lib/getopt/getopt1.c ./;cd ..
  fi
  
  for ac_func in getrlimit getrusage gmtime_r localtime_r poll pread pwrite directio
  do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2726: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2731 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! $ac_func();
  #endif
+ 
+ ; return 0; }
+ EOF
+ if { (eval echo configure:2754: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=yes"
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=no"
+ fi
+ rm -f conftest*
+ fi
  
! if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
!   cat >> confdefs.h <<EOF
! #define $ac_tr_func 1
  EOF
!  
! else
!   echo "$ac_t""no" 1>&6
  fi
  done
  
+ 
  case "$regexp_val" in
    system)
!     echo $ac_n "checking for regcomp""... $ac_c" 1>&6
! echo "configure:2782: checking for regcomp" >&5
! if eval "test \"`echo '$''{'ac_cv_func_regcomp'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2787 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char regcomp(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char regcomp();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_regcomp) || defined (__stub___regcomp)
  choke me
  #else
! regcomp();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:2810: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_regcomp=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_regcomp=no"
! fi
! rm -f conftest*
! fi
! 
! if eval "test \"`echo '$ac_cv_func_'regcomp`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    :
  else
!   echo "$ac_t""no" 1>&6
! echo "regcomp not found in system libraries" 2>&1; exit 1
  fi
  
!     cat >> confdefs.h <<\EOF
  #define REGEX_H <regex.h>
  EOF
  
***************
*** 4531,4543 ****
      if test "X`echo $CFLAGS | grep '\-I/usr/local/include'`" = "X"; then
  	CFLAGS="$CFLAGS -I/usr/local/include"
      fi
!     cat >>confdefs.h <<\EOF
  #define REGEX_H <pcreposix.h>
  EOF
  
      ;;
    builtin)
!     cat >>confdefs.h <<\EOF
  #define REGEX_H "gnu_regex.h"
  EOF
   EXTRASRC="$EXTRASRC gnu_regex.c"
--- 2840,2852 ----
      if test "X`echo $CFLAGS | grep '\-I/usr/local/include'`" = "X"; then
  	CFLAGS="$CFLAGS -I/usr/local/include"
      fi
!     cat >> confdefs.h <<\EOF
  #define REGEX_H <pcreposix.h>
  EOF
  
      ;;
    builtin)
!     cat >> confdefs.h <<\EOF
  #define REGEX_H "gnu_regex.h"
  EOF
   EXTRASRC="$EXTRASRC gnu_regex.c"
***************
*** 4551,4628 ****
  
  case "$host_os" in
  gnu*|linux*)
!     EXTRASRC="$EXTRASRC rwlock.c" ;
      cd src;
      cp -f lib/rwlock/rwlock.c ./;
!     cp -f lib/rwlock/rwlock.h ./;
      cd ..
      ;;
  *)
!     echo "$as_me:4561: checking for pthread_rwlock_init" >&5
! echo $ECHO_N "checking for pthread_rwlock_init... $ECHO_C" >&6
! if test "${ac_cv_func_pthread_rwlock_init+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4567 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char pthread_rwlock_init (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char pthread_rwlock_init ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_pthread_rwlock_init) || defined (__stub___pthread_rwlock_init)
  choke me
  #else
! f = pthread_rwlock_init;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4598: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4601: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4604: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4607: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_pthread_rwlock_init=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_pthread_rwlock_init=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4617: result: $ac_cv_func_pthread_rwlock_init" >&5
! echo "${ECHO_T}$ac_cv_func_pthread_rwlock_init" >&6
! if test $ac_cv_func_pthread_rwlock_init = yes; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_PTHREAD_RWLOCK_INIT 1
  EOF
  
  else
!   EXTRASRC="$EXTRASRC rwlock.c" ; cd src; cp -f lib/rwlock/rwlock.c ./; cp -f lib/rwlock/rwlock.h ./; cd ..
  fi
  
      ;;
--- 2860,2922 ----
  
  case "$host_os" in
  gnu*|linux*)
!     EXTRASRC="$EXTRASRC rwlock.c" ; 
      cd src;
      cp -f lib/rwlock/rwlock.c ./;
!     cp -f lib/rwlock/rwlock.h ./; 
      cd ..
      ;;
  *)
!     echo $ac_n "checking for pthread_rwlock_init""... $ac_c" 1>&6
! echo "configure:2872: checking for pthread_rwlock_init" >&5
! if eval "test \"`echo '$''{'ac_cv_func_pthread_rwlock_init'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2877 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char pthread_rwlock_init(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char pthread_rwlock_init();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_pthread_rwlock_init) || defined (__stub___pthread_rwlock_init)
  choke me
  #else
! pthread_rwlock_init();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:2900: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_pthread_rwlock_init=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_pthread_rwlock_init=no"
! fi
! rm -f conftest*
! fi
! 
! if eval "test \"`echo '$ac_cv_func_'pthread_rwlock_init`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<\EOF
  #define HAVE_PTHREAD_RWLOCK_INIT 1
  EOF
  
  else
!   echo "$ac_t""no" 1>&6
! EXTRASRC="$EXTRASRC rwlock.c" ; cd src; cp -f lib/rwlock/rwlock.c ./; cp -f lib/rwlock/rwlock.h ./; cd ..
  fi
  
      ;;
***************
*** 4630,4871 ****
  
  for ac_func in setegid snprintf setrlimit strcasestr strerror_r strtoll
  do
! as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
! echo "$as_me:4634: checking for $ac_func" >&5
! echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
! if eval "test \"\${$as_ac_var+set}\" = set"; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4640 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char $ac_func ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! f = $ac_func;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4671: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4674: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4677: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4680: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   eval "$as_ac_var=yes"
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! eval "$as_ac_var=no"
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4690: result: `eval echo '${'$as_ac_var'}'`" >&5
! echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
! if test `eval echo '${'$as_ac_var'}'` = yes; then
!   cat >>confdefs.h <<EOF
! #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
  EOF
  
  fi
  done
  
! echo "$as_me:4700: checking for strtok_r" >&5
! echo $ECHO_N "checking for strtok_r... $ECHO_C" >&6
! if test "${ac_cv_func_strtok_r+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4706 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char strtok_r (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char strtok_r ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_strtok_r) || defined (__stub___strtok_r)
  choke me
  #else
! f = strtok_r;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4737: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4740: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4743: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4746: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_strtok_r=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_strtok_r=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4756: result: $ac_cv_func_strtok_r" >&5
! echo "${ECHO_T}$ac_cv_func_strtok_r" >&6
! if test $ac_cv_func_strtok_r = yes; then
    :
  else
!   EXTRASRC="$EXTRASRC strtok_r.c" ; cd src; cp -f lib/misc/strtok_r.c ./; cd ..
  fi
  
! echo "$as_me:4764: checking for snprintf" >&5
! echo $ECHO_N "checking for snprintf... $ECHO_C" >&6
! if test "${ac_cv_func_snprintf+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   cat >conftest.$ac_ext <<_ACEOF
! #line 4770 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char snprintf (); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
- #ifdef __cplusplus
- extern "C"
- #endif
  /* We use char because int might match the return type of a gcc2
!    builtin and then its argument prototype would still apply.  */
! char snprintf ();
! char (*f) ();
  
! int
! main ()
! {
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_snprintf) || defined (__stub___snprintf)
  choke me
  #else
! f = snprintf;
  #endif
  
!   ;
!   return 0;
! }
! _ACEOF
! rm -f conftest.$ac_objext conftest$ac_exeext
! if { (eval echo "$as_me:4801: \"$ac_link\"") >&5
!   (eval $ac_link) 2>&5
!   ac_status=$?
!   echo "$as_me:4804: \$? = $ac_status" >&5
!   (exit $ac_status); } &&
!          { ac_try='test -s conftest$ac_exeext'
!   { (eval echo "$as_me:4807: \"$ac_try\"") >&5
!   (eval $ac_try) 2>&5
!   ac_status=$?
!   echo "$as_me:4810: \$? = $ac_status" >&5
!   (exit $ac_status); }; }; then
!   ac_cv_func_snprintf=yes
! else
!   echo "$as_me: failed program was:" >&5
! cat conftest.$ac_ext >&5
! ac_cv_func_snprintf=no
! fi
! rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
! fi
! echo "$as_me:4820: result: $ac_cv_func_snprintf" >&5
! echo "${ECHO_T}$ac_cv_func_snprintf" >&6
! if test $ac_cv_func_snprintf = yes; then
!   cat >>confdefs.h <<\EOF
  #define HAVE_SNPRINTF 1
  EOF
  
  else
!   OOPSCTL_SNPRINTF="../snprintf.o"; EXTRASRC="$EXTRASRC snprintf.c" ; cd src; cp -f lib/misc/snprintf.c ./; cd ..
  fi
  
  # Extract the first word of "chown", so it can be a program name with args.
  set dummy chown; ac_word=$2
! echo "$as_me:4833: checking for $ac_word" >&5
! echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
! if test "${ac_cv_path_CHOWN+set}" = set; then
!   echo $ECHO_N "(cached) $ECHO_C" >&6
  else
!   case $CHOWN in
!   [\\/]* | ?:[\\/]*)
    ac_cv_path_CHOWN="$CHOWN" # Let the user override the test with a path.
    ;;
    *)
!   ac_save_IFS=$IFS; IFS=$ac_path_separator
! ac_dummy="$PATH:/bin:/usr/bin:/usr/sbin"
! for ac_dir in $ac_dummy; do
!   IFS=$ac_save_IFS
!   test -z "$ac_dir" && ac_dir=.
!   if $as_executable_p "$ac_dir/$ac_word"; then
!    ac_cv_path_CHOWN="$ac_dir/$ac_word"
!    echo "$as_me:4850: found $ac_dir/$ac_word" >&5
!    break
! fi
! done
! 
    test -z "$ac_cv_path_CHOWN" && ac_cv_path_CHOWN="/usr/sbin/chown"
    ;;
  esac
  fi
! CHOWN=$ac_cv_path_CHOWN
! 
  if test -n "$CHOWN"; then
!   echo "$as_me:4862: result: $CHOWN" >&5
! echo "${ECHO_T}$CHOWN" >&6
  else
!   echo "$as_me:4865: result: no" >&5
! echo "${ECHO_T}no" >&6
  fi
  
  if test "X$with_malloc" != "X" ; then
  LIBS="$with_malloc $LIBS"
  fi
--- 2924,3120 ----
  
  for ac_func in setegid snprintf setrlimit strcasestr strerror_r strtoll
  do
! echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:2929: checking for $ac_func" >&5
! if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2934 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char $ac_func(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char $ac_func();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
  choke me
  #else
! $ac_func();
  #endif
  
! ; return 0; }
  EOF
+ if { (eval echo configure:2957: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=yes"
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=no"
+ fi
+ rm -f conftest*
+ fi
  
+ if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+   echo "$ac_t""yes" 1>&6
+     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+   cat >> confdefs.h <<EOF
+ #define $ac_tr_func 1
+ EOF
+  
+ else
+   echo "$ac_t""no" 1>&6
  fi
  done
  
! echo $ac_n "checking for strtok_r""... $ac_c" 1>&6
! echo "configure:2982: checking for strtok_r" >&5
! if eval "test \"`echo '$''{'ac_cv_func_strtok_r'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 2987 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char strtok_r(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char strtok_r();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_strtok_r) || defined (__stub___strtok_r)
  choke me
  #else
! strtok_r();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:3010: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_strtok_r=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_strtok_r=no"
! fi
! rm -f conftest*
! fi
! 
! if eval "test \"`echo '$ac_cv_func_'strtok_r`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
    :
  else
!   echo "$ac_t""no" 1>&6
! EXTRASRC="$EXTRASRC strtok_r.c" ; cd src; cp -f lib/misc/strtok_r.c ./; cd ..
  fi
  
! echo $ac_n "checking for snprintf""... $ac_c" 1>&6
! echo "configure:3031: checking for snprintf" >&5
! if eval "test \"`echo '$''{'ac_cv_func_snprintf'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   cat > conftest.$ac_ext <<EOF
! #line 3036 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
!     which can conflict with char snprintf(); below.  */
  #include <assert.h>
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
!     builtin and then its argument prototype would still apply.  */
! char snprintf();
  
! int main() {
! 
  /* The GNU C library defines this for functions which it implements
      to always fail with ENOSYS.  Some functions are actually named
      something starting with __ and the normal name is an alias.  */
  #if defined (__stub_snprintf) || defined (__stub___snprintf)
  choke me
  #else
! snprintf();
  #endif
  
! ; return 0; }
! EOF
! if { (eval echo configure:3059: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
!   rm -rf conftest*
!   eval "ac_cv_func_snprintf=yes"
! else
!   echo "configure: failed program was:" >&5
!   cat conftest.$ac_ext >&5
!   rm -rf conftest*
!   eval "ac_cv_func_snprintf=no"
! fi
! rm -f conftest*
! fi
! 
! if eval "test \"`echo '$ac_cv_func_'snprintf`\" = yes"; then
!   echo "$ac_t""yes" 1>&6
!   cat >> confdefs.h <<\EOF
  #define HAVE_SNPRINTF 1
  EOF
  
  else
!   echo "$ac_t""no" 1>&6
! OOPSCTL_SNPRINTF="../snprintf.o"; EXTRASRC="$EXTRASRC snprintf.c" ; cd src; cp -f lib/misc/snprintf.c ./; cd ..
  fi
  
  # Extract the first word of "chown", so it can be a program name with args.
  set dummy chown; ac_word=$2
! echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:3085: checking for $ac_word" >&5
! if eval "test \"`echo '$''{'ac_cv_path_CHOWN'+set}'`\" = set"; then
!   echo $ac_n "(cached) $ac_c" 1>&6
  else
!   case "$CHOWN" in
!   /*)
    ac_cv_path_CHOWN="$CHOWN" # Let the user override the test with a path.
    ;;
+   ?:/*)			 
+   ac_cv_path_CHOWN="$CHOWN" # Let the user override the test with a dos path.
+   ;;
    *)
!   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
!   ac_dummy="$PATH:/bin:/usr/bin:/usr/sbin"
!   for ac_dir in $ac_dummy; do 
!     test -z "$ac_dir" && ac_dir=.
!     if test -f $ac_dir/$ac_word; then
!       ac_cv_path_CHOWN="$ac_dir/$ac_word"
!       break
!     fi
!   done
!   IFS="$ac_save_ifs"
    test -z "$ac_cv_path_CHOWN" && ac_cv_path_CHOWN="/usr/sbin/chown"
    ;;
  esac
  fi
! CHOWN="$ac_cv_path_CHOWN"
  if test -n "$CHOWN"; then
!   echo "$ac_t""$CHOWN" 1>&6
  else
!   echo "$ac_t""no" 1>&6
  fi
  
+ 
  if test "X$with_malloc" != "X" ; then
  LIBS="$with_malloc $LIBS"
  fi
***************
*** 4892,4903 ****
  	echo
  	SETOWNER="-o $OOPS_USER"
  	OOPSUSER_DEF="userid	$OOPS_USER"
! 
  else
  	OOPSUSER_DEF=""
  fi
  
! cat >>confdefs.h <<\EOF
  #define OPEN_FILES_MAXIMUM 8196
  EOF
  
--- 3141,3174 ----
  	echo
  	SETOWNER="-o $OOPS_USER"
  	OOPSUSER_DEF="userid	$OOPS_USER"
! 	
! 	
  else
  	OOPSUSER_DEF=""
  fi
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
  
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! cat >> confdefs.h <<\EOF
  #define OPEN_FILES_MAXIMUM 8196
  EOF
  
***************
*** 4938,5850 ****
  OOPS_LIBDIR=$oops_libdir
  
  OOPS_HOME="$oops_prefix/oops"
  
! cat >>confdefs.h <<EOF
  #define OOPS_HOME "$oops_prefix/oops"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_SBINDIR "$oops_sbindir"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_SYSCONFDIR "$oops_sysconfdir"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_LOCALSTATEDIR "$oops_localstatedir"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_LIBDIR "$oops_libdir"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_CFG "$oops_sysconfdir/oops.cfg"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_CC "$CC"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_CFLAGS "$CFLAGS"
  EOF
  
! cat >>confdefs.h <<EOF
  #define OOPS_LIBS "$LIBS"
  EOF
  
- ac_config_headers="$ac_config_headers src/config.h"
  
! ac_config_files="$ac_config_files src/Makefile src/modules/Makefile src/oops.cfg doc/oops.8 doc/oopsctl.8"
! cat >confcache <<\_ACEOF
  # This file is a shell script that caches the results of configure
  # tests run on this system so they can be shared between configure
! # scripts and configure runs, see configure's option --config-cache.
! # It is not useful on other systems.  If it contains results you don't
! # want to keep, you may remove or edit it.
  #
! # config.status only pays attention to the cache file if you give it
! # the --recheck option to rerun configure.
  #
! # `ac_cv_env_foo' variables (set or unset) will be overriden when
! # loading this file, other *unset* `ac_cv_foo' will be assigned the
! # following values.
! 
! _ACEOF
! 
  # The following way of writing the cache mishandles newlines in values,
  # but we know of no workaround that is simple, portable, and efficient.
  # So, don't put newlines in cache variables' values.
  # Ultrix sh set writes to stderr and can't be redirected directly,
  # and sets the high bit in the cache file unless we assign to the vars.
! {
!   (set) 2>&1 |
!     case `(ac_space=' '; set | grep ac_space) 2>&1` in
!     *ac_space=\ *)
!       # `set' does not quote correctly, so add quotes (double-quote
!       # substitution turns \\\\ into \\, and sed turns \\ into \).
!       sed -n \
!         "s/'/'\\\\''/g;
!     	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
!       ;;
!     *)
!       # `set' quotes correctly as required by POSIX, so do not add quotes.
!       sed -n \
!         "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
!       ;;
!     esac;
! } |
!   sed '
!      t clear
!      : clear
!      s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
!      t end
!      /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
!      : end' >>confcache
! if cmp -s $cache_file confcache; then :; else
    if test -w $cache_file; then
!     test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
!     cat confcache >$cache_file
    else
      echo "not updating unwritable cache $cache_file"
    fi
  fi
  rm -f confcache
  
  test "x$prefix" = xNONE && prefix=$ac_default_prefix
  # Let make expand exec_prefix.
  test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
  
! # VPATH may cause trouble with some makes, so we remove $(srcdir),
! # ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
! # trailing colons and then remove the whole line if VPATH becomes empty
! # (actually we leave an empty line to preserve line numbers).
  if test "x$srcdir" = x.; then
!   ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
! s/:*\$(srcdir):*/:/;
! s/:*\${srcdir}:*/:/;
! s/:*@srcdir@:*/:/;
! s/^\([^=]*=[ 	]*\):*/\1/;
! s/:*$//;
! s/^[^=]*=[ 	]*$//;
! }'
  fi
  
  DEFS=-DHAVE_CONFIG_H
  
  : ${CONFIG_STATUS=./config.status}
! ac_clean_files_save=$ac_clean_files
! ac_clean_files="$ac_clean_files $CONFIG_STATUS"
! { echo "$as_me:5060: creating $CONFIG_STATUS" >&5
! echo "$as_me: creating $CONFIG_STATUS" >&6;}
! cat >$CONFIG_STATUS <<_ACEOF
! #! $SHELL
  # Generated automatically by configure.
  # Run this file to recreate the current configuration.
  # Compiler output produced by configure, useful for debugging
! # configure, is in config.log if it exists.
! 
! debug=false
! SHELL=\${CONFIG_SHELL-$SHELL}
! ac_cs_invocation="\$0 \$@"
! 
! _ACEOF
! 
! cat >>$CONFIG_STATUS <<\_ACEOF
! # Be Bourne compatible
! if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
!   emulate sh
!   NULLCMD=:
! elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
!   set -o posix
! fi
! 
! # Name of the executable.
! as_me=`echo "$0" |sed 's,.*[\\/],,'`
! 
! if expr a : '\(a\)' >/dev/null 2>&1; then
!   as_expr=expr
! else
!   as_expr=false
! fi
! 
! rm -f conf$$ conf$$.exe conf$$.file
! echo >conf$$.file
! if ln -s conf$$.file conf$$ 2>/dev/null; then
!   # We could just check for DJGPP; but this test a) works b) is more generic
!   # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
!   if test -f conf$$.exe; then
!     # Don't use ln at all; we don't have any links
!     as_ln_s='cp -p'
!   else
!     as_ln_s='ln -s'
!   fi
! elif ln conf$$.file conf$$ 2>/dev/null; then
!   as_ln_s=ln
! else
!   as_ln_s='cp -p'
! fi
! rm -f conf$$ conf$$.exe conf$$.file
! 
! as_executable_p="test -f"
! 
! # Support unset when possible.
! if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
!   as_unset=unset
! else
!   as_unset=false
! fi
! 
! # NLS nuisances.
! $as_unset LANG || test "${LANG+set}" != set || { LANG=C; export LANG; }
! $as_unset LC_ALL || test "${LC_ALL+set}" != set || { LC_ALL=C; export LC_ALL; }
! $as_unset LC_TIME || test "${LC_TIME+set}" != set || { LC_TIME=C; export LC_TIME; }
! $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set || { LC_CTYPE=C; export LC_CTYPE; }
! $as_unset LANGUAGE || test "${LANGUAGE+set}" != set || { LANGUAGE=C; export LANGUAGE; }
! $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set || { LC_COLLATE=C; export LC_COLLATE; }
! $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set || { LC_NUMERIC=C; export LC_NUMERIC; }
! $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set || { LC_MESSAGES=C; export LC_MESSAGES; }
! 
! # IFS
! # We need space, tab and new line, in precisely that order.
! as_nl='
! '
! IFS=" 	$as_nl"
! 
! # CDPATH.
! $as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=:; export CDPATH; }
! 
! exec 6>&1
! 
! _ACEOF
! 
! # Files that config.status was made for.
! if test -n "$ac_config_files"; then
!   echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
! fi
! 
! if test -n "$ac_config_headers"; then
!   echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
! fi
! 
! if test -n "$ac_config_links"; then
!   echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
! fi
! 
! if test -n "$ac_config_commands"; then
!   echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
! fi
! 
! cat >>$CONFIG_STATUS <<\EOF
! 
! ac_cs_usage="\
! \`$as_me' instantiates files from templates according to the
! current configuration.
! 
! Usage: $0 [OPTIONS] [FILE]...
! 
!   -h, --help       print this help, then exit
!   -V, --version    print version number, then exit
!   -d, --debug      don't remove temporary files
!       --recheck    update $as_me by reconfiguring in the same conditions
!   --file=FILE[:TEMPLATE]
!                    instantiate the configuration file FILE
!   --header=FILE[:TEMPLATE]
!                    instantiate the configuration header FILE
  
! Configuration files:
! $config_files
! 
! Configuration headers:
! $config_headers
! 
! Report bugs to <bug-autoconf@gnu.org>."
! EOF
! 
! cat >>$CONFIG_STATUS <<EOF
! ac_cs_version="\\
! config.status
! configured by $0, generated by GNU Autoconf 2.52,
!   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
! 
! Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
! Free Software Foundation, Inc.
! This config.status script is free software; the Free Software Foundation
! gives unlimited permission to copy, distribute and modify it."
! srcdir=$srcdir
! INSTALL="$INSTALL"
! EOF
! 
! cat >>$CONFIG_STATUS <<\EOF
! # If no file are specified by the user, then we need to provide default
! # value.  By we need to know if files were specified by the user.
! ac_need_defaults=:
! while test $# != 0
  do
!   case $1 in
!   --*=*)
!     ac_option=`expr "x$1" : 'x\([^=]*\)='`
!     ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
!     shift
!     set dummy "$ac_option" "$ac_optarg" ${1+"$@"}
!     shift
!     ;;
!   -*);;
!   *) # This is not an option, so the user has probably given explicit
!      # arguments.
!      ac_need_defaults=false;;
!   esac
! 
!   case $1 in
!   # Handling of the options.
! EOF
! cat >>$CONFIG_STATUS <<EOF
    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
!     echo "running $SHELL $0 " $ac_configure_args " --no-create --no-recursion"
!     exec $SHELL $0 $ac_configure_args --no-create --no-recursion ;;
! EOF
! cat >>$CONFIG_STATUS <<\EOF
!   --version | --vers* | -V )
!     echo "$ac_cs_version"; exit 0 ;;
!   --he | --h)
!     # Conflict between --help and --header
!     { { echo "$as_me:5233: error: ambiguous option: $1
! Try \`$0 --help' for more information." >&5
! echo "$as_me: error: ambiguous option: $1
! Try \`$0 --help' for more information." >&2;}
!    { (exit 1); exit 1; }; };;
!   --help | --hel | -h )
!     echo "$ac_cs_usage"; exit 0 ;;
!   --debug | --d* | -d )
!     debug=: ;;
!   --file | --fil | --fi | --f )
!     shift
!     CONFIG_FILES="$CONFIG_FILES $1"
!     ac_need_defaults=false;;
!   --header | --heade | --head | --hea )
!     shift
!     CONFIG_HEADERS="$CONFIG_HEADERS $1"
!     ac_need_defaults=false;;
! 
!   # This is an error.
!   -*) { { echo "$as_me:5252: error: unrecognized option: $1
! Try \`$0 --help' for more information." >&5
! echo "$as_me: error: unrecognized option: $1
! Try \`$0 --help' for more information." >&2;}
!    { (exit 1); exit 1; }; } ;;
! 
!   *) ac_config_targets="$ac_config_targets $1" ;;
! 
!   esac
!   shift
! done
! 
! exec 5>>config.log
! cat >&5 << _ACEOF
! 
! ## ----------------------- ##
! ## Running config.status.  ##
! ## ----------------------- ##
! 
! This file was extended by $as_me 2.52, executed with
!   CONFIG_FILES    = $CONFIG_FILES
!   CONFIG_HEADERS  = $CONFIG_HEADERS
!   CONFIG_LINKS    = $CONFIG_LINKS
!   CONFIG_COMMANDS = $CONFIG_COMMANDS
!   > $ac_cs_invocation
! on `(hostname || uname -n) 2>/dev/null | sed 1q`
! 
! _ACEOF
! EOF
! 
! cat >>$CONFIG_STATUS <<\EOF
! for ac_config_target in $ac_config_targets
! do
!   case "$ac_config_target" in
!   # Handling of arguments.
!   "src/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
!   "src/modules/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/modules/Makefile" ;;
!   "src/oops.cfg" ) CONFIG_FILES="$CONFIG_FILES src/oops.cfg" ;;
!   "doc/oops.8" ) CONFIG_FILES="$CONFIG_FILES doc/oops.8" ;;
!   "doc/oopsctl.8" ) CONFIG_FILES="$CONFIG_FILES doc/oopsctl.8" ;;
!   "src/config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS src/config.h" ;;
!   *) { { echo "$as_me:5293: error: invalid argument: $ac_config_target" >&5
! echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
!    { (exit 1); exit 1; }; };;
    esac
  done
- 
- # If the user did not use the arguments to specify the items to instantiate,
- # then the envvar interface is used.  Set only those that are not.
- # We use the long form for the default assignment because of an extremely
- # bizarre bug on SunOS 4.1.3.
- if $ac_need_defaults; then
-   test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-   test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
- fi
- 
- # Create a temporary directory, and hook for its removal unless debugging.
- $debug ||
- {
-   trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
-   trap '{ (exit 1); exit 1; }' 1 2 13 15
- }
  
! # Create a (secure) tmp directory for tmp files.
! : ${TMPDIR=/tmp}
! {
!   tmp=`(umask 077 && mktemp -d -q "$TMPDIR/csXXXXXX") 2>/dev/null` &&
!   test -n "$tmp" && test -d "$tmp"
! }  ||
! {
!   tmp=$TMPDIR/cs$$-$RANDOM
!   (umask 077 && mkdir $tmp)
! } ||
! {
!    echo "$me: cannot create a temporary directory in $TMPDIR" >&2
!    { (exit 1); exit 1; }
! }
  
  EOF
  
! cat >>$CONFIG_STATUS <<EOF
! 
! #
! # CONFIG_FILES section.
! #
  
- # No need to generate the scripts if there are no CONFIG_FILES.
- # This happens for instance when ./config.status config.h
- if test -n "\$CONFIG_FILES"; then
-   # Protect against being on the right side of a sed subst in config.status.
-   sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
-    s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
- s,@SHELL@,$SHELL,;t t
- s,@exec_prefix@,$exec_prefix,;t t
- s,@prefix@,$prefix,;t t
- s,@program_transform_name@,$program_transform_name,;t t
- s,@bindir@,$bindir,;t t
- s,@sbindir@,$sbindir,;t t
- s,@libexecdir@,$libexecdir,;t t
- s,@datadir@,$datadir,;t t
- s,@sysconfdir@,$sysconfdir,;t t
- s,@sharedstatedir@,$sharedstatedir,;t t
- s,@localstatedir@,$localstatedir,;t t
- s,@libdir@,$libdir,;t t
- s,@includedir@,$includedir,;t t
- s,@oldincludedir@,$oldincludedir,;t t
- s,@infodir@,$infodir,;t t
- s,@mandir@,$mandir,;t t
- s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
- s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
- s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
- s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
- s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
- s,@build_alias@,$build_alias,;t t
- s,@host_alias@,$host_alias,;t t
- s,@target_alias@,$target_alias,;t t
- s,@ECHO_C@,$ECHO_C,;t t
- s,@ECHO_N@,$ECHO_N,;t t
- s,@ECHO_T@,$ECHO_T,;t t
- s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
- s,@DEFS@,$DEFS,;t t
- s,@LIBS@,$LIBS,;t t
- s,@build@,$build,;t t
- s,@build_cpu@,$build_cpu,;t t
- s,@build_vendor@,$build_vendor,;t t
- s,@build_os@,$build_os,;t t
- s,@host@,$host,;t t
- s,@host_cpu@,$host_cpu,;t t
- s,@host_vendor@,$host_vendor,;t t
- s,@host_os@,$host_os,;t t
- s,@target@,$target,;t t
- s,@target_cpu@,$target_cpu,;t t
- s,@target_vendor@,$target_vendor,;t t
- s,@target_os@,$target_os,;t t
- s,@CC@,$CC,;t t
- s,@CFLAGS@,$CFLAGS,;t t
- s,@LDFLAGS@,$LDFLAGS,;t t
- s,@CPPFLAGS@,$CPPFLAGS,;t t
- s,@ac_ct_CC@,$ac_ct_CC,;t t
- s,@EXEEXT@,$EXEEXT,;t t
- s,@OBJEXT@,$OBJEXT,;t t
- s,@CXX@,$CXX,;t t
- s,@CXXFLAGS@,$CXXFLAGS,;t t
- s,@ac_ct_CXX@,$ac_ct_CXX,;t t
- s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
- s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
- s,@INSTALL_DATA@,$INSTALL_DATA,;t t
- s,@LEX@,$LEX,;t t
- s,@LEXLIB@,$LEXLIB,;t t
- s,@LEX_OUTPUT_ROOT@,$LEX_OUTPUT_ROOT,;t t
- s,@YACC@,$YACC,;t t
- s,@CPP@,$CPP,;t t
- s,@CHOWN@,$CHOWN,;t t
- s,@OOPS_USER@,$OOPS_USER,;t t
- s,@SETOWNER@,$SETOWNER,;t t
- s,@OOPSUSER_DEF@,$OOPSUSER_DEF,;t t
- s,@YACCLIB@,$YACCLIB,;t t
- s,@EXTRASRC@,$EXTRASRC,;t t
- s,@SOFLAGS@,$SOFLAGS,;t t
- s,@MOD_EXT@,$MOD_EXT,;t t
- s,@OPT_MODS@,$OPT_MODS,;t t
- s,@STATIC_MODULES@,$STATIC_MODULES,;t t
- s,@LD@,$LD,;t t
- s,@VER@,$VER,;t t
- s,@LIBGB_PATH@,$LIBGB_PATH,;t t
- s,@LIBGB_NAME@,$LIBGB_NAME,;t t
- s,@LIBGB_INCL@,$LIBGB_INCL,;t t
- s,@LIBZ_NAME@,$LIBZ_NAME,;t t
- s,@CXXCOMPFLAGS@,$CXXCOMPFLAGS,;t t
- s,@CXXSOFLAGS@,$CXXSOFLAGS,;t t
- s,@MYSQL_LIB@,$MYSQL_LIB,;t t
- s,@PGSQL_LIB@,$PGSQL_LIB,;t t
- s,@OOPS_HOME@,$OOPS_HOME,;t t
- s,@OOPS_SBINDIR@,$OOPS_SBINDIR,;t t
- s,@OOPS_SYSCONFDIR@,$OOPS_SYSCONFDIR,;t t
- s,@OOPS_LOCALSTATEDIR@,$OOPS_LOCALSTATEDIR,;t t
- s,@OOPS_LIBDIR@,$OOPS_LIBDIR,;t t
- s,@OOPS_LIBS@,$OOPS_LIBS,;t t
- s,@OOPS_RPATH@,$OOPS_RPATH,;t t
- s,@LIBDB_INCL@,$LIBDB_INCL,;t t
- s,@LIBDB_PATH@,$LIBDB_PATH,;t t
- s,@LIBDB_RPATH@,$LIBDB_RPATH,;t t
- s,@LIBDB_NAME@,$LIBDB_NAME,;t t
  CEOF
- 
  EOF
  
!   cat >>$CONFIG_STATUS <<\EOF
!   # Split the substitutions into bite-sized pieces for seds with
!   # small command number limits, like on Digital OSF/1 and HP-UX.
!   ac_max_sed_lines=48
!   ac_sed_frag=1 # Number of current file.
!   ac_beg=1 # First line for current file.
!   ac_end=$ac_max_sed_lines # Line after last line for current file.
!   ac_more_lines=:
!   ac_sed_cmds=
!   while $ac_more_lines; do
!     if test $ac_beg -gt 1; then
!       sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
!     else
!       sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
!     fi
!     if test ! -s $tmp/subs.frag; then
!       ac_more_lines=false
      else
!       # The purpose of the label and of the branching condition is to
!       # speed up the sed processing (if there are no `@' at all, there
!       # is no need to browse any of the substitutions).
!       # These are the two extra sed commands mentioned above.
!       (echo ':t
!   /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
!       if test -z "$ac_sed_cmds"; then
!   	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
!       else
!   	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
!       fi
!       ac_sed_frag=`expr $ac_sed_frag + 1`
!       ac_beg=$ac_end
!       ac_end=`expr $ac_end + $ac_max_sed_lines`
      fi
!   done
!   if test -z "$ac_sed_cmds"; then
!     ac_sed_cmds=cat
    fi
! fi # test -n "$CONFIG_FILES"
  
  EOF
! cat >>$CONFIG_STATUS <<\EOF
! for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case $ac_file in
!   - | *:- | *:-:* ) # input from stdin
!         cat >$tmp/stdin
!         ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   * )   ac_file_in=$ac_file.in ;;
    esac
  
!   # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
!   ac_dir=`$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
!          X"$ac_file" : 'X\(//\)[^/]' \| \
!          X"$ac_file" : 'X\(//\)$' \| \
!          X"$ac_file" : 'X\(/\)' \| \
!          .     : '\(.\)' 2>/dev/null ||
! echo X"$ac_file" |
!     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
!   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
!   	  /^X\(\/\/\)$/{ s//\1/; q; }
!   	  /^X\(\/\).*/{ s//\1/; q; }
!   	  s/.*/./; q'`
!   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!     { case "$ac_dir" in
!   [\\/]* | ?:[\\/]* ) as_incr_dir=;;
!   *)                      as_incr_dir=.;;
! esac
! as_dummy="$ac_dir"
! for as_mkdir_dir in `IFS='/\\'; set X $as_dummy; shift; echo "$@"`; do
!   case $as_mkdir_dir in
!     # Skip DOS drivespec
!     ?:) as_incr_dir=$as_mkdir_dir ;;
!     *)
!       as_incr_dir=$as_incr_dir/$as_mkdir_dir
!       test -d "$as_incr_dir" || mkdir "$as_incr_dir"
!     ;;
!   esac
! done; }
  
!     ac_dir_suffix="/`echo $ac_dir|sed 's,^\./,,'`"
      # A "../" for each directory in $ac_dir_suffix.
!     ac_dots=`echo "$ac_dir_suffix" | sed 's,/[^/]*,../,g'`
    else
      ac_dir_suffix= ac_dots=
    fi
  
!   case $srcdir in
!   .)  ac_srcdir=.
!       if test -z "$ac_dots"; then
!          ac_top_srcdir=.
!       else
!          ac_top_srcdir=`echo $ac_dots | sed 's,/$,,'`
!       fi ;;
!   [\\/]* | ?:[\\/]* )
!       ac_srcdir=$srcdir$ac_dir_suffix;
!       ac_top_srcdir=$srcdir ;;
    *) # Relative path.
!     ac_srcdir=$ac_dots$srcdir$ac_dir_suffix
!     ac_top_srcdir=$ac_dots$srcdir ;;
    esac
  
!   case $INSTALL in
!   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
!   *) ac_INSTALL=$ac_dots$INSTALL ;;
    esac
- 
-   if test x"$ac_file" != x-; then
-     { echo "$as_me:5549: creating $ac_file" >&5
- echo "$as_me: creating $ac_file" >&6;}
-     rm -f "$ac_file"
-   fi
-   # Let's still pretend it is `configure' which instantiates (i.e., don't
-   # use $as_me), people would be surprised to read:
-   #    /* config.h.  Generated automatically by config.status.  */
-   configure_input="Generated automatically from `echo $ac_file_in |
-                                                  sed 's,.*/,,'` by configure."
- 
-   # First look for the input files in the build tree, otherwise in the
-   # src tree.
-   ac_file_inputs=`IFS=:
-     for f in $ac_file_in; do
-       case $f in
-       -) echo $tmp/stdin ;;
-       [\\/$]*)
-          # Absolute (can't be DOS-style, as IFS=:)
-          test -f "$f" || { { echo "$as_me:5567: error: cannot find input file: $f" >&5
- echo "$as_me: error: cannot find input file: $f" >&2;}
-    { (exit 1); exit 1; }; }
-          echo $f;;
-       *) # Relative
-          if test -f "$f"; then
-            # Build tree
-            echo $f
-          elif test -f "$srcdir/$f"; then
-            # Source tree
-            echo $srcdir/$f
-          else
-            # /dev/null tree
-            { { echo "$as_me:5580: error: cannot find input file: $f" >&5
- echo "$as_me: error: cannot find input file: $f" >&2;}
-    { (exit 1); exit 1; }; }
-          fi;;
-       esac
-     done` || { (exit 1); exit 1; }
- EOF
- cat >>$CONFIG_STATUS <<EOF
-   sed "$ac_vpsub
- $extrasub
- EOF
- cat >>$CONFIG_STATUS <<\EOF
- :t
- /@[a-zA-Z_][a-zA-Z_0-9]*@/!b
- s,@configure_input@,$configure_input,;t t
- s,@srcdir@,$ac_srcdir,;t t
- s,@top_srcdir@,$ac_top_srcdir,;t t
- s,@INSTALL@,$ac_INSTALL,;t t
- " $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
-   rm -f $tmp/stdin
-   if test x"$ac_file" != x-; then
-     mv $tmp/out $ac_file
-   else
-     cat $tmp/out
-     rm -f $tmp/out
-   fi
  
! done
! EOF
! cat >>$CONFIG_STATUS <<\EOF
  
! #
! # CONFIG_HEADER section.
! #
  
  # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
  # NAME is the cpp macro being defined and VALUE is the value it is being given.
  #
  # ac_d sets the value in "#define NAME VALUE" lines.
! ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
! ac_dB='[ 	].*$,\1#\2'
! ac_dC=' '
! ac_dD=',;t'
! # ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
! ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
! ac_uB='$,\1#\2define\3'
  ac_uC=' '
! ac_uD=',;t'
  
! for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case $ac_file in
!   - | *:- | *:-:* ) # input from stdin
!         cat >$tmp/stdin
!         ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
!         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
!   * )   ac_file_in=$ac_file.in ;;
    esac
  
!   test x"$ac_file" != x- && { echo "$as_me:5641: creating $ac_file" >&5
! echo "$as_me: creating $ac_file" >&6;}
  
!   # First look for the input files in the build tree, otherwise in the
!   # src tree.
!   ac_file_inputs=`IFS=:
!     for f in $ac_file_in; do
!       case $f in
!       -) echo $tmp/stdin ;;
!       [\\/$]*)
!          # Absolute (can't be DOS-style, as IFS=:)
!          test -f "$f" || { { echo "$as_me:5652: error: cannot find input file: $f" >&5
! echo "$as_me: error: cannot find input file: $f" >&2;}
!    { (exit 1); exit 1; }; }
!          echo $f;;
!       *) # Relative
!          if test -f "$f"; then
!            # Build tree
!            echo $f
!          elif test -f "$srcdir/$f"; then
!            # Source tree
!            echo $srcdir/$f
!          else
!            # /dev/null tree
!            { { echo "$as_me:5665: error: cannot find input file: $f" >&5
! echo "$as_me: error: cannot find input file: $f" >&2;}
!    { (exit 1); exit 1; }; }
!          fi;;
!       esac
!     done` || { (exit 1); exit 1; }
!   # Remove the trailing spaces.
!   sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
  
  EOF
  
! # Transform confdefs.h into two sed scripts, `conftest.defines' and
! # `conftest.undefs', that substitutes the proper values into
! # config.h.in to produce config.h.  The first handles `#define'
! # templates, and the second `#undef' templates.
! # And first: Protect against being on the right side of a sed subst in
! # config.status.  Protect against being in an unquoted here document
! # in config.status.
! rm -f conftest.defines conftest.undefs
! # Using a here document instead of a string reduces the quoting nightmare.
! # Putting comments in sed scripts is not portable.
! #
! # `end' is used to avoid that the second main sed command (meant for
! # 0-ary CPP macros) applies to n-ary macro definitions.
! # See the Autoconf documentation for `clear'.
! cat >confdef2sed.sed <<\EOF
! s/[\\&,]/\\&/g
! s,[\\$`],\\&,g
! t clear
! : clear
! s,^[ 	]*#[ 	]*define[ 	][ 	]*\(\([^ 	(][^ 	(]*\)([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\2${ac_dB}\1${ac_dC}\3${ac_dD},gp
! t end
! s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
! : end
! EOF
! # If some macros were called several times there might be several times
! # the same #defines, which is useless.  Nevertheless, we may not want to
! # sort them, since we want the *last* AC-DEFINE to be honored.
! uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
! sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
! rm -f confdef2sed.sed
  
  # This sed command replaces #undef with comments.  This is necessary, for
  # example, in the case of _POSIX_SOURCE, which is predefined and required
  # on some systems where configure will not decide to define it.
! cat >>conftest.undefs <<\EOF
! s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
  EOF
  
! # Break up conftest.defines because some shells have a limit on the size
! # of here documents, and old seds have small limits too (100 cmds).
! echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
! echo '  if egrep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
! echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
! echo '  :' >>$CONFIG_STATUS
! rm -f conftest.tail
! while grep . conftest.defines >/dev/null
! do
!   # Write a limited-size here document to $tmp/defines.sed.
!   echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
!   # Speed up: don't consider the non `#define' lines.
!   echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
!   # Work around the forget-to-reset-the-flag bug.
!   echo 't clr' >>$CONFIG_STATUS
!   echo ': clr' >>$CONFIG_STATUS
!   sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
!   echo 'CEOF
!   sed -f $tmp/defines.sed $tmp/in >$tmp/out
!   rm -f $tmp/in
!   mv $tmp/out $tmp/in
! ' >>$CONFIG_STATUS
!   sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
!   rm -f conftest.defines
!   mv conftest.tail conftest.defines
! done
! rm -f conftest.defines
! echo '  fi # egrep' >>$CONFIG_STATUS
! echo >>$CONFIG_STATUS
! 
! # Break up conftest.undefs because some shells have a limit on the size
! # of here documents, and old seds have small limits too (100 cmds).
! echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
  rm -f conftest.tail
! while grep . conftest.undefs >/dev/null
  do
!   # Write a limited-size here document to $tmp/undefs.sed.
!   echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
!   # Speed up: don't consider the non `#undef'
!   echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
!   # Work around the forget-to-reset-the-flag bug.
!   echo 't clr' >>$CONFIG_STATUS
!   echo ': clr' >>$CONFIG_STATUS
!   sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
    echo 'CEOF
!   sed -f $tmp/undefs.sed $tmp/in >$tmp/out
!   rm -f $tmp/in
!   mv $tmp/out $tmp/in
! ' >>$CONFIG_STATUS
!   sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
!   rm -f conftest.undefs
!   mv conftest.tail conftest.undefs
! done
! rm -f conftest.undefs
! 
! cat >>$CONFIG_STATUS <<\EOF
!   # Let's still pretend it is `configure' which instantiates (i.e., don't
!   # use $as_me), people would be surprised to read:
!   #    /* config.h.  Generated automatically by config.status.  */
!   if test x"$ac_file" = x-; then
!     echo "/* Generated automatically by configure.  */" >$tmp/config.h
    else
!     echo "/* $ac_file.  Generated automatically by configure.  */" >$tmp/config.h
!   fi
!   cat $tmp/in >>$tmp/config.h
!   rm -f $tmp/in
!   if test x"$ac_file" != x-; then
!     if cmp -s $ac_file $tmp/config.h 2>/dev/null; then
!       { echo "$as_me:5782: $ac_file is unchanged" >&5
! echo "$as_me: $ac_file is unchanged" >&6;}
!     else
!       ac_dir=`$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
!          X"$ac_file" : 'X\(//\)[^/]' \| \
!          X"$ac_file" : 'X\(//\)$' \| \
!          X"$ac_file" : 'X\(/\)' \| \
!          .     : '\(.\)' 2>/dev/null ||
! echo X"$ac_file" |
!     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
!   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
!   	  /^X\(\/\/\)$/{ s//\1/; q; }
!   	  /^X\(\/\).*/{ s//\1/; q; }
!   	  s/.*/./; q'`
        if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!         { case "$ac_dir" in
!   [\\/]* | ?:[\\/]* ) as_incr_dir=;;
!   *)                      as_incr_dir=.;;
! esac
! as_dummy="$ac_dir"
! for as_mkdir_dir in `IFS='/\\'; set X $as_dummy; shift; echo "$@"`; do
!   case $as_mkdir_dir in
!     # Skip DOS drivespec
!     ?:) as_incr_dir=$as_mkdir_dir ;;
!     *)
!       as_incr_dir=$as_incr_dir/$as_mkdir_dir
!       test -d "$as_incr_dir" || mkdir "$as_incr_dir"
!     ;;
!   esac
! done; }
! 
!       fi
!       rm -f $ac_file
!       mv $tmp/config.h $ac_file
      fi
!   else
!     cat $tmp/config.h
!     rm -f $tmp/config.h
    fi
! done
  EOF
  
! cat >>$CONFIG_STATUS <<\EOF
  
! { (exit 0); exit 0; }
  EOF
  chmod +x $CONFIG_STATUS
! ac_clean_files=$ac_clean_files_save
  
- # configure is writing to config.log, and then calls config.status.
- # config.status does its own redirection, appending to config.log.
- # Unfortunately, on DOS this fails, as config.log is still kept open
- # by configure, so config.status won't be able to write to it; its
- # output is simply discarded.  So we exec the FD to /dev/null,
- # effectively closing config.log, so it can be properly (re)opened and
- # appended to by config.status.  When coming back to configure, we
- # need to make the FD available again.
- if test "$no_create" != yes; then
-   ac_cs_success=:
-   exec 5>/dev/null
-   $SHELL $CONFIG_STATUS || ac_cs_success=false
-   exec 5>>config.log
-   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-   # would make configure fail if this is the last instruction.
-   $ac_cs_success || { (exit 1); exit 1; }
- fi
  
  if test "X$LIBDB_NAME" = "X" ; then
      if test "X$LIBGB_NAME" = "X" ; then
--- 3209,3675 ----
  OOPS_LIBDIR=$oops_libdir
  
  OOPS_HOME="$oops_prefix/oops"
+ 
+ 
+ 
+ 
  
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! cat >> confdefs.h <<EOF
  #define OOPS_HOME "$oops_prefix/oops"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_SBINDIR "$oops_sbindir"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_SYSCONFDIR "$oops_sysconfdir"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_LOCALSTATEDIR "$oops_localstatedir"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_LIBDIR "$oops_libdir"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_CFG "$oops_sysconfdir/oops.cfg"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_CC "$CC"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_CFLAGS "$CFLAGS"
  EOF
  
! cat >> confdefs.h <<EOF
  #define OOPS_LIBS "$LIBS"
  EOF
  
  
! trap '' 1 2 15
! cat > confcache <<\EOF
  # This file is a shell script that caches the results of configure
  # tests run on this system so they can be shared between configure
! # scripts and configure runs.  It is not useful on other systems.
! # If it contains results you don't want to keep, you may remove or edit it.
  #
! # By default, configure uses ./config.cache as the cache file,
! # creating it if it does not exist already.  You can give configure
! # the --cache-file=FILE option to use a different cache file; that is
! # what configure does when it calls configure scripts in
! # subdirectories, so they share the cache.
! # Giving --cache-file=/dev/null disables caching, for debugging configure.
! # config.status only pays attention to the cache file if you give it the
! # --recheck option to rerun configure.
  #
! EOF
  # The following way of writing the cache mishandles newlines in values,
  # but we know of no workaround that is simple, portable, and efficient.
  # So, don't put newlines in cache variables' values.
  # Ultrix sh set writes to stderr and can't be redirected directly,
  # and sets the high bit in the cache file unless we assign to the vars.
! (set) 2>&1 |
!   case `(ac_space=' '; set | grep ac_space) 2>&1` in
!   *ac_space=\ *)
!     # `set' does not quote correctly, so add quotes (double-quote substitution
!     # turns \\\\ into \\, and sed turns \\ into \).
!     sed -n \
!       -e "s/'/'\\\\''/g" \
!       -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
!     ;;
!   *)
!     # `set' quotes correctly as required by POSIX, so do not add quotes.
!     sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
!     ;;
!   esac >> confcache
! if cmp -s $cache_file confcache; then
!   :
! else
    if test -w $cache_file; then
!     echo "updating cache $cache_file"
!     cat confcache > $cache_file
    else
      echo "not updating unwritable cache $cache_file"
    fi
  fi
  rm -f confcache
  
+ trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+ 
  test "x$prefix" = xNONE && prefix=$ac_default_prefix
  # Let make expand exec_prefix.
  test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
  
! # Any assignment to VPATH causes Sun make to only execute
! # the first set of double-colon rules, so remove it if not needed.
! # If there is a colon in the path, we need to keep it.
  if test "x$srcdir" = x.; then
!   ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
  fi
  
+ trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+ 
  DEFS=-DHAVE_CONFIG_H
  
+ # Without the "./", some shells look in PATH for config.status.
  : ${CONFIG_STATUS=./config.status}
! 
! echo creating $CONFIG_STATUS
! rm -f $CONFIG_STATUS
! cat > $CONFIG_STATUS <<EOF
! #! /bin/sh
  # Generated automatically by configure.
  # Run this file to recreate the current configuration.
+ # This directory was configured as follows,
+ # on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+ #
+ # $0 $ac_configure_args
+ #
  # Compiler output produced by configure, useful for debugging
! # configure, is in ./config.log if it exists.
  
! ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
! for ac_option
  do
!   case "\$ac_option" in
    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
!     echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
!     exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
!   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
!     echo "$CONFIG_STATUS generated by autoconf version 2.13"
!     exit 0 ;;
!   -help | --help | --hel | --he | --h)
!     echo "\$ac_cs_usage"; exit 0 ;;
!   *) echo "\$ac_cs_usage"; exit 1 ;;
    esac
  done
  
! ac_given_srcdir=$srcdir
! ac_given_INSTALL="$INSTALL"
  
+ trap 'rm -fr `echo "src/Makefile src/modules/Makefile src/oops.cfg doc/oops.8 doc/oopsctl.8 src/config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
  EOF
+ cat >> $CONFIG_STATUS <<EOF
  
! # Protect against being on the right side of a sed subst in config.status.
! sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
!  s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
! $ac_vpsub
! $extrasub
! s%@SHELL@%$SHELL%g
! s%@CFLAGS@%$CFLAGS%g
! s%@CPPFLAGS@%$CPPFLAGS%g
! s%@CXXFLAGS@%$CXXFLAGS%g
! s%@FFLAGS@%$FFLAGS%g
! s%@DEFS@%$DEFS%g
! s%@LDFLAGS@%$LDFLAGS%g
! s%@LIBS@%$LIBS%g
! s%@exec_prefix@%$exec_prefix%g
! s%@prefix@%$prefix%g
! s%@program_transform_name@%$program_transform_name%g
! s%@bindir@%$bindir%g
! s%@sbindir@%$sbindir%g
! s%@libexecdir@%$libexecdir%g
! s%@datadir@%$datadir%g
! s%@sysconfdir@%$sysconfdir%g
! s%@sharedstatedir@%$sharedstatedir%g
! s%@localstatedir@%$localstatedir%g
! s%@libdir@%$libdir%g
! s%@includedir@%$includedir%g
! s%@oldincludedir@%$oldincludedir%g
! s%@infodir@%$infodir%g
! s%@mandir@%$mandir%g
! s%@host@%$host%g
! s%@host_alias@%$host_alias%g
! s%@host_cpu@%$host_cpu%g
! s%@host_vendor@%$host_vendor%g
! s%@host_os@%$host_os%g
! s%@target@%$target%g
! s%@target_alias@%$target_alias%g
! s%@target_cpu@%$target_cpu%g
! s%@target_vendor@%$target_vendor%g
! s%@target_os@%$target_os%g
! s%@build@%$build%g
! s%@build_alias@%$build_alias%g
! s%@build_cpu@%$build_cpu%g
! s%@build_vendor@%$build_vendor%g
! s%@build_os@%$build_os%g
! s%@CC@%$CC%g
! s%@CXX@%$CXX%g
! s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
! s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
! s%@INSTALL_DATA@%$INSTALL_DATA%g
! s%@LEX@%$LEX%g
! s%@LEXLIB@%$LEXLIB%g
! s%@YACC@%$YACC%g
! s%@CPP@%$CPP%g
! s%@CHOWN@%$CHOWN%g
! s%@OOPS_USER@%$OOPS_USER%g
! s%@SETOWNER@%$SETOWNER%g
! s%@OOPSUSER_DEF@%$OOPSUSER_DEF%g
! s%@YACCLIB@%$YACCLIB%g
! s%@EXTRASRC@%$EXTRASRC%g
! s%@SOFLAGS@%$SOFLAGS%g
! s%@MOD_EXT@%$MOD_EXT%g
! s%@OPT_MODS@%$OPT_MODS%g
! s%@STATIC_MODULES@%$STATIC_MODULES%g
! s%@LD@%$LD%g
! s%@VER@%$VER%g
! s%@LIBGB_PATH@%$LIBGB_PATH%g
! s%@LIBGB_NAME@%$LIBGB_NAME%g
! s%@LIBGB_INCL@%$LIBGB_INCL%g
! s%@LIBZ_NAME@%$LIBZ_NAME%g
! s%@CXXCOMPFLAGS@%$CXXCOMPFLAGS%g
! s%@CXXSOFLAGS@%$CXXSOFLAGS%g
! s%@MYSQL_LIB@%$MYSQL_LIB%g
! s%@PGSQL_LIB@%$PGSQL_LIB%g
! s%@OOPS_HOME@%$OOPS_HOME%g
! s%@OOPS_SBINDIR@%$OOPS_SBINDIR%g
! s%@OOPS_SYSCONFDIR@%$OOPS_SYSCONFDIR%g
! s%@OOPS_LOCALSTATEDIR@%$OOPS_LOCALSTATEDIR%g
! s%@OOPS_LIBDIR@%$OOPS_LIBDIR%g
! s%@OOPS_LIBS@%$OOPS_LIBS%g
! s%@OOPS_RPATH@%$OOPS_RPATH%g
! s%@LIBDB_INCL@%$LIBDB_INCL%g
! s%@LIBDB_PATH@%$LIBDB_PATH%g
! s%@LIBDB_RPATH@%$LIBDB_RPATH%g
! s%@LIBDB_NAME@%$LIBDB_NAME%g
  
  CEOF
  EOF
  
! cat >> $CONFIG_STATUS <<\EOF
! 
! # Split the substitutions into bite-sized pieces for seds with
! # small command number limits, like on Digital OSF/1 and HP-UX.
! ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
! ac_file=1 # Number of current file.
! ac_beg=1 # First line for current file.
! ac_end=$ac_max_sed_cmds # Line after last line for current file.
! ac_more_lines=:
! ac_sed_cmds=""
! while $ac_more_lines; do
!   if test $ac_beg -gt 1; then
!     sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
!   else
!     sed "${ac_end}q" conftest.subs > conftest.s$ac_file
!   fi
!   if test ! -s conftest.s$ac_file; then
!     ac_more_lines=false
!     rm -f conftest.s$ac_file
!   else
!     if test -z "$ac_sed_cmds"; then
!       ac_sed_cmds="sed -f conftest.s$ac_file"
      else
!       ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
      fi
!     ac_file=`expr $ac_file + 1`
!     ac_beg=$ac_end
!     ac_end=`expr $ac_end + $ac_max_sed_cmds`
    fi
! done
! if test -z "$ac_sed_cmds"; then
!   ac_sed_cmds=cat
! fi
! EOF
  
+ cat >> $CONFIG_STATUS <<EOF
+ 
+ CONFIG_FILES=\${CONFIG_FILES-"src/Makefile src/modules/Makefile src/oops.cfg doc/oops.8 doc/oopsctl.8"}
  EOF
! cat >> $CONFIG_STATUS <<\EOF
! for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case "$ac_file" in
!   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
!        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
!   *) ac_file_in="${ac_file}.in" ;;
    esac
  
!   # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
  
!   # Remove last slash and all that follows it.  Not all systems have dirname.
!   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
!   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!     # The file is in a subdirectory.
!     test ! -d "$ac_dir" && mkdir "$ac_dir"
!     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
      # A "../" for each directory in $ac_dir_suffix.
!     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
    else
      ac_dir_suffix= ac_dots=
    fi
  
!   case "$ac_given_srcdir" in
!   .)  srcdir=.
!       if test -z "$ac_dots"; then top_srcdir=.
!       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
!   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
    *) # Relative path.
!     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
!     top_srcdir="$ac_dots$ac_given_srcdir" ;;
    esac
  
!   case "$ac_given_INSTALL" in
!   [/$]*) INSTALL="$ac_given_INSTALL" ;;
!   *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
    esac
  
!   echo creating "$ac_file"
!   rm -f "$ac_file"
!   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
!   case "$ac_file" in
!   *Makefile*) ac_comsub="1i\\
! # $configure_input" ;;
!   *) ac_comsub= ;;
!   esac
  
!   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
!   sed -e "$ac_comsub
! s%@configure_input@%$configure_input%g
! s%@srcdir@%$srcdir%g
! s%@top_srcdir@%$top_srcdir%g
! s%@INSTALL@%$INSTALL%g
! " $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
! fi; done
! rm -f conftest.s*
  
  # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
  # NAME is the cpp macro being defined and VALUE is the value it is being given.
  #
  # ac_d sets the value in "#define NAME VALUE" lines.
! ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
! ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
! ac_dC='\3'
! ac_dD='%g'
! # ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
! ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
! ac_uB='\([ 	]\)%\1#\2define\3'
  ac_uC=' '
! ac_uD='\4%g'
! # ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
! ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
! ac_eB='$%\1#\2define\3'
! ac_eC=' '
! ac_eD='%g'
  
! if test "${CONFIG_HEADERS+set}" != set; then
! EOF
! cat >> $CONFIG_STATUS <<EOF
!   CONFIG_HEADERS="src/config.h"
! EOF
! cat >> $CONFIG_STATUS <<\EOF
! fi
! for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
    # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
!   case "$ac_file" in
!   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
!        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
!   *) ac_file_in="${ac_file}.in" ;;
    esac
  
!   echo creating $ac_file
  
!   rm -f conftest.frag conftest.in conftest.out
!   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
!   cat $ac_file_inputs > conftest.in
  
  EOF
  
! # Transform confdefs.h into a sed script conftest.vals that substitutes
! # the proper values into config.h.in to produce config.h.  And first:
! # Protect against being on the right side of a sed subst in config.status.
! # Protect against being in an unquoted here document in config.status.
! rm -f conftest.vals
! cat > conftest.hdr <<\EOF
! s/[\\&%]/\\&/g
! s%[\\$`]%\\&%g
! s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
! s%ac_d%ac_u%gp
! s%ac_u%ac_e%gp
! EOF
! sed -n -f conftest.hdr confdefs.h > conftest.vals
! rm -f conftest.hdr
  
  # This sed command replaces #undef with comments.  This is necessary, for
  # example, in the case of _POSIX_SOURCE, which is predefined and required
  # on some systems where configure will not decide to define it.
! cat >> conftest.vals <<\EOF
! s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
  EOF
  
! # Break up conftest.vals because some shells have a limit on
! # the size of here documents, and old seds have small limits too.
! 
  rm -f conftest.tail
! while :
  do
!   ac_lines=`grep -c . conftest.vals`
!   # grep -c gives empty output for an empty file on some AIX systems.
!   if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
!   # Write a limited-size here document to conftest.frag.
!   echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
!   sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
    echo 'CEOF
!   sed -f conftest.frag conftest.in > conftest.out
!   rm -f conftest.in
!   mv conftest.out conftest.in
! ' >> $CONFIG_STATUS
!   sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
!   rm -f conftest.vals
!   mv conftest.tail conftest.vals
! done
! rm -f conftest.vals
! 
! cat >> $CONFIG_STATUS <<\EOF
!   rm -f conftest.frag conftest.h
!   echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
!   cat conftest.in >> conftest.h
!   rm -f conftest.in
!   if cmp -s $ac_file conftest.h 2>/dev/null; then
!     echo "$ac_file is unchanged"
!     rm -f conftest.h
    else
!     # Remove last slash and all that follows it.  Not all systems have dirname.
!       ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
        if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
!       # The file is in a subdirectory.
!       test ! -d "$ac_dir" && mkdir "$ac_dir"
      fi
!     rm -f $ac_file
!     mv conftest.h $ac_file
    fi
! fi; done
! 
  EOF
+ cat >> $CONFIG_STATUS <<EOF
  
! EOF
! cat >> $CONFIG_STATUS <<\EOF
  
! exit 0
  EOF
  chmod +x $CONFIG_STATUS
! rm -fr confdefs* $ac_clean_files
! test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
  
  
  if test "X$LIBDB_NAME" = "X" ; then
      if test "X$LIBGB_NAME" = "X" ; then
Index: contrib/nettune
===================================================================
RCS file: /usr/local/cvs/oops/contrib/nettune,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -r1.2 -r1.3
*** nettune	2001/03/26 12:27:22	1.2
--- nettune	2002/03/03 06:31:16	1.3
***************
*** 1,18 ****
  #!/sbin/sh
  ############################################################################
! # $Id: diff_from_1.5.22.patch,v 1.1.1.1 2004/02/19 22:21:45 shattered Exp $
  #
! # Author: Jens-S. Vckler <voeckler@rvs.uni-hannover.de>
  #         Jean Chouanard <chouanard@parc.xerox.com>
  #
  ############################################################################
  #
  # /etc/rcS.d/S31nettune -> /etc/init.d/nettune
  #
! # See : http://www.rvs.uni-hannover.de/people/voeckler/tune/EN/your-tune
! # and : http://www.rvs.uni-hannover.de/people/voeckler/tune/EN/tune.html
  #
  
  # insert configuration from secure installation tool, 
  # see: http://yassp.parc.xerox.com/
  test -r /etc/yassp.conf && . /etc/yassp.conf
--- 1,27 ----
  #!/sbin/sh
  ############################################################################
! # $Id: diff_from_1.5.22.patch,v 1.1.1.1 2004/02/19 22:21:45 shattered Exp $
  #
! # Author: Jens-S. Vckler <solaris@sean.de>
  #         Jean Chouanard <chouanard@parc.xerox.com>
  #
  ############################################################################
  #
  # /etc/rcS.d/S31nettune -> /etc/init.d/nettune
  #
! # See : http://www.sean.de/Solaris/nettune
! # and : http://www.sean.de/Solaris/
  #
  
+ # insanity checks
+ if [ "`uname`" != "SunOS" ]; then
+     echo "This is not a Solaris system!"
+     exit 1
+ fi
+ 
+ # parameter "stop" is a noop, exit ASAP.
+ test "$1" = "stop" && exit 0
+ 
  # insert configuration from secure installation tool, 
  # see: http://yassp.parc.xerox.com/
  test -r /etc/yassp.conf && . /etc/yassp.conf
***************
*** 22,31 ****
      NET_SECURITY=YES
  fi
  
! # set default paths and say hello
  PATH=/usr/sbin:/usr/bin
- echo "Tweaking Solaris TCP/IP: \c"
  
  # determine, if SunOS 5.6 (Solaris 2.6) or above is installed (care w/ 2.5.1!)
  osver=`uname -r | sed 's/\.//' | awk '{ print $1*10 }'`
  
--- 31,65 ----
      NET_SECURITY=YES
  fi
  
! # set secure defaults
  PATH=/usr/sbin:/usr/bin
  
+ # Further legal parameters are "start" (tweak), and no parameter (show)
+ if [ "$1" = "start" ]; then 
+     TWEAK=1
+     action='tweaking'
+     echo "Tweaking Solaris TCP/IP: \c"
+ else
+     TWEAK=0
+     action='showing'
+     echo "Showing Solaris TCP/IP: \c"
+ fi
+ 
+ modlist () {
+     # purpose: show and/or set a parameter 
+     # paramtr: $1: device to use
+     #          $2: name of parameter
+     #          $3..$n: advised value(s)
+     # globals: $TWEAK: 0: show, 1: tweak
+     #          $YASSP_VERBOSE: show content before setting
+     device=$1; shift
+     parameter=$1; shift
+     test $TWEAK -eq 0 -o "$YASSP_VERBOSE" -gt 0 &&
+ 	echo "$parameter `ndd $device $parameter` advised $@"
+     test $TWEAK -eq 1 && 
+ 	ndd -set $device $parameter $@
+ }
+ 
  # determine, if SunOS 5.6 (Solaris 2.6) or above is installed (care w/ 2.5.1!)
  osver=`uname -r | sed 's/\.//' | awk '{ print $1*10 }'`
  
***************
*** 70,89 ****
  # tcp_conn_req_max_q0	1024
  #
  if [ $osver -ge 560 -o $patch -ge 12 ]; then
!      # Solaris 2.6 *OR* patch 103582-12 or above applied
!      echo "   tweaking separate connection queues"
!      ndd -set /dev/tcp tcp_conn_req_max_q 512   # 128 for restrictions
!      if [ "YES${NET_SECURITY}" = "YESYES" ] ; then
  	# use 10240 for SYN flood symptom treatment
! 	echo "   tweaking against SYN flood symptoms"
! 	ndd -set /dev/tcp tcp_conn_req_max_q0 10240
!      else
! 	ndd -set /dev/tcp tcp_conn_req_max_q0 1024
!      fi
  else
!      # Solaris 2.5.1 or below, no patch
!      echo "   tweaking single connection queue"
!      ndd -set /dev/tcp tcp_conn_req_max 512     # Hmmm, how about 1024
  fi
  
  
--- 104,123 ----
  # tcp_conn_req_max_q0	1024
  #
  if [ $osver -ge 560 -o $patch -ge 12 ]; then
!     # Solaris 2.6 *OR* patch 103582-12 or above applied
!     echo "   $action separate connection queues"
!     modlist /dev/tcp tcp_conn_req_max_q 512   # 128 for restrictions
!     if [ "YES${NET_SECURITY}" = "YESYES" ] ; then
  	# use 10240 for SYN flood symptom treatment
! 	echo "   $action against SYN flood symptoms"
! 	modlist /dev/tcp tcp_conn_req_max_q0 10240
!     else
!         modlist /dev/tcp tcp_conn_req_max_q0 1024
!     fi
  else
!     # Solaris 2.5.1 or below, no patch
!     echo "   $action single connection queue"
!     modlist /dev/tcp tcp_conn_req_max 512     # Hmmm, how about 1024
  fi
  
  
***************
*** 96,107 ****
  # tcp_ip_abort_cinterval	180000
  # tcp_rexmit_interval_max	60000
  #
! echo "   tweaking timeouts"
! ndd -set /dev/tcp tcp_rexmit_interval_initial 3000 # 500 for laboratories
! ndd -set /dev/tcp tcp_rexmit_interval_min 2000     # 200 for laboratories
! ndd -set /dev/tcp tcp_ip_abort_interval 600000     # 10 min before drop
! ndd -set /dev/tcp tcp_ip_abort_cinterval 60000     # 60 sec to estab. conn.
! ndd -set /dev/tcp tcp_rexmit_interval_max 60000    # free nw resources quickly
  
  #
  # slow start bug / feature           Sol8
--- 130,141 ----
  # tcp_ip_abort_cinterval	180000
  # tcp_rexmit_interval_max	60000
  #
! echo "   $action timeouts"
! modlist /dev/tcp tcp_rexmit_interval_initial 3000 # 500 for laboratories
! modlist /dev/tcp tcp_rexmit_interval_min 2000     # 200 for laboratories
! modlist /dev/tcp tcp_ip_abort_interval 600000     # 10 min before drop
! modlist /dev/tcp tcp_ip_abort_cinterval 60000     # 60 sec to estab. conn.
! modlist /dev/tcp tcp_rexmit_interval_max 60000    # free nw resources quickly
  
  #
  # slow start bug / feature           Sol8
***************
*** 112,120 ****
  if [ $osver -lt 580 ]; then
      if [ $osver -ge 560 -o $patch -ge 15 ]; then
  	# Solaris 2.6 *OR* patch 103582-15 or above applied
! 	echo "   tweaking slow start bug/feature"
! 	ndd -set /dev/tcp tcp_slow_start_initial 2    # Solaris 8 uses 4
! 	ndd -set /dev/tcp tcp_slow_start_after_idle 2 # Solaris 8 uses 4
      fi
  fi
  
--- 146,154 ----
  if [ $osver -lt 580 ]; then
      if [ $osver -ge 560 -o $patch -ge 15 ]; then
  	# Solaris 2.6 *OR* patch 103582-15 or above applied
! 	echo "   $action slow start bug/feature"
! 	modlist /dev/tcp tcp_slow_start_initial 2    # Solaris 8 uses 4
! 	modlist /dev/tcp tcp_slow_start_after_idle 2 # Solaris 8 uses 4
      fi
  fi
  
***************
*** 126,141 ****
  # tcp_fin_wait_2_flush_interval	675000
  # tcp_time_wait_interval	240000
  #
! echo "   tweaking pMTU discovery interval and common timers"
! ndd -set /dev/ip ip_ire_pathmtu_interval 600000
! ndd -set /dev/tcp tcp_keepalive_interval 3600000
! ndd -set /dev/tcp tcp_fin_wait_2_flush_interval 67500
  if [ $osver -le 560 ] ; then
       # Before Solaris 7
!      ndd -set /dev/tcp tcp_close_wait_interval 60000 # 2MSL value
  else
       # Solaris 7 has changed the name. It's now named for for it does.
!      ndd -set /dev/tcp tcp_time_wait_interval 60000 # 2MSL value
  fi
  
  #
--- 160,175 ----
  # tcp_fin_wait_2_flush_interval	675000
  # tcp_time_wait_interval	240000
  #
! echo "   $action pMTU discovery interval and common timers"
! modlist /dev/ip ip_ire_pathmtu_interval 600000
! modlist /dev/tcp tcp_keepalive_interval 3600000
! modlist /dev/tcp tcp_fin_wait_2_flush_interval 67500
  if [ $osver -le 560 ] ; then
       # Before Solaris 7
!      modlist /dev/tcp tcp_close_wait_interval 60000 # 2MSL value
  else
       # Solaris 7 has changed the name. It's now named for for it does.
!      modlist /dev/tcp tcp_time_wait_interval 60000 # 2MSL value
  fi
  
  #
***************
*** 146,159 ****
  # tcp_smallest_anon_port	32768
  # udp_smallest_anon_port	32768
  #
! echo "   tweaking misc. parameters"
! ndd -set /dev/ip ip_icmp_err_interval 0
! ndd -set /dev/ip ip_forward_src_routed 0
! ndd -set /dev/tcp tcp_smallest_anon_port 8192
! ndd -set /dev/udp udp_smallest_anon_port 8192
  if [ $osver -ge 580 ]; then
      # ip6_forward_src_routed	1
!     ndd -set /dev/ip ip6_forward_src_routed 0
  fi
  
  #
--- 180,193 ----
  # tcp_smallest_anon_port	32768
  # udp_smallest_anon_port	32768
  #
! echo "   $action misc. parameters"
! modlist /dev/ip ip_icmp_err_interval 0
! modlist /dev/ip ip_forward_src_routed 0
! modlist /dev/tcp tcp_smallest_anon_port 8192
! modlist /dev/udp udp_smallest_anon_port 8192
  if [ $osver -ge 580 ]; then
      # ip6_forward_src_routed	1
!     modlist /dev/ip ip6_forward_src_routed 0
  fi
  
  #
***************
*** 180,235 ****
      # pointed out by Jean Chouanard (see Stevens 12.3 and E.4):
      # - uncomment, if you don't want to forward pings or other broadcasts
      #   to the broadcast address(es) of your installed interface(s).
!     ndd -set /dev/ip ip_forward_directed_broadcasts 0
  
      # - uncomment, if you have multiple interfaces installed, but don't
      #   want to act as a router (no forwarding). Reasonable for most hosts.
!     ndd -set /dev/ip ip_forwarding 0
!     test $osver -ge 580 && ndd -set /dev/ip ip6_forwarding 0
  
      # - uncomment, if you don't want to respond to a ping to any of your
      #   broadcast addresses. On one hand, it is rumored to have caused 
      #   panics. On the other hand, it is a valid response, and often 
      #   used to determine the UP hosts on a particular network.
!     ndd -set /dev/ip ip_respond_to_echo_broadcast 0
!     test $osver -ge 580 && ndd -set /dev/ip ip6_respond_to_echo_multicast 0
  
      # - uncomment, if you don't want to respond to a timestamp
      #   request, unicast or braodcast
!     ndd -set /dev/ip ip_respond_to_timestamp 0
!     ndd -set /dev/ip ip_respond_to_timestamp_broadcast 0
  
      # - For ICMP redirect protection
!     ndd -set /dev/ip ip_ignore_redirect 1
!     test $osver -ge 580 && ndd -set /dev/ip ip6_ignore_redirect 1
!     ndd -set /dev/ip ip_send_redirects 0
!     test $osver -ge 580 && ndd -set /dev/ip ip6_send_redirects 0
  
      # Next 3 from Titan ( See http://www.fish.com/titan/ )
      # - Unconditionally flush ARP info from IP routing table
      if [ $osver -le 570 ]; then
! 	ndd -set /dev/ip ip_ire_flush_interval 120000
      else
  	# is this the correct parameter?
! 	ndd -set /dev/ip ip_ire_arp_interval 120000
      fi
      # - discard ARP entry from ARP cache after this interval
!     ndd -set /dev/arp arp_cleanup_interval 60000
  
      # - Enable the 'strong end system' model from RFC 1122
      #   Beware, this might break some interface routing policies in
      #   combination with static routes - disable, if you need such.
!     ndd -set /dev/ip ip_strict_dst_multihoming 1
!     test $osver -ge 580 && ndd -set /dev/ip ip6_strict_dst_multihoming 1
  
      # - add the NFS port (TCP and UDP) as priviledged ports
      ndd /dev/udp udp_extra_priv_ports | grep 2049 1>/dev/null 2>&1
      if [ $? -ne 0 ]; then
! 	ndd -set /dev/udp udp_extra_priv_ports_add 2049
      fi
      ndd /dev/tcp tcp_extra_priv_ports| grep 2049  1>/dev/null 2>&1
      if [ $? -ne 0 ]; then
! 	ndd -set /dev/tcp tcp_extra_priv_ports_add 2049
      fi
  fi
  
--- 214,269 ----
      # pointed out by Jean Chouanard (see Stevens 12.3 and E.4):
      # - uncomment, if you don't want to forward pings or other broadcasts
      #   to the broadcast address(es) of your installed interface(s).
!     modlist /dev/ip ip_forward_directed_broadcasts 0
  
      # - uncomment, if you have multiple interfaces installed, but don't
      #   want to act as a router (no forwarding). Reasonable for most hosts.
!     modlist /dev/ip ip_forwarding 0
!     test $osver -ge 580 && modlist /dev/ip ip6_forwarding 0
  
      # - uncomment, if you don't want to respond to a ping to any of your
      #   broadcast addresses. On one hand, it is rumored to have caused 
      #   panics. On the other hand, it is a valid response, and often 
      #   used to determine the UP hosts on a particular network.
!     modlist /dev/ip ip_respond_to_echo_broadcast 0
!     test $osver -ge 580 && modlist /dev/ip ip6_respond_to_echo_multicast 0
  
      # - uncomment, if you don't want to respond to a timestamp
      #   request, unicast or braodcast
!     modlist /dev/ip ip_respond_to_timestamp 0
!     modlist /dev/ip ip_respond_to_timestamp_broadcast 0
  
      # - For ICMP redirect protection
!     modlist /dev/ip ip_ignore_redirect 1
!     test $osver -ge 580 && modlist /dev/ip ip6_ignore_redirect 1
!     modlist /dev/ip ip_send_redirects 0
!     test $osver -ge 580 && modlist /dev/ip ip6_send_redirects 0
  
      # Next 3 from Titan ( See http://www.fish.com/titan/ )
      # - Unconditionally flush ARP info from IP routing table
      if [ $osver -le 570 ]; then
! 	modlist /dev/ip ip_ire_flush_interval 120000
      else
  	# is this the correct parameter?
! 	modlist /dev/ip ip_ire_arp_interval 120000
      fi
      # - discard ARP entry from ARP cache after this interval
!     modlist /dev/arp arp_cleanup_interval 60000
  
      # - Enable the 'strong end system' model from RFC 1122
      #   Beware, this might break some interface routing policies in
      #   combination with static routes - disable, if you need such.
!     modlist /dev/ip ip_strict_dst_multihoming 1
!     test $osver -ge 580 && modlist /dev/ip ip6_strict_dst_multihoming 1
  
      # - add the NFS port (TCP and UDP) as priviledged ports
      ndd /dev/udp udp_extra_priv_ports | grep 2049 1>/dev/null 2>&1
      if [ $? -ne 0 ]; then
! 	modlist /dev/udp udp_extra_priv_ports_add 2049
      fi
      ndd /dev/tcp tcp_extra_priv_ports| grep 2049  1>/dev/null 2>&1
      if [ $? -ne 0 ]; then
! 	modlist /dev/tcp tcp_extra_priv_ports_add 2049
      fi
  fi
  
***************
*** 241,256 ****
  # tcp_xmit_hiwat	8192
  # tcp_recv_hiwat	8192
  #
! echo "   tweaking windows, buffers and watermarks"
! ndd -set /dev/udp udp_xmit_hiwat 16384 # max. UDP PDU size for sending
! ndd -set /dev/udp udp_recv_hiwat 64000 # queue for UDP
! ndd -set /dev/tcp tcp_xmit_hiwat 32768 # Cockroft's recommendation
! ndd -set /dev/tcp tcp_recv_hiwat 32768 # Cockroft's recommendation 
  
  
  # Note: Starting with Solaris 2.6 you can use tcp_host_param to boost 
  # just selected networks, with Solaris 8 IPv6 hosts separately, see: 
! # http://www.rvs.uni-hannover.de/people/voeckler/tune/EN/tune.html#thp
  #
  echo "done."
  
--- 275,290 ----
  # tcp_xmit_hiwat	8192
  # tcp_recv_hiwat	8192
  #
! echo "   $action windows, buffers and watermarks"
! modlist /dev/udp udp_xmit_hiwat 16384 # max. UDP PDU size for sending
! modlist /dev/udp udp_recv_hiwat 64000 # queue for UDP
! modlist /dev/tcp tcp_xmit_hiwat 32768 # Cockroft's recommendation
! modlist /dev/tcp tcp_recv_hiwat 32768 # Cockroft's recommendation 
  
  
  # Note: Starting with Solaris 2.6 you can use tcp_host_param to boost 
  # just selected networks, with Solaris 8 IPv6 hosts separately, see: 
! # http://www.sean.de/Solaris/tune.html#tcp_host_param
  #
  echo "done."
  
***************
*** 258,264 ****
  
  # ******************************************************************************
  # $Log: diff_from_1.5.22.patch,v $
  # Revision 1.1.1.1  2004/02/19 22:21:45  shattered
  # Oops is a multithreaded, modular, feature-rich caching FTP/HTTP proxy server.
  #
! # Revision 1.2  2001/03/26 12:27:22  ai
  # *** empty log message ***
  #
  # Revision 3.22  2000/07/13 19:34:53  chouanar
--- 292,298 ----
  
  # ******************************************************************************
  # $Log: diff_from_1.5.22.patch,v $
  # Revision 1.1.1.1  2004/02/19 22:21:45  shattered
  # Oops is a multithreaded, modular, feature-rich caching FTP/HTTP proxy server.
  #
! # Revision 1.3  2002/03/03 06:31:16  ai
  # *** empty log message ***
  #
  # Revision 3.22  2000/07/13 19:34:53  chouanar
Index: contrib/sol8_gre.tar.gz
===================================================================
RCS file: /usr/local/cvs/oops/contrib/sol8_gre.tar.gz,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
Binary files /tmp/cvsHAAa004Zm and /tmp/cvsIAAa004Zm differ
Index: src/accel_maps
===================================================================
RCS file: /usr/local/cvs/oops/src/accel_maps,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -r1.1.1.1 -r1.2
*** accel_maps	2000/04/06 14:07:41	1.1.1.1
--- accel_maps	2002/10/13 15:23:09	1.2
***************
*** 92,94 ****
--- 92,100 ----
  #	When request match ACL, then 'Location' header will be rewritten
  ##
  #	rewrite_location	REWRITEPORTS www(.*)ru:.* www$1.ru
+ #
+ ##
+ #
+ #
+ #canpurge	www.topping.com.ua
+ #canpurge/r	10.0.0.1:8080
Index: src/acl.c
===================================================================
RCS file: /usr/local/cvs/oops/src/acl.c,v
retrieving revision 1.34
retrieving revision 1.35
diff -c -r1.34 -r1.35
*** acl.c	2001/12/04 08:43:36	1.34
--- acl.c	2002/07/30 08:05:55	1.35
***************
*** 474,479 ****
--- 474,481 ----
  	return(ACL_USERCHARSET);
      if ( !strcasecmp(type, "src_ip") )
  	return(ACL_SRC_IP);
+     if ( !strcasecmp(type, "dst_ip") )
+ 	return(ACL_DST_IP);
      if ( !strcasecmp(type, "method") )
  	return(ACL_METHOD);
      if ( !strcasecmp(type, "port") )
***************
*** 528,533 ****
--- 530,536 ----
  case ACL_USERCHARSET:
  	/* nothing was allocated in structure	*/
  	break;
+ case ACL_DST_IP:
  case ACL_SRC_IP:
  	{
  	struct	acl_ip_data *acl_ip_data = (struct  acl_ip_data*)acl->data;
***************
*** 881,886 ****
--- 884,891 ----
  	}
  	if ( must_free_data ) free(data);
  	return(0);
+ case ACL_DST_IP:
+         dst_ip_acl_present = TRUE;
  case ACL_SRC_IP:
  	/* IP IP IP					*/
  	/* IP in format a.b.c.d or a.b.c/l		*/
***************
*** 889,895 ****
  	  struct cidr_net	*networks = NULL, *last = NULL;
  	  int			networks_num = 0;
  
! 	    verb_printf("SRC_IP: %s\n", data);
  	    t = data;
  	    while ( (p = (char*)strtok_r(t, "\t \n", &tptr)) != 0 ) {
  	      char		*slash = NULL, masklen, *tt, *pp, *ttptr;
--- 894,900 ----
  	  struct cidr_net	*networks = NULL, *last = NULL;
  	  int			networks_num = 0;
  
! 	    verb_printf("SRC/DST_IP: %s\n", data);
  	    t = data;
  	    while ( (p = (char*)strtok_r(t, "\t \n", &tptr)) != 0 ) {
  	      char		*slash = NULL, masklen, *tt, *pp, *ttptr;
***************
*** 1075,1080 ****
--- 1080,1104 ----
  	    return( !strcmp(agent_cs->Name, ucsd->name) );
  	}
  	break;
+ case ACL_DST_IP:
+ 	{
+ 	struct acl_ip_data *acl_ip_data = (struct acl_ip_data *)acl->data;
+ 	struct  cidr_net   *net;
+ 	int		   i;
+ 	struct	in_addr	   *addr = &(rq->dst_sa.sin_addr);
+ 
+ 	    if ( !acl_ip_data ) break;
+ 	    if (  (acl_ip_data->num<=0) 
+ 	       || !acl_ip_data->sorted
+ 	       || !acl_ip_data->unsorted ) break;
+ 
+ 	    for(i=0;i<acl_ip_data->num;i++) {
+ 		net = acl_ip_data->sorted[i];
+ 		if ( (net->network & net->mask) ==
+ 		     (ntohl(addr->s_addr) & net->mask) ) return(TRUE);
+ 	    }
+ 	}
+         break;
  
  case ACL_SRC_IP:
  	{
***************
*** 1564,1570 ****
  	    new->acl = acl;
  	    new->sign = sign;
  	} else {
! 	    verb_printf("parse_networks_acl(): Unknown acl `%s' or bad type (only src_ip allowed).\n", p);
  	    goto error;
  	}
  	string_list = string_list->next;
--- 1588,1594 ----
  	    new->acl = acl;
  	    new->sign = sign;
  	} else {
! 	    verb_printf("parse_networks_acl(): Unknown acl `%s' or bad type (only src_ip/dst_ip allowed).\n", p);
  	    goto error;
  	}
  	string_list = string_list->next;
Index: src/config.h.in
===================================================================
RCS file: /usr/local/cvs/oops/src/config.h.in,v
retrieving revision 1.70
diff -c -r1.70 config.h.in
*** config.h.in	2001/12/19 12:22:35	1.70
--- config.h.in	2003/01/21 07:40:05
***************
*** 1,4 ****
--- 1,15 ----
  /* src/config.h.in.  Generated automatically from configure.in by autoheader.  */
+ 
+ /* Define if on AIX 3.
+    System headers sometimes define this.
+    We just want to avoid a redefinition error message.  */
+ #ifndef _ALL_SOURCE
+ #undef _ALL_SOURCE
+ #endif
+ 
+ /* Define as __inline if that's what the C compiler calls it.  */
+ #undef inline
+ 
  #undef OOPS_HOME
  #undef OOPS_CFG
  #undef OOPS_CC
***************
*** 45,160 ****
  #undef HAVE_UINT32_T
  #undef HAVE__GMTOFF__
  
! /* Define if you have the `atoll' function. */
  #undef HAVE_ATOLL
  
! /* Define if you have the `bzero' function. */
  #undef HAVE_BZERO
  
! /* Define if you have the `chroot' function. */
  #undef HAVE_CHROOT
- 
- /* Define if you have the <crypt.h> header file. */
- #undef HAVE_CRYPT_H
  
! /* Define if you have the `ctime_r' function. */
  #undef HAVE_CTIME_R
  
! /* Define if you have the `daemon' function. */
  #undef HAVE_DAEMON
  
! /* Define if you have the `directio' function. */
  #undef HAVE_DIRECTIO
  
! /* Define if you have the `getdomainname' function. */
  #undef HAVE_GETDOMAINNAME
  
! /* Define if you have the `gethostbyname_r' function. */
  #undef HAVE_GETHOSTBYNAME_R
- 
- /* Define if you have the <getopt.h> header file. */
- #undef HAVE_GETOPT_H
  
! /* Define if you have the `getrlimit' function. */
  #undef HAVE_GETRLIMIT
  
! /* Define if you have the `getrusage' function. */
  #undef HAVE_GETRUSAGE
  
! /* Define if you have the `gmtime_r' function. */
  #undef HAVE_GMTIME_R
  
! /* Define if you have the `pam' library (-lpam). */
! #undef HAVE_LIBPAM
! 
! /* Define if you have the `tnfprobe' library (-ltnfprobe). */
! #undef HAVE_LIBTNFPROBE
! 
! /* Define if you have the `localtime_r' function. */
  #undef HAVE_LOCALTIME_R
- 
- /* Define if you have the <netinet/ip6.h> header file. */
- #undef HAVE_NETINET_IP6_H
  
! /* Define if you have the <netinet/ip_fil.h> header file. */
! #undef HAVE_NETINET_IP_FIL_H
! 
! /* Define if you have the `poll' function. */
  #undef HAVE_POLL
  
! /* Define if you have the `pread' function. */
  #undef HAVE_PREAD
- 
- /* Define if you have the <pthread.h> header file. */
- #undef HAVE_PTHREAD_H
  
! /* Define if you have the `pwrite' function. */
  #undef HAVE_PWRITE
  
! /* Define if you have the `setegid' function. */
  #undef HAVE_SETEGID
  
! /* Define if you have the `setrlimit' function. */
  #undef HAVE_SETRLIMIT
  
! /* Define if you have the `snprintf' function. */
  #undef HAVE_SNPRINTF
- 
- /* Define if you have the <stdlib.h> header file. */
- #undef HAVE_STDLIB_H
  
! /* Define if you have the `strcasestr' function. */
  #undef HAVE_STRCASESTR
  
! /* Define if you have the `strerror_r' function. */
  #undef HAVE_STRERROR_R
  
! /* Define if you have the <strings.h> header file. */
! #undef HAVE_STRINGS_H
  
! /* Define if you have the <string.h> header file. */
  #undef HAVE_STRING_H
  
! /* Define if you have the `strtoll' function. */
! #undef HAVE_STRTOLL
  
! /* Define if you have the <sys/inttypes.h> header file. */
  #undef HAVE_SYS_INTTYPES_H
  
! /* Define if you have the <unistd.h> header file. */
  #undef HAVE_UNISTD_H
  
! /* Define if `lex' declares `yytext' as a `char *' by default, not a `char[]'.
!    */
! #undef YYTEXT_POINTER
! 
! /* Define if on AIX 3.
!    System headers sometimes define this.
!    We just want to avoid a redefinition error message.  */
! #ifndef _ALL_SOURCE
! # undef _ALL_SOURCE
! #endif
  
! /* Define as `__inline' if that's what the C compiler calls it, or to nothing
!    if it is not supported. */
! #undef inline
--- 56,156 ----
  #undef HAVE_UINT32_T
  #undef HAVE__GMTOFF__
  
! /* Define if you have the atoll function.  */
  #undef HAVE_ATOLL
  
! /* Define if you have the bzero function.  */
  #undef HAVE_BZERO
  
! /* Define if you have the chroot function.  */
  #undef HAVE_CHROOT
  
! /* Define if you have the ctime_r function.  */
  #undef HAVE_CTIME_R
  
! /* Define if you have the daemon function.  */
  #undef HAVE_DAEMON
  
! /* Define if you have the directio function.  */
  #undef HAVE_DIRECTIO
  
! /* Define if you have the getdomainname function.  */
  #undef HAVE_GETDOMAINNAME
  
! /* Define if you have the gethostbyname_r function.  */
  #undef HAVE_GETHOSTBYNAME_R
  
! /* Define if you have the getrlimit function.  */
  #undef HAVE_GETRLIMIT
  
! /* Define if you have the getrusage function.  */
  #undef HAVE_GETRUSAGE
  
! /* Define if you have the gmtime_r function.  */
  #undef HAVE_GMTIME_R
  
! /* Define if you have the localtime_r function.  */
  #undef HAVE_LOCALTIME_R
  
! /* Define if you have the poll function.  */
  #undef HAVE_POLL
  
! /* Define if you have the pread function.  */
  #undef HAVE_PREAD
  
! /* Define if you have the pwrite function.  */
  #undef HAVE_PWRITE
  
! /* Define if you have the setegid function.  */
  #undef HAVE_SETEGID
  
! /* Define if you have the setrlimit function.  */
  #undef HAVE_SETRLIMIT
  
! /* Define if you have the snprintf function.  */
  #undef HAVE_SNPRINTF
  
! /* Define if you have the strcasestr function.  */
  #undef HAVE_STRCASESTR
  
! /* Define if you have the strerror_r function.  */
  #undef HAVE_STRERROR_R
  
! /* Define if you have the strtoll function.  */
! #undef HAVE_STRTOLL
! 
! /* Define if you have the <crypt.h> header file.  */
! #undef HAVE_CRYPT_H
  
! /* Define if you have the <getopt.h> header file.  */
! #undef HAVE_GETOPT_H
! 
! /* Define if you have the <netinet/ip6.h> header file.  */
! #undef HAVE_NETINET_IP6_H
! 
! /* Define if you have the <netinet/ip_fil.h> header file.  */
! #undef HAVE_NETINET_IP_FIL_H
! 
! /* Define if you have the <pthread.h> header file.  */
! #undef HAVE_PTHREAD_H
! 
! /* Define if you have the <stdlib.h> header file.  */
! #undef HAVE_STDLIB_H
! 
! /* Define if you have the <string.h> header file.  */
  #undef HAVE_STRING_H
  
! /* Define if you have the <strings.h> header file.  */
! #undef HAVE_STRINGS_H
  
! /* Define if you have the <sys/inttypes.h> header file.  */
  #undef HAVE_SYS_INTTYPES_H
  
! /* Define if you have the <unistd.h> header file.  */
  #undef HAVE_UNISTD_H
  
! /* Define if you have the pam library (-lpam).  */
! #undef HAVE_LIBPAM
  
! /* Define if you have the tnfprobe library (-ltnfprobe).  */
! #undef HAVE_LIBTNFPROBE
Index: src/extern.h
===================================================================
RCS file: /usr/local/cvs/oops/src/extern.h,v
retrieving revision 1.67
retrieving revision 1.70
diff -c -r1.67 -r1.70
*** extern.h	2002/01/23 19:29:01	1.67
--- extern.h	2002/09/11 19:01:27	1.70
***************
*** 37,42 ****
--- 37,43 ----
  extern int		accesslog_num, accesslog_size;
  extern int		log_num, log_size;
  extern unsigned int	maxresident;
+ extern unsigned int	minresident;
  extern int		icp_so;
  extern int		server_so;
  extern int		peer_down_interval;
***************
*** 139,144 ****
--- 140,146 ----
  extern int          dont_cache_without_last_modified;
  extern int          storages_ready;
  extern int          fetch_with_client_speed;
+ extern int          dst_ip_acl_present;
  #endif		/* !defined(OOPS_MAIN) */
  
  extern	struct	cidr_net **sort_n(struct cidr_net*, int*);
***************
*** 263,269 ****
  extern	int		add_socket_to_listen_list(int, u_short, struct in_addr*, int, void* (*f)(void*));
  extern	char		daybit(char*);
  extern	int		denytime_check(struct denytime*);
! extern	int             send_data_from_buff_no_wait(int, struct buff **, int *, unsigned int *, int*, int, struct mem_obj*, char*, struct request *);
  extern	void		update_transfer_rate(struct request*, int size);
  extern	int		traffic_load(struct request *rq);
  extern	char		*format_av_pair(char*, char*);
--- 265,271 ----
  extern	int		add_socket_to_listen_list(int, u_short, struct in_addr*, int, void* (*f)(void*));
  extern	char		daybit(char*);
  extern	int		denytime_check(struct denytime*);
! extern	int             send_data_from_buff_no_wait(int, int, struct buff **, int *, unsigned int *, int*, int, struct mem_obj*, char*, struct request *);
  extern	void		update_transfer_rate(struct request*, int size);
  extern	int		traffic_load(struct request *rq);
  extern	char		*format_av_pair(char*, char*);
Index: src/ftp_utils.c
===================================================================
RCS file: /usr/local/cvs/oops/src/ftp_utils.c,v
retrieving revision 1.31
retrieving revision 1.32
diff -c -r1.31 -r1.32
*** ftp_utils.c	2001/05/23 11:52:40	1.31
--- ftp_utils.c	2002/03/16 15:39:59	1.32
***************
*** 354,360 ****
  	my_xlog(OOPS_LOG_FTP|OOPS_LOG_DBG, "recv_ftp_data(): receiving data.\n");
  
      ftp_r->file_dir = FTP_TYPE_FILE;
!     if ( !ftp_r->size || (ftp_r->size >= maxresident) )
      		SET(obj->flags, FLAG_DEAD);
      if ( ftp_r->mode == MODE_PORT ) {
  	sa_len = sizeof(sa);
--- 354,360 ----
  	my_xlog(OOPS_LOG_FTP|OOPS_LOG_DBG, "recv_ftp_data(): receiving data.\n");
  
      ftp_r->file_dir = FTP_TYPE_FILE;
!     if ( !ftp_r->size || (ftp_r->size >= maxresident) || (ftp_r->size < minresident) )
      		SET(obj->flags, FLAG_DEAD);
      if ( ftp_r->mode == MODE_PORT ) {
  	sa_len = sizeof(sa);
Index: src/garbage_c.c
===================================================================
RCS file: /usr/local/cvs/oops/src/garbage_c.c,v
retrieving revision 1.43
retrieving revision 1.45
diff -c -r1.43 -r1.45
*** garbage_c.c	2001/12/19 12:15:41	1.43
--- garbage_c.c	2002/07/25 14:45:26	1.45
***************
*** 71,95 ****
  	pthread_mutex_unlock(&flush_mem_cache_lock);
  	return;
      }
!     my_xlog(OOPS_LOG_CACHE, "flush_mem_chache(): total_size: %dMB.\n", total_size/1024/1024);
      if ( total_size < lo_mark_val ) {
  	pthread_mutex_unlock(&flush_mem_cache_lock);
!         my_xlog(OOPS_LOG_CACHE, "flush_mem_chache(): total_size < lo_mark.\n", total_size);
  	return;
      }
      if ( total_size > mem_max_val ) {
  	gc_mode = GC_DROP ;
! 	my_xlog(OOPS_LOG_CACHE, "flush_mem_chache(): DROPout documents.\n");
      } else {
  	gc_mode = GC_EASY ;
! 	my_xlog(OOPS_LOG_CACHE, "flush_mem_chache(): SWAPout documents.\n");
      }
      /* create kill-list */
      kill_size = total_size - lo_mark_val;
      kill_size += (lo_mark_val*swap_advance)/100;
      current_swap_size = kill_size;
      if ( kill_size > total_size ) kill_size = total_size;
!     my_xlog(OOPS_LOG_CACHE, "flush_mem_chache(): kill_size=%dMB\n", kill_size/1024/1024);
      destroyed = 0;
      hash_index = last_index;
      do {
--- 71,95 ----
  	pthread_mutex_unlock(&flush_mem_cache_lock);
  	return;
      }
!     my_xlog(OOPS_LOG_CACHE, "flush_mem_cache(): total_size: %dMB.\n", total_size/1024/1024);
      if ( total_size < lo_mark_val ) {
  	pthread_mutex_unlock(&flush_mem_cache_lock);
!         my_xlog(OOPS_LOG_CACHE, "flush_mem_cache(): total_size < lo_mark.\n", total_size);
  	return;
      }
      if ( total_size > mem_max_val ) {
  	gc_mode = GC_DROP ;
! 	my_xlog(OOPS_LOG_CACHE, "flush_mem_cache(): DROPout documents.\n");
      } else {
  	gc_mode = GC_EASY ;
! 	my_xlog(OOPS_LOG_CACHE, "flush_mem_cache(): SWAPout documents.\n");
      }
      /* create kill-list */
      kill_size = total_size - lo_mark_val;
      kill_size += (lo_mark_val*swap_advance)/100;
      current_swap_size = kill_size;
      if ( kill_size > total_size ) kill_size = total_size;
!     my_xlog(OOPS_LOG_CACHE, "flush_mem_cache(): kill_size=%dMB\n", kill_size/1024/1024);
      destroyed = 0;
      hash_index = last_index;
      do {
***************
*** 127,133 ****
          pthread_mutex_unlock(&hash_table[hash_index].lock);
      last_index = hash_index;
      pthread_mutex_unlock(&flush_mem_cache_lock); 
!     my_xlog(OOPS_LOG_CACHE, "flush_mem_chache(): %d documents in kill list.\n", kill_list.count);
      if ( kill_list.count > 0 ) {
  	my_xlog(OOPS_LOG_DBG, "flush_mem_cache(): Will swap/destroy %d objects.\n", kill_list.count);
  	RDLOCK_CONFIG ;
--- 127,133 ----
          pthread_mutex_unlock(&hash_table[hash_index].lock);
      last_index = hash_index;
      pthread_mutex_unlock(&flush_mem_cache_lock); 
!     my_xlog(OOPS_LOG_CACHE, "flush_mem_cache(): %d documents in kill list.\n", kill_list.count);
      if ( kill_list.count > 0 ) {
  	my_xlog(OOPS_LOG_DBG, "flush_mem_cache(): Will swap/destroy %d objects.\n", kill_list.count);
  	RDLOCK_CONFIG ;
***************
*** 185,204 ****
      }
      UNLOCK_CONFIG ;
      total_size += current_swap_size;
!     my_xlog(OOPS_LOG_CACHE, "drop_mem_chache() : total_size: %dMB, current_swap_size: %dMB.\n", total_size/1024/1024, 
      		current_swap_size/1024/1024);
      if ( total_size > mem_max_val ) {
  	gc_mode = GC_DROP ;
! 	my_xlog(OOPS_LOG_CACHE, "drop_mem_chache() : DROPout documents.\n");
      } else {
! 	my_xlog(OOPS_LOG_CACHE, "drop_mem_chache() : no need.\n");
  	pthread_mutex_unlock(&flush_mem_cache_lock);
  	return;
      }
      /* create kill-list */
      kill_size = total_size - lo_mark_val;
      if ( kill_size > total_size ) kill_size = total_size;
!     my_xlog(OOPS_LOG_CACHE, "drop_mem_chache() : kill_size=%dMB\n", kill_size/1024/1024);
      destroyed = 0;
      hash_index = last_index;
      do {
--- 185,204 ----
      }
      UNLOCK_CONFIG ;
      total_size += current_swap_size;
!     my_xlog(OOPS_LOG_CACHE, "drop_mem_cache() : total_size: %dMB, current_swap_size: %dMB.\n", total_size/1024/1024, 
      		current_swap_size/1024/1024);
      if ( total_size > mem_max_val ) {
  	gc_mode = GC_DROP ;
! 	my_xlog(OOPS_LOG_CACHE, "drop_mem_cache() : DROPout documents.\n");
      } else {
! 	my_xlog(OOPS_LOG_CACHE, "drop_mem_cache() : no need.\n");
  	pthread_mutex_unlock(&flush_mem_cache_lock);
  	return;
      }
      /* create kill-list */
      kill_size = total_size - lo_mark_val;
      if ( kill_size > total_size ) kill_size = total_size;
!     my_xlog(OOPS_LOG_CACHE, "drop_mem_cache() : kill_size=%dMB\n", kill_size/1024/1024);
      destroyed = 0;
      hash_index = last_index;
      do {
***************
*** 237,243 ****
      last_index = hash_index;
      pthread_mutex_unlock(&flush_mem_cache_lock);
  
!     my_xlog(OOPS_LOG_CACHE, "drop_mem_chache() : %d documents in kill list.\n", kill_list.count);
      if ( kill_list.count > 0 ) {
  	my_xlog(OOPS_LOG_DBG, "drop_mem_cache() : Will destroy %d objects.\n", kill_list.count);
  	while ( (obj = list_dequeue(&kill_list)) != 0 ) {
--- 237,243 ----
      last_index = hash_index;
      pthread_mutex_unlock(&flush_mem_cache_lock);
  
!     my_xlog(OOPS_LOG_CACHE, "drop_mem_cache() : %d documents in kill list.\n", kill_list.count);
      if ( kill_list.count > 0 ) {
  	my_xlog(OOPS_LOG_DBG, "drop_mem_cache() : Will destroy %d objects.\n", kill_list.count);
  	while ( (obj = list_dequeue(&kill_list)) != 0 ) {
***************
*** 276,284 ****
  
      my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "Garbage collector started.\n");
  
!     Log = open("/var/tmp/Log", O_RDWR|O_CREAT|O_APPEND, 0660);
      if ( Log == -1 ) perror("Log");
      printf("Log = %d\n", Log);
      for(i=0;i<HASH_SIZE;i++) hash_ptr[i] = h++;
  
      forever() {
--- 276,285 ----
  
      my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "Garbage collector started.\n");
  
! /*    Log = open("/var/tmp/Log", O_RDWR|O_CREAT|O_APPEND, 0660);
      if ( Log == -1 ) perror("Log");
      printf("Log = %d\n", Log);
+ */
      for(i=0;i<HASH_SIZE;i++) hash_ptr[i] = h++;
  
      forever() {
Index: src/http_utils.c
===================================================================
RCS file: /usr/local/cvs/oops/src/http_utils.c,v
retrieving revision 1.68
retrieving revision 1.82
diff -c -r1.68 -r1.82
*** http_utils.c	2002/01/23 19:29:01	1.68
--- http_utils.c	2002/12/24 08:02:59	1.82
***************
*** 421,427 ****
  #define			ROLE_WRITER	2
  #define			ROLE_VALIDATOR	3
  int			role, no_more_logs = FALSE, source_type;
! char			*origin;
  struct	sockaddr_in	peer_sa;
  hash_entry_t            *he = NULL;
  
--- 421,427 ----
  #define			ROLE_WRITER	2
  #define			ROLE_VALIDATOR	3
  int			role, no_more_logs = FALSE, source_type;
! char			origin[MAXHOSTNAMELEN], *source;
  struct	sockaddr_in	peer_sa;
  hash_entry_t            *he = NULL;
  
***************
*** 451,456 ****
--- 451,457 ----
      IF_STRDUP(rq->tag, tcp_tag);
      send_data_from_obj(rq, so, obj, flags);
      DECR_READERS(obj);
+     source_type = SOURCE_NONE;
      goto done;
  
  revalidate:
***************
*** 525,534 ****
  		/* wait for answers */
  		if ( !new_qe->status && pthread_cond_timedwait(&new_qe->icpr_cond,&new_qe->icpr_mutex,&ts) ) {
  		    /* failed */
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp timed out.\n");
  		} else {
  		    /* success */
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp success.\n");
  		}
  		new_qe->rq_n = 0;
  		pthread_mutex_unlock(&new_qe->icpr_mutex);
--- 526,535 ----
  		/* wait for answers */
  		if ( !new_qe->status && pthread_cond_timedwait(&new_qe->icpr_cond,&new_qe->icpr_mutex,&ts) ) {
  		    /* failed */
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp timed out: %s.\n", inet_ntoa(new_qe->peer_sa.sin_addr));
  		} else {
  		    /* success */
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp success: %s.\n", inet_ntoa(new_qe->peer_sa.sin_addr));
  		}
  		new_qe->rq_n = 0;
  		pthread_mutex_unlock(&new_qe->icpr_mutex);
***************
*** 538,544 ****
                          abort();
                  }
  		if ( new_qe->status ) {
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): Fetch from neighbour.\n");
  		    peer_sa = new_qe->peer_sa;
  		    source_type = new_qe->type;
  		    server_so = peer_connect_silent(so, &new_qe->peer_sa, rq);
--- 539,545 ----
                          abort();
                  }
  		if ( new_qe->status ) {
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): Fetch from neighbour: %s.\n", inet_ntoa(new_qe->peer_sa.sin_addr));
  		    peer_sa = new_qe->peer_sa;
  		    source_type = new_qe->type;
  		    server_so = peer_connect_silent(so, &new_qe->peer_sa, rq);
***************
*** 649,661 ****
  	else		    have_code = 555;
      if ( new_obj ) received = new_obj->size;
           else	   received =     obj->size;
-     if ( parent_port && !TEST(rq->flags, RQ_GO_DIRECT) )
-     		origin = parent_host;
- 	else
- 		origin = obj->url.host;
  
      if ( !no_more_logs ) {
! 	IF_STRDUP(rq->hierarchy, "NONE");
  	IF_STRDUP(rq->source, origin);
  	rq->code = have_code;
  	rq->received = received;
--- 650,710 ----
  	else		    have_code = 555;
      if ( new_obj ) received = new_obj->size;
           else	   received =     obj->size;
  
+     switch(source_type) {
+     struct peer *peer;
+ 
+     case SOURCE_NONE:
+         source = "NONE";
+ 	strncpy(origin, "-", sizeof(origin)-1);
+         break;        
+     case SOURCE_DIRECT:
+ 	source="DIRECT";
+ 	strncpy(origin, obj->url.host, sizeof(origin)-1);
+ 	origin[sizeof(origin)-1] = 0;
+ 	break;
+     case PEER_PARENT:
+ 	source="PARENT";
+ 	if ( parent_port ) {
+ 	    RDLOCK_CONFIG ;
+ 	    strncpy(origin, parent_host, sizeof(origin)-1);
+ 	    origin[sizeof(origin)-1] = 0;
+ 	    IF_FREE(rq->peer_auth); rq->peer_auth = NULL;
+ 	    if ( parent_auth ) rq->peer_auth = strdup(parent_auth);
+ 	    UNLOCK_CONFIG ;
+ 	} else {
+ 	    RDLOCK_CONFIG ;
+ 	    peer = peer_by_http_addr(&peer_sa);
+ 	    if ( peer ) {
+ 		if ( peer->name )
+ 		    strncpy(origin, peer->name, sizeof(origin)-1);
+ 		else
+ 		    strncpy(origin, "unknown_peer", sizeof(origin)-1);
+ 		origin[sizeof(origin)-1] = 0;
+ 	    }
+ 	    UNLOCK_CONFIG ;
+ 	}
+ 	break;
+     case PEER_SIBLING:
+ 	source="SIBLING";
+ 	RDLOCK_CONFIG ;
+ 	peer = peer_by_http_addr(&peer_sa);
+ 	if ( peer ) {
+ 	    if ( peer->name )
+ 		strncpy(origin, peer->name, sizeof(origin)-1);
+ 	    else
+ 		strncpy(origin, "unknown_peer", sizeof(origin)-1);
+ 	    origin[sizeof(origin)-1] = 0;
+ 	}
+ 	UNLOCK_CONFIG ;
+ 	break;
+     default:
+ 	source="UNKNOWN";
+ 	strncpy(origin, "UNKNOWN", sizeof(origin));
+ 	break;
+     }
      if ( !no_more_logs ) {
! 	IF_STRDUP(rq->hierarchy, source);
  	IF_STRDUP(rq->source, origin);
  	rq->code = have_code;
  	rq->received = received;
***************
*** 677,683 ****
  char		convert_from_chunked = FALSE, downgrade_minor = FALSE;
  char		ungzip = FALSE;
  int		convert_charset = FALSE;
! int		partial_content = FALSE;
  int		rest_in_chunk = 0, content_length_sent = 0, downgrade_flags;
  char		*table = NULL;
  int		osize =  0;
--- 726,732 ----
  char		convert_from_chunked = FALSE, downgrade_minor = FALSE;
  char		ungzip = FALSE;
  int		convert_charset = FALSE;
! int		partial_content = FALSE, part_length = -1;
  int		rest_in_chunk = 0, content_length_sent = 0, downgrade_flags;
  char		*table = NULL;
  int		osize =  0;
***************
*** 703,722 ****
  go_again:
      lock_obj_state(obj);
      forever() {
  	state = obj->state;
  	switch(state) {
  	  case OBJ_READY:
  	    unlock_obj_state(obj);
  	    goto send_ready;
  	  case OBJ_EMPTY:
! 	    pthread_cond_wait(&obj->state_cond, &obj->state_lock);
  	    continue;
  	  case OBJ_INPROGR:
  	    if ( sended < obj->size ) {
  		unlock_obj_state(obj);
  		goto send_ready;
  	    }
! 	    pthread_cond_wait(&obj->state_cond, &obj->state_lock);
  	    continue;
  	}
      }
--- 752,788 ----
  go_again:
      lock_obj_state(obj);
      forever() {
+ 	int			rc;
+ 	struct	timespec	ts;
+ 
  	state = obj->state;
  	switch(state) {
  	  case OBJ_READY:
  	    unlock_obj_state(obj);
  	    goto send_ready;
  	  case OBJ_EMPTY:
! 	    ts.tv_sec = global_sec_timer + READ_ANSW_TIMEOUT;
!             ts.tv_nsec = 0;
! 	    rc = pthread_cond_timedwait(&obj->state_cond, &obj->state_lock, &ts);
!             if ( rc ) {
!                 my_xlog(OOPS_LOG_SEVERE, "send_data_from_obj(): cond_timedwait: %d in state %d\n", rc, state);
!                 unlock_obj_state(obj);
!                 return;
!             }
  	    continue;
  	  case OBJ_INPROGR:
  	    if ( sended < obj->size ) {
  		unlock_obj_state(obj);
  		goto send_ready;
  	    }
! 	    ts.tv_sec = global_sec_timer + READ_ANSW_TIMEOUT;
!             ts.tv_nsec = 0;
! 	    rc = pthread_cond_timedwait(&obj->state_cond, &obj->state_lock, &ts);
!             if ( rc ) {
!                 my_xlog(OOPS_LOG_SEVERE, "send_data_from_obj(): cond_timedwait: %d in state %d\n", rc, state);
!                 unlock_obj_state(obj);
!                 return;
!             }
  	    continue;
  	}
      }
***************
*** 732,743 ****
  	/* we pay attention to 'Range:' iff
  	   1) object is ready (it is all here)
  	   2) doc have no chunked content
! 	   3) range is like 'nnn-'
  	 */
  	if ( TEST(rq->flags, RQ_HAVE_RANGE)
  	     &&  (obj->state == OBJ_READY)
  	     &&  !content_chunked(obj)
! 	     &&  ((rq->range_from >= 0) && (rq->range_to == -1))) {
  
  		struct buff *tb = NULL;
  		char	buff[80];
--- 798,810 ----
  	/* we pay attention to 'Range:' iff
  	   1) object is ready (it is all here)
  	   2) doc have no chunked content
! 	  -3) range is like 'nnn-'
  	 */
  	if ( TEST(rq->flags, RQ_HAVE_RANGE)
  	     &&  (obj->state == OBJ_READY)
  	     &&  !content_chunked(obj)
! 	     /*&&  ((rq->range_from >= 0) && (rq->range_to == -1))*/
! 	     ) {
  
  		struct buff *tb = NULL;
  		char	buff[80];
***************
*** 764,770 ****
  		    /* any valid document. So we simply ajust values	*/
  		    rq->range_from = osize;
  		}
! 		snprintf(buff, sizeof(buff)-1, "bytes %d-%d/%d", rq->range_from, osize, osize);
  		attach_av_pair_to_buff("Content-Range:", buff, hdrs_to_send);
  	} else {
  	    /* first must be "HTTP/1.x 200 ..." */
--- 831,843 ----
  		    /* any valid document. So we simply ajust values	*/
  		    rq->range_from = osize;
  		}
!                 if ( rq->range_to != -1 && rq->range_to < osize ) {
! 		    snprintf(buff, sizeof(buff)-1, "bytes %d-%d/%d",
! 		        rq->range_from, rq->range_to, osize);
!                     part_length = rq->range_to - rq->range_from + 1;
!                 } else
! 		    snprintf(buff, sizeof(buff)-1, "bytes %d-%d/%d",
! 		        rq->range_from, osize, osize);
  		attach_av_pair_to_buff("Content-Range:", buff, hdrs_to_send);
  	} else {
  	    /* first must be "HTTP/1.x 200 ..." */
***************
*** 836,842 ****
  	}
  	if ( !content_length_sent && partial_content ) {
  	    char clbuf[32];
! 	    snprintf(clbuf, sizeof(clbuf)-1,"%d", osize-rq->range_from);
  	    attach_av_pair_to_buff("Content-Length:", clbuf, hdrs_to_send);
  	    content_length_sent = TRUE;
  	}
--- 909,918 ----
  	}
  	if ( !content_length_sent && partial_content ) {
  	    char clbuf[32];
!             if ( part_length == -1 )
! 	        snprintf(clbuf, sizeof(clbuf)-1,"%d", osize-rq->range_from);
!               else
! 	        snprintf(clbuf, sizeof(clbuf)-1,"%d", part_length);
  	    attach_av_pair_to_buff("Content-Length:", clbuf, hdrs_to_send);
  	    content_length_sent = TRUE;
  	}
***************
*** 930,936 ****
  	sf |= RQ_CONVERT_FROM_CHUNKED;
      if ( IS_HUPED(&pollarg) )
  	goto done;
!     if ( (r = send_data_from_buff_no_wait(so, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 ) {
  	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "send_data_from_obj(): send_data_from_buff_no_wait(): Send error: %m\n");
  	goto done;
      }
--- 1006,1012 ----
  	sf |= RQ_CONVERT_FROM_CHUNKED;
      if ( IS_HUPED(&pollarg) )
  	goto done;
!     if ( (r = send_data_from_buff_no_wait(so, part_length, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 ) {
  	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "send_data_from_obj(): send_data_from_buff_no_wait(): Send error: %m\n");
  	goto done;
      }
***************
*** 946,951 ****
--- 1022,1031 ----
  		    obj->url.host, obj->url.path);
  	goto done;
      }
+     if ( part_length != -1 ) {
+         part_length -= sended-ssended;
+         if ( part_length < 0 ) goto done;
+     }
      if ( !r && convert_from_chunked && !rest_in_chunk ) {
  	/* we sent nothing... this can be because we convert from chunked
  	 * ans we have only part of chunk size value stored in buff. like this:
***************
*** 1121,1136 ****
  		new_obj->times = answer_stat.times;
  
  		if ( new_obj->status_code == STATUS_NOT_MODIFIED ) {
  		    SET(new_obj->flags, FLAG_DEAD);
  		    leave_obj(new_obj);
  		    new_obj = NULL;
  		    goto validate_done;
  		}
  
  		if ( (new_obj->status_code == STATUS_GATEWAY_TIMEOUT) 
! 		        || (new_obj->status_code == STATUS_FORBIDEN) )
  		    goto validate_done;
! 
  		if ( !new_obj->times.date ) new_obj->times.date = time(NULL);
  		check_new_object_expiration(rq, new_obj);
  		if ( new_obj->status_code == STATUS_OK ) {
--- 1201,1250 ----
  		new_obj->times = answer_stat.times;
  
  		if ( new_obj->status_code == STATUS_NOT_MODIFIED ) {
+                     struct av *header;
+                     /*
+                      * copy end-to-end info from new_obj to old obj
+                      */
+                     obj->times = new_obj->times;
+                     obj->response_time = global_sec_timer;
+                     obj->request_time = new_obj->request_time;
+                     header = obj->headers->next;
+                     while ( header ) {
+                         if ( is_attr(header, "Date:") ) {
+                             char *new_val = attr_value(new_obj->headers->next, header->attr);
+                             if ( new_val ) {
+                                 IF_FREE(header->val);
+                                 header->val = strdup(new_val);
+                             }
+                         } else
+                         if ( is_attr(header, "Age:") ) {
+                             char *new_val = attr_value(new_obj->headers->next, header->attr);
+                             if ( new_val ) {
+                                 IF_FREE(header->val);
+                                 header->val = strdup(new_val);
+                             }
+                         } else
+                         if ( is_attr(header, "Last-Modified:") ) {
+                             char *new_val = attr_value(new_obj->headers->next, header->attr);
+                             if ( new_val ) {
+                                 IF_FREE(header->val);
+                                 header->val = strdup(new_val);
+                             }
+                         }
+                         header = header->next;
+                     }
  		    SET(new_obj->flags, FLAG_DEAD);
  		    leave_obj(new_obj);
  		    new_obj = NULL;
+ 		    check_new_object_expiration(rq, obj);
  		    goto validate_done;
  		}
  
  		if ( (new_obj->status_code == STATUS_GATEWAY_TIMEOUT) 
! 		        || (new_obj->status_code == STATUS_FORBIDEN) ) {
!                     SET(new_obj->flags, FLAG_DEAD);
  		    goto validate_done;
!                 }
  		if ( !new_obj->times.date ) new_obj->times.date = time(NULL);
  		check_new_object_expiration(rq, new_obj);
  		if ( new_obj->status_code == STATUS_OK ) {
***************
*** 1189,1194 ****
--- 1303,1310 ----
  hash_entry_t            *he = NULL;
  ERRBUF ;
  
+     obj->response_time	= time(NULL);
+ 
      if ( rq->meth == METH_GET ) meth="GET";
      else if ( rq->meth == METH_PUT ) meth="PUT";
      else if ( rq->meth == METH_POST ) meth="POST";
***************
*** 1237,1246 ****
  	    /* wait for answers */
  	    if ( !new_qe->status && pthread_cond_timedwait(&new_qe->icpr_cond,&new_qe->icpr_mutex,&ts) ) {
  		/* failed */
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp timed out.\n");
  	    } else {
  		/* success */
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp success.\n");
  	    }
  	    new_qe->rq_n = 0;
  	    pthread_mutex_unlock(&new_qe->icpr_mutex);
--- 1353,1362 ----
  	    /* wait for answers */
  	    if ( !new_qe->status && pthread_cond_timedwait(&new_qe->icpr_cond,&new_qe->icpr_mutex,&ts) ) {
  		/* failed */
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp timed out: %s.\n", inet_ntoa(new_qe->peer_sa.sin_addr));
  	    } else {
  		/* success */
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): icp success: %s.\n", inet_ntoa(new_qe->peer_sa.sin_addr));
  	    }
  	    new_qe->rq_n = 0;
  	    pthread_mutex_unlock(&new_qe->icpr_mutex);
***************
*** 1250,1256 ****
                      abort();
              }
  	    if ( new_qe->status ) {
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): Fetch from neighbour.\n");
  		peer_sa = new_qe->peer_sa;
  		source_type = new_qe->type;
  		server_so = peer_connect(so, &new_qe->peer_sa, rq);
--- 1366,1372 ----
                      abort();
              }
  	    if ( new_qe->status ) {
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): Fetch from neighbour: %s.\n", inet_ntoa(new_qe->peer_sa.sin_addr));
  		peer_sa = new_qe->peer_sa;
  		source_type = new_qe->type;
  		server_so = peer_connect(so, &new_qe->peer_sa, rq);
***************
*** 1510,1516 ****
  		so = -1;
  		goto client_so_closed;
  	    }
! 	    if ( (rc = send_data_from_buff_no_wait(so, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 )
  		so = -1;
  	    if ( rest_in_chunk == -1 ) { /* was last chunk */
  		obj->state = OBJ_READY;
--- 1626,1632 ----
  		so = -1;
  		goto client_so_closed;
  	    }
! 	    if ( (rc = send_data_from_buff_no_wait(so, -1, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 )
  		so = -1;
  	    if ( rest_in_chunk == -1 ) { /* was last chunk */
  		obj->state = OBJ_READY;
***************
*** 1645,1651 ****
  		if ( IS_HUPED(&pollarg) )
  		    goto done;
  		ssended = sended;
! 		if ( (rc = send_data_from_buff_no_wait(so, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 )
  		    so = -1;
  		if ( ssended == sended )
  			goto done;
--- 1761,1767 ----
  		if ( IS_HUPED(&pollarg) )
  		    goto done;
  		ssended = sended;
! 		if ( (rc = send_data_from_buff_no_wait(so, -1, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 )
  		    so = -1;
  		if ( ssended == sended )
  			goto done;
***************
*** 1913,1920 ****
      if ( !obj->content_length && !content_chunked(obj) )
  	/* we don't know size */
      obj->flags |= FLAG_DEAD;
!     /* if object too large remove it right now */
!     if ( resident_size > maxresident ) {
  	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): Obj is too large - remove it.\n");
  	obj->flags |= FLAG_DEAD;
      } else {
--- 2029,2036 ----
      if ( !obj->content_length && !content_chunked(obj) )
  	/* we don't know size */
      obj->flags |= FLAG_DEAD;
!     /* if object too large (or small) remove it right now */
!     if ( (resident_size > maxresident) || (resident_size<minresident) ) {
  	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "fill_mem_obj(): Obj is too large - remove it.\n");
  	obj->flags |= FLAG_DEAD;
      } else {
***************
*** 2156,2162 ****
  		goto are_we_alone;
  	    }
  	    ssended = sended;
! 	    if ( (rc = send_data_from_buff_no_wait(so, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 ) {
  		so = -1;
  		goto are_we_alone;
  	    }
--- 2272,2278 ----
  		goto are_we_alone;
  	    }
  	    ssended = sended;
! 	    if ( (rc = send_data_from_buff_no_wait(so, -1, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 ) {
  		so = -1;
  		goto are_we_alone;
  	    }
***************
*** 2257,2263 ****
  		if ( IS_HUPED(&pollarg) )
  		    goto done;
  		ssended = sended;
! 		if ( (rc = send_data_from_buff_no_wait(so, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 )
  		    so = -1;
  		if ( ssended == sended )
  		    goto done;
--- 2373,2379 ----
  		if ( IS_HUPED(&pollarg) )
  		    goto done;
  		ssended = sended;
! 		if ( (rc = send_data_from_buff_no_wait(so, -1, &send_hot_buff, &send_hot_pos, &sended, &rest_in_chunk, sf, obj, table, rq)) != 0 )
  		    so = -1;
  		if ( ssended == sended )
  		    goto done;
***************
*** 2334,2339 ****
--- 2450,2457 ----
  
  /* send data from memory buffs
     so 		 - socket to client
+    lim           - send max lim bytes (for the partial contents)
+                    ignored if lim == -1
     hot		 - current buff
     pos		 - offset in buff data
     sended	 - address of 'sended' variable (updated in accordance with progress)
***************
*** 2343,2349 ****
     recode	 - recode table if we do charset conversion on the fly
  */
  int
! send_data_from_buff_no_wait(int so, struct buff **hot, int *pos, unsigned int *sended, int *rest_in_chunk, int flags, struct mem_obj *obj, char *table, struct request *rq)
  {
  int		r, to_send, cz_here, faked_sent, chunk_size, ss, sp;
  struct	buff	*b = *hot;
--- 2461,2467 ----
     recode	 - recode table if we do charset conversion on the fly
  */
  int
! send_data_from_buff_no_wait(int so, int lim, struct buff **hot, int *pos, unsigned int *sended, int *rest_in_chunk, int flags, struct mem_obj *obj, char *table, struct request *rq)
  {
  int		r, to_send, cz_here, faked_sent, chunk_size, ss, sp;
  struct	buff	*b = *hot;
***************
*** 2480,2485 ****
--- 2598,2604 ----
      }
  #endif
      to_send = b->used - *pos;
+     if ( lim != -1 ) to_send = MIN(to_send, lim);
      if ( !to_send ) {
  	if ( !b->next ) return(0);
  	*hot = b->next;
***************
*** 2575,2580 ****
--- 2694,2700 ----
      if ( r < 0 )
  	return(r);
      *pos += r; *sended += r;
+     if ( lim != -1 ) lim -= r;
      if ( r < to_send ) {/* it can't accept more data now */
  	return(0);
      }
***************
*** 2673,2679 ****
  	/* send from current position till the minimum(chunksize,b->used) */
  	to_send = MIN(b->used - *pos, (uint32_t)*rest_in_chunk);
  	if ( !to_send ) {
! 	    /* this canbe only end of buffer */
  	    if ( !b->next ) return(0);
  	    *hot = b->next;
  	    b = b->next;
--- 2793,2799 ----
  	/* send from current position till the minimum(chunksize,b->used) */
  	to_send = MIN(b->used - *pos, (uint32_t)*rest_in_chunk);
  	if ( !to_send ) {
! 	    /* this can be only end of buffer */
  	    if ( !b->next ) return(0);
  	    *hot = b->next;
  	    b = b->next;
***************
*** 3092,3098 ****
  struct	peer		*peer;
  ERRBUF ;
  
!     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "peer_connect(): Connecting to peer...\n");
      server_so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      if ( server_so == -1 ) {
  	say_bad_request(client_so, "Can't create socket", STRERROR_R(ERRNO, ERRBUFS),
--- 3212,3218 ----
  struct	peer		*peer;
  ERRBUF ;
  
!     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "peer_connect(): Connecting to peer: %s...\n", inet_ntoa(peer_sa->sin_addr));
      server_so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      if ( server_so == -1 ) {
  	say_bad_request(client_so, "Can't create socket", STRERROR_R(ERRNO, ERRBUFS),
***************
*** 3126,3132 ****
  int 			server_so = -1, r;
  struct	peer		*peer;
  
!     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "peer_connect_silent(): Connecting to peer...\n");
      server_so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      if ( server_so == -1 ) {
  	return(-1);
--- 3246,3252 ----
  int 			server_so = -1, r;
  struct	peer		*peer;
  
!     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "peer_connect_silent(): Connecting to peer: %s...\n", inet_ntoa(peer_sa->sin_addr));
      server_so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      if ( server_so == -1 ) {
  	return(-1);
***************
*** 3603,3614 ****
  	    }
  	    if ( expires_altered == TRUE )
  		SET(obj->flags, ANSW_EXPIRES_ALTERED);
! 	    if ( obj->times.expires < obj->times.date ) {
  		obj->flags |= ANSW_NO_STORE;
  	    }
  	}
  	else if ( obj->flags & ANSW_HAS_EXPIRES ) {
! 	    if ( obj->times.expires < obj->times.date ) {
  		obj->flags |= ANSW_NO_STORE;
  	    }
  	}
--- 3723,3734 ----
  	    }
  	    if ( expires_altered == TRUE )
  		SET(obj->flags, ANSW_EXPIRES_ALTERED);
! 	    if ( obj->times.expires <= obj->times.date ) {
  		obj->flags |= ANSW_NO_STORE;
  	    }
  	}
  	else if ( obj->flags & ANSW_HAS_EXPIRES ) {
! 	    if ( obj->times.expires <= obj->times.date ) {
  		obj->flags |= ANSW_NO_STORE;
  	    }
  	}
***************
*** 3879,3886 ****
  		a->flags |= ANSW_MUST_REVALIDATE;
  	if ( !strncasecmp(x, "proxy-revalidate", 15) )
  		a->flags |= ANSW_PROXY_REVALIDATE;
! 	if ( sscanf(x, "max-age = %d", (int*)&a->times.max_age) == 1 )
  		a->flags |= ANSW_HAS_MAX_AGE;
      }
      if ( !strncasecmp(p, "Connection: ", 12) ) {
  	char        *x;
--- 3999,4008 ----
  		a->flags |= ANSW_MUST_REVALIDATE;
  	if ( !strncasecmp(x, "proxy-revalidate", 15) )
  		a->flags |= ANSW_PROXY_REVALIDATE;
! 	if ( sscanf(x, "max-age = %d", (int*)&a->times.max_age) == 1 ) {
  		a->flags |= ANSW_HAS_MAX_AGE;
+ 		a->times.expires = a->times.date + a->times.max_age;
+         }
      }
      if ( !strncasecmp(p, "Connection: ", 12) ) {
  	char        *x;
***************
*** 3892,3898 ****
  	if ( !strncasecmp(x, "close", 5) )
  		a->flags &= ~ANSW_KEEP_ALIVE;
      }
!     if (    !TEST(a->flags, ANSW_HAS_EXPIRES) 
           && !strncasecmp(p, "Expires: ", 9) ) {
  	char        *x;
  	/* length */
--- 4014,4020 ----
  	if ( !strncasecmp(x, "close", 5) )
  		a->flags &= ~ANSW_KEEP_ALIVE;
      }
!     if (    !TEST(a->flags, ANSW_HAS_EXPIRES) && !TEST(a->flags, ANSW_HAS_MAX_AGE)
           && !strncasecmp(p, "Expires: ", 9) ) {
  	char        *x;
  	/* length */
***************
*** 4039,4045 ****
  	}
  	/* allocate data storage */
  	if ( a->content_len ) {
! 	    if ( a->content_len > maxresident ) {
  		/*
  		 -  This object will not be stored, we will receive it in
  		 -  small parts, in syncronous mode
--- 4161,4167 ----
  	}
  	/* allocate data storage */
  	if ( a->content_len ) {
! 	    if ( (a->content_len > maxresident) || (a->content_len < minresident) ) {
  		/*
  		 -  This object will not be stored, we will receive it in
  		 -  small parts, in syncronous mode
***************
*** 4110,4112 ****
--- 4232,4235 ----
      }
      return(0);
  }
+ 
Index: src/lib.c
===================================================================
RCS file: /usr/local/cvs/oops/src/lib.c,v
retrieving revision 1.106
retrieving revision 1.110
diff -c -r1.106 -r1.110
*** lib.c	2002/01/23 19:29:01	1.106
--- lib.c	2002/12/06 09:09:26	1.110
***************
*** 622,627 ****
--- 622,628 ----
  	if ( (flags & 0x8000) && (ah->id == qh->id) && (!(flags&0xf)) ) {
  	    if ( !ntohs(ah->ancount) ) {
  		my_xlog(OOPS_LOG_DNS|OOPS_LOG_DBG, "my_gethostbyname(): got 0 answers.\n");
+                 if (--resend_cnt) goto resend;
  		break;
  	    }
  	} else {
***************
*** 2136,2142 ****
      r = poll_descriptors(1, &pollarg, READ_ANSW_TIMEOUT*1000);
      if ( r <= 0 ) goto done;
      ssended = sended;
!     if ( send_data_from_buff_no_wait(so, &send_hot_buff, &send_hot_pos, &sended, NULL, 0, NULL, NULL, NULL) )
  	goto done;
      if ( rq->flags & RQ_HAS_BANDWIDTH) update_transfer_rate(rq, sended-ssended);
      if ( sended >= obj->body->used )
--- 2137,2143 ----
      r = poll_descriptors(1, &pollarg, READ_ANSW_TIMEOUT*1000);
      if ( r <= 0 ) goto done;
      ssended = sended;
!     if ( send_data_from_buff_no_wait(so, -1, &send_hot_buff, &send_hot_pos, &sended, NULL, 0, NULL, NULL, NULL) )
  	goto done;
      if ( rq->flags & RQ_HAS_BANDWIDTH) update_transfer_rate(rq, sended-ssended);
      if ( sended >= obj->body->used )
Index: src/modules.c
===================================================================
RCS file: /usr/local/cvs/oops/src/modules.c,v
retrieving revision 1.37
retrieving revision 1.40
diff -c -r1.37 -r1.40
*** modules.c	2001/12/28 14:06:56	1.37
--- modules.c	2002/10/13 15:16:57	1.40
***************
*** 156,161 ****
--- 156,163 ----
          instance = mod_list->mod_instance;
  	if ( module && module->redir ) {
  	    rc = module->redir(so, group, rq, flag, instance);
+             my_xlog(OOPS_LOG_DBG,"%s/%d returned %d\n", 
+                 mod_list->mod_name, instance, rc);
  	}
  	if ( flag && TEST(*flag, MOD_AFLAG_BRK) )
  	    return(MOD_CODE_ERR);
***************
*** 206,211 ****
--- 208,241 ----
  }
  
  int
+ check_redir_control_request(int so, struct request *rq, struct group *group, int *flag)
+ {
+ int                     rc = MOD_CODE_OK;
+ struct  redir_module    *module;
+ l_mod_call_list_t       *gr_mods = group->redir_mods;
+ mod_call_t              *mod_list = NULL;
+ int                     instance;
+ 
+     if ( gr_mods ) mod_list = gr_mods->list;
+ 
+     if ( flag ) *flag = 0;
+     while( mod_list && (rc == MOD_CODE_OK) ) {
+         module = NULL;
+         module = redir_module_by_name(mod_list->mod_name);
+         instance = mod_list->mod_instance;
+         if ( module && module->redir_control_request ) {
+             rc = module->redir_control_request(so, group, rq, flag, instance);
+             my_xlog(OOPS_LOG_DBG,"%s/%d returned %d\n",
+                 mod_list->mod_name, instance, rc);
+         }
+         if ( flag && TEST(*flag, MOD_AFLAG_BRK) )
+             return(MOD_CODE_ERR);
+         mod_list = mod_list->next;
+     }
+     return(rc);
+ }
+ 
+ int
  pre_body(int so, struct mem_obj *obj, struct request *rq, int *flags)
  {
  int			rc = MOD_CODE_OK;
***************
*** 420,426 ****
  		redir_module->redir = (mod_load_t*)DLSYM(modh, "redir");
  		redir_module->redir_connect = (mod_load_t*)DLSYM(modh, "redir_connect");
  		redir_module->redir_rewrite_header = (mod_load_t*)DLSYM(modh, "redir_rewrite_header");
! 		redir_module->general.type = MODULE_REDIR;
  		insert_module((struct general_module*)redir_module,
  			      (struct general_module**)&redir_first);
  
--- 450,457 ----
  		redir_module->redir = (mod_load_t*)DLSYM(modh, "redir");
  		redir_module->redir_connect = (mod_load_t*)DLSYM(modh, "redir_connect");
  		redir_module->redir_rewrite_header = (mod_load_t*)DLSYM(modh, "redir_rewrite_header");
!                 redir_module->redir_control_request = (mod_load_t*)DLSYM(modh, "redir_control_request");
!                 redir_module->general.type = MODULE_REDIR;
  		insert_module((struct general_module*)redir_module,
  			      (struct general_module**)&redir_first);
  
***************
*** 771,777 ****
  		pptr->in_addr = sin_addr.sin_addr;
  		pptr->so = so;
  		add_socket_to_listen_list(so, port, &pptr->in_addr, 0, NULL);
! 		listen(so, 128);
  		pptr++;
  	    } else {
  		verb_printf("parse_myports(): bind: %s\n", strerror(errno));
--- 802,808 ----
  		pptr->in_addr = sin_addr.sin_addr;
  		pptr->so = so;
  		add_socket_to_listen_list(so, port, &pptr->in_addr, 0, NULL);
! 		listen(so, 8196);
  		pptr++;
  	    } else {
  		verb_printf("parse_myports(): bind: %s\n", strerror(errno));
Index: src/modules.h
===================================================================
RCS file: /usr/local/cvs/oops/src/modules.h,v
retrieving revision 1.20
retrieving revision 1.21
diff -c -r1.20 -r1.21
*** modules.h	2001/05/26 07:26:55	1.20
--- modules.h	2002/10/13 15:17:02	1.21
***************
*** 75,80 ****
--- 75,81 ----
  	int	(*redir)(int, struct group*, struct request*, int*, int);
  	int	(*redir_connect)(int*, struct request*, int*, int);
  	int	(*redir_rewrite_header)(char **, struct request*, int*, int);
+         int     (*redir_control_request)(int, struct group*, struct request*, int*, int);
  };
  
  struct	output_module {
Index: src/oops.c
===================================================================
RCS file: /usr/local/cvs/oops/src/oops.c,v
retrieving revision 1.75
retrieving revision 1.77
diff -c -r1.75 -r1.77
*** oops.c	2002/02/14 07:02:23	1.75
--- oops.c	2002/07/30 08:05:56	1.77
***************
*** 68,73 ****
--- 68,74 ----
  int			accesslog_num, accesslog_size;
  int			log_num, log_size;
  unsigned int		maxresident;
+ unsigned int		minresident;
  int			icp_so;
  int			server_so;
  int			peer_down_interval;
***************
*** 156,161 ****
--- 157,163 ----
  int		dont_cache_without_last_modified;
  int		storages_ready;
  int             fetch_with_client_speed;
+ int             dst_ip_acl_present;
  
  named_acl_t	*named_acls;
  struct charset	*charsets;
***************
*** 693,698 ****
--- 695,701 ----
      disk_low_free	= DEFAULT_LOW_FREE;
      disk_hi_free	= DEFAULT_HI_FREE;
      maxresident		= DEFAULT_MAXRESIDENT;
+     minresident		= DEFAULT_MINRESIDENT;
      dns_ttl		= DEFAULT_DNS_TTL;
      icp_timeout		= DEFAULT_ICP_TIMEOUT;
      accesslog_buffered	= FALSE;
***************
*** 702,707 ****
--- 705,711 ----
      dont_cache_without_last_modified = FALSE;
      storages_ready = FALSE;
      fetch_with_client_speed = TRUE;
+     dst_ip_acl_present = FALSE;
      if ( stop_cache )
  	free_stop_cache();
  
Index: src/oops.cfg.in
===================================================================
RCS file: /usr/local/cvs/oops/src/oops.cfg.in,v
retrieving revision 1.39
retrieving revision 1.41
diff -c -r1.39 -r1.41
*** oops.cfg.in	2002/01/23 19:29:02	1.39
--- oops.cfg.in	2002/07/30 08:05:56	1.41
***************
*** 1,4 ****
--- 1,10 ----
  ##
+ ## You can insert include statement at top level config, so that config can
+ ## be combined from several files. 'include' can be nested (maximum depth 10)
+ ##
+ #include	<filename>
+ 
+ ##
  #  nameservers. Use your own, not our.
  ## 
  
***************
*** 168,175 ****
--- 174,192 ----
  ##
  maxresident	1m
  
+ ##
+ #  minimum size of the object we will cache
+ ##
+ #minresident	0
+ 
  insert_x_forwarded_for	yes
  insert_via		yes
+ ##
+ # Load documents as fast as we can, or as fast as client can download
+ # First method will save number of opened sockets
+ # Second - save your bandwidth and memory.
+ # Use "yes".
+ ##
  fetch_with_client_speed yes
  
  ##
***************
*** 198,203 ****
--- 215,224 ----
  #acl	BADDOMREGEX	dstdom_regex	baddomain\.((com)|(org))
  #acl	LOCAL_NETWORKS	src_ip		include:@OOPS_SYSCONFDIR@/acl_local_networks
  #acl	BADNETWORKS	src_ip		192.168.10/24
+ ## WARNING: acl dst_ip is applyed to destination hostname BEFORE
+ ## any redirection used.
+ #acl	LOCALDST	dst_ip		192.168.10/24
+ ##
  #acl	WORKTIME	time		Mon,Tue:Fri 0900:1800
  #acl	HTMLS		content_type	text/html
  #acl	USERS		username	joe
Index: src/oops.h
===================================================================
RCS file: /usr/local/cvs/oops/src/oops.h,v
retrieving revision 1.76
retrieving revision 1.80
diff -c -r1.76 -r1.80
*** oops.h	2001/12/02 09:14:44	1.76
--- oops.h	2002/10/13 15:17:31	1.80
***************
*** 194,200 ****
  #define	CHUNK_SIZE	(64)
  #define	ROUND_CHUNKS(s)	((((s) / CHUNK_SIZE) + 1) * CHUNK_SIZE)
  
! #define	HASH_SIZE	(512)
  #define	HASH_MASK	(HASH_SIZE-1)
  
  #define	DNS_HASH_SIZE	(512)
--- 194,200 ----
  #define	CHUNK_SIZE	(64)
  #define	ROUND_CHUNKS(s)	((((s) / CHUNK_SIZE) + 1) * CHUNK_SIZE)
  
! #define	HASH_SIZE	(1024)
  #define	HASH_MASK	(HASH_SIZE-1)
  
  #define	DNS_HASH_SIZE	(512)
***************
*** 202,223 ****
  
  #define	OOPS_DB_PAGE_SIZE	(4*1024)
  
! #define	METH_GET	0
! #define	METH_HEAD	1
! #define	METH_POST	2
! #define	METH_PUT	3
! #define	METH_CONNECT	4
! #define	METH_TRACE	5
! #define	METH_PROPFIND	6
! #define	METH_PROPPATCH	7
! #define	METH_DELETE	8
! #define	METH_MKCOL	9
! #define	METH_COPY	10
! #define	METH_MOVE	11
! #define	METH_LOCK	12
! #define	METH_UNLOCK	13
! #define	METH_PURGE	14
! #define	METH_OPTIONS	15
  
  #define	AND_PUT		1
  #define	AND_USE		2
--- 202,225 ----
  
  #define	OOPS_DB_PAGE_SIZE	(4*1024)
  
! #define	METH_GET                0
! #define	METH_HEAD               1
! #define	METH_POST               2
! #define	METH_PUT                3
! #define	METH_CONNECT            4
! #define	METH_TRACE              5
! #define	METH_PROPFIND           6
! #define	METH_PROPPATCH          7
! #define	METH_DELETE             8
! #define	METH_MKCOL              9
! #define	METH_COPY               10
! #define	METH_MOVE               11
! #define	METH_LOCK               12
! #define	METH_UNLOCK             13
! #define	METH_PURGE              14
! #define	METH_OPTIONS            15
! #define	METH_PURGE_SITE         16
! #define METH_PURGE_SITE_R       17
  
  #define	AND_PUT		1
  #define	AND_USE		2
***************
*** 285,291 ****
  #define	CRLF			"\r\n"
  
  #define	ANSW_SIZE		(2*1024)
! #define	READ_ANSW_TIMEOUT	(10*60)		/* 10 minutes	*/
  
  #define	DEFAULT_EXPIRE_VALUE	(7*24*3600)	/* 7 days	*/
  #define	DEFAULT_EXPIRE_INTERVAL	(1*3600)	/* each hour	*/
--- 287,293 ----
  #define	CRLF			"\r\n"
  
  #define	ANSW_SIZE		(2*1024)
! #define	READ_ANSW_TIMEOUT	(5*60)		/* 5 minutes	*/
  
  #define	DEFAULT_EXPIRE_VALUE	(7*24*3600)	/* 7 days	*/
  #define	DEFAULT_EXPIRE_INTERVAL	(1*3600)	/* each hour	*/
***************
*** 294,299 ****
--- 296,302 ----
  #define	DEFAULT_LOW_FREE	(5)		/* these values for BIG storages */
  #define	DEFAULT_HI_FREE		(6)
  #define	DEFAULT_MAXRESIDENT	(1024*1024)	/* 1MB		*/
+ #define	DEFAULT_MINRESIDENT	(0)	        /* no limit	*/
  #define	DEFAULT_DNS_TTL		(30*60)		/* 30 min's	*/
  #define	DEFAULT_ICP_TIMEOUT	(1000000)	/* 1 sec	*/
  
***************
*** 498,503 ****
--- 501,508 ----
  	ip_hash_entry_t		*ip_hash_ptr;
  	char			*decoding_buff;	/* for inflate or any other content decoding */
  	char			*decoded_beg, *decoded_end;
+ 	struct			sockaddr_in dst_sa; /* if we have to use dst_ip acl */
+         time_t                  site_purged;    /* if we go through accel/map with 'purged' */
  #if	defined(HAVE_ZLIB)
  	z_streamp		strmp;
  	z_stream		strm;
***************
*** 787,792 ****
--- 792,798 ----
  #define	ACL_CONTENT_TYPE	14
  #define	ACL_USERNAME        15
  #define ACL_HEADER_SUBSTR   16
+ #define	ACL_DST_IP          17
  
  struct	acl {
  #define	ACL_DOMAINDST		1
***************
*** 873,880 ****
  	struct dns_cache_item *items;
  };
  #define	SOURCE_DIRECT	0
! #define	PEER_PARENT	1
  #define	PEER_SIBLING	2
  
  #define	PEER_UP		0
  #define	PEER_DOWN	1
--- 879,887 ----
  	struct dns_cache_item *items;
  };
  #define	SOURCE_DIRECT	0
! #define	PEER_PARENT	    1
  #define	PEER_SIBLING	2
+ #define SOURCE_NONE     3
  
  #define	PEER_UP		0
  #define	PEER_DOWN	1
Index: src/parser.l
===================================================================
RCS file: /usr/local/cvs/oops/src/parser.l,v
retrieving revision 1.29
retrieving revision 1.31
diff -c -r1.29 -r1.31
*** parser.l	2002/01/23 19:29:02	1.29
--- parser.l	2002/07/25 14:45:27	1.31
***************
*** 1,14 ****
! %a 10500
  %o 17000
  %p 10000
  %n 1000
  %e 3000
  %{
  #include "oops.h"
  
  #include "y.tab.h"
! int	atline;
! int	parser_errors;
  
  #if	defined(WITH_LARGE_FILES)
  #if	defined(HAVE_ATOLL)
--- 1,16 ----
! %a 11000
  %o 17000
  %p 10000
  %n 1000
  %e 3000
+ %x incl
  %{
  #include "oops.h"
  
  #include "y.tab.h"
! int atline;
! char *conf_file_name;
! int parser_errors;
  
  #if	defined(WITH_LARGE_FILES)
  #if	defined(HAVE_ATOLL)
***************
*** 21,26 ****
--- 23,34 ----
  #else
  #define	ATOOFF	atoi
  #endif	/* WITH_LARGE_FILES */
+ 
+ #define MAX_INCLUDE_DEPTH 10
+ YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
+ char *conf_file_names[MAX_INCLUDE_DEPTH];
+ int conf_file_lines[MAX_INCLUDE_DEPTH];
+ int include_stack_ptr = 0;
  %}
  
  %s	groupst peerst
***************
*** 37,42 ****
--- 45,51 ----
  network		{number}("."{number})*"/"{number}
  group		[Gg][Rr][Oo][Uu][Pp]
  networks	[Nn][Ee][Tt][Ww][Oo][Rr][Kk][Ss]
+ include_conf	[Ii][Nn][Cc][Ll][Uu][Dd][Ee]
  logfile		[Ll][Oo][Gg][Ff][Ii][Ll][Ee]
  accesslog	[Aa][Cc][Cc][Ee][Ss][Ss][Ll][Oo][Gg]
  pidfile		[Pp][Ii][Dd][Ff][Ii][Ll][Ee]
***************
*** 142,147 ****
--- 151,188 ----
  <groupst>[Ss][Rr][Cc][Dd][Oo][Mm][Aa][Ii][Nn][Ss] {
  		return(SRCDOMAINS_T);
  		}
+ <INITIAL>{include_conf}	{
+ 		BEGIN(incl);
+ 		}
+ <incl>[ \t]+	/* eat the whitespace */
+ <incl>[^ \t\n]+ { /* got the include file name */
+ 	if ( include_stack_ptr >= MAX_INCLUDE_DEPTH ) {
+ 		fprintf( stderr, "Includes nested too deeply" );
+ 		exit( 1 );
+ 	}
+ 	conf_file_names[include_stack_ptr] = conf_file_name;
+ 	conf_file_name = strdup(yytext);
+ 	conf_file_lines[include_stack_ptr] = atline;
+ 	atline = 1;
+ 	include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
+ 	yyin = fopen( yytext, "r" );
+ 	if ( ! yyin ) {
+ 		fprintf( stderr, "Unable to include file %s: %s", yytext, errno );
+ 		exit( 1 );
+ 	}
+ 	yy_switch_to_buffer( yy_create_buffer( yyin, YY_BUF_SIZE ) );
+ 	BEGIN(INITIAL);
+ 	}
+ <<EOF>> {
+ 	if ( --include_stack_ptr < 0 ) {
+ 		yyterminate();
+ 	} else {
+ 		yy_delete_buffer( YY_CURRENT_BUFFER );
+ 		conf_file_name = conf_file_names[include_stack_ptr];
+ 		atline = conf_file_lines[include_stack_ptr];
+ 		yy_switch_to_buffer( include_stack[include_stack_ptr] );
+ 	}
+ 	}
  <INITIAL>{logfile}	{
  		return(LOGFILE);
  		}
***************
*** 262,267 ****
--- 303,311 ----
  <INITIAL>{maxresident}	{
  		return(MAXRESIDENT);
  		}
+ <INITIAL>[Mm][Ii][Nn][Rr][Ee][Ss][Ii][Dd][Ee][Nn][Tt]	{
+ 		return(MINRESIDENT);
+ 		}
  <INITIAL>{icons_host}	{
  		return(ICONS_HOST);
  		}
***************
*** 479,484 ****
  yyerror(void)
  {
  	parser_errors++;
! 	fprintf(stderr, "lex: error on \"%s\" at line %d\n", yytext, atline);
  	exit(1);
  }
--- 523,528 ----
  yyerror(void)
  {
  	parser_errors++;
! 	fprintf(stderr, "%s:%d: error on \"%s\"\n", conf_file_name, atline, yytext);
  	exit(1);
  }
Index: src/parser.y
===================================================================
RCS file: /usr/local/cvs/oops/src/parser.y,v
retrieving revision 1.41
retrieving revision 1.43
diff -c -r1.41 -r1.43
*** parser.y	2002/01/23 19:29:02	1.41
--- parser.y	2002/07/25 14:45:27	1.43
***************
*** 1,6 ****
  %token	LOGFILE ACCESSLOG STATISTICS PIDFILE NAMESERVER HTTP_PORT ICP_PORT
  %token	ICONS_HOST ICONS_PORT ICONS_PATH EXPIRE_VALUE FTP_EXPIRE_VALUE_T EXPIRE_INTERVAL
! %token	STOP_CACHE MAXRESIDENT CONNECT_FROM
  %token	MEM_MAX LO_MARK HI_MARK DISK_LOW_FREE_T DISK_HI_FREE_T
  %token	PARENT_T PEER_T SIBLING_T LOCAL_DOMAIN_T LOCAL_NETWORKS_T
  %token	GROUP NETWORK NETWORKS HTTP ICP
--- 1,6 ----
  %token	LOGFILE ACCESSLOG STATISTICS PIDFILE NAMESERVER HTTP_PORT ICP_PORT
  %token	ICONS_HOST ICONS_PORT ICONS_PATH EXPIRE_VALUE FTP_EXPIRE_VALUE_T EXPIRE_INTERVAL
! %token	STOP_CACHE MAXRESIDENT MINRESIDENT CONNECT_FROM
  %token	MEM_MAX LO_MARK HI_MARK DISK_LOW_FREE_T DISK_HI_FREE_T
  %token	PARENT_T PEER_T SIBLING_T LOCAL_DOMAIN_T LOCAL_NETWORKS_T
  %token	GROUP NETWORK NETWORKS HTTP ICP
***************
*** 41,46 ****
--- 41,47 ----
  extern	FILE	*yyin;
  
  int	atline;
+ char	*conf_file_name;
  int	parser_errors;
  
  static	char	*storage_path = NULL;
***************
*** 59,66 ****
  	int			down_timeout;
  } peer_c = {PEER_SIBLING,NULL,NULL,NULL, 60};
  
! static	void			add_to_stop_cache(char *string);
! static	struct	domain_list	*load_domlist_from_file(char*);
  static	struct	domain_list	*load_domlist_from_list(struct string_list *);
  static	int			string_to_days(struct denytime *, struct string_list *);
  
--- 60,67 ----
  	int			down_timeout;
  } peer_c = {PEER_SIBLING,NULL,NULL,NULL, 60};
  
! static	void			add_to_stop_cache(char *);
! static	struct	domain_list	*load_domlist_from_file(char *);
  static	struct	domain_list	*load_domlist_from_list(struct string_list *);
  static	int			string_to_days(struct denytime *, struct string_list *);
  
***************
*** 90,95 ****
--- 91,97 ----
  
  statements	: statement
  		| statements statement
+ 		;
  
  statement	: logfile
  		| accesslog
***************
*** 122,127 ****
--- 124,130 ----
  		| local_networks
  		| stop_cache
  		| maxresident
+ 		| minresident
  		| mem_max
  		| lo_mark
  		| hi_mark
***************
*** 152,157 ****
--- 155,161 ----
  			yyerrok;
  		  }
  		| L_EOS
+ 		;
  
  logfile		: LOGFILE string L_EOS {
  			verb_printf("LOGFILE:\t<<%s>>\n", $2);
***************
*** 207,235 ****
  			}
  			free($7);
  		}
  
  userid		: USERID_T string L_EOS {
  			oops_user = $2;
  		}
! 
  chroot		: CHROOT_T string L_EOS {
  			oops_chroot = $2;
  		}
! 
  blacklist	: BLACKLIST_T num L_EOS {
  			blacklist_len = $2;
  		}
! 
  refuse_at	: REFUSE_AT_T num L_EOS {
  			refuse_at = $2;
  		}
  start_red	: START_RED_T num L_EOS {
  			start_red = $2;
  		}
  dont_cache_without_last_modified : DONT_CACHE_WITHOUT_LAST_MODIFIED_T L_EOS {
  			dont_cache_without_last_modified = TRUE;
  		}
! 
  insert_x_forwarded_for : INSERT_X_FORWARDED_FOR_T string L_EOS {
  			if ( !strcasecmp(yylval.STRPTR, "yes") )
  				insert_x_forwarded_for = TRUE;
--- 211,242 ----
  			}
  			free($7);
  		}
+ 		;
  
  userid		: USERID_T string L_EOS {
  			oops_user = $2;
  		}
! 		;
  chroot		: CHROOT_T string L_EOS {
  			oops_chroot = $2;
  		}
! 		;
  blacklist	: BLACKLIST_T num L_EOS {
  			blacklist_len = $2;
  		}
! 		;
  refuse_at	: REFUSE_AT_T num L_EOS {
  			refuse_at = $2;
  		}
+ 		;
  start_red	: START_RED_T num L_EOS {
  			start_red = $2;
  		}
+ 		;
  dont_cache_without_last_modified : DONT_CACHE_WITHOUT_LAST_MODIFIED_T L_EOS {
  			dont_cache_without_last_modified = TRUE;
  		}
! 		;
  insert_x_forwarded_for : INSERT_X_FORWARDED_FOR_T string L_EOS {
  			if ( !strcasecmp(yylval.STRPTR, "yes") )
  				insert_x_forwarded_for = TRUE;
***************
*** 240,246 ****
  				printf("insert_x_forwarded_for can be 'yes' or 'no'\n");
  			free(yylval.STRPTR);
  		}
! 
  fetch_with_client_speed : FETCH_WITH_CLIENT_SPEED_T string L_EOS {
  			if ( !strcasecmp(yylval.STRPTR, "yes") )
  				fetch_with_client_speed = TRUE;
--- 247,253 ----
  				printf("insert_x_forwarded_for can be 'yes' or 'no'\n");
  			free(yylval.STRPTR);
  		}
! 		;
  fetch_with_client_speed : FETCH_WITH_CLIENT_SPEED_T string L_EOS {
  			if ( !strcasecmp(yylval.STRPTR, "yes") )
  				fetch_with_client_speed = TRUE;
***************
*** 251,257 ****
  				printf("fetch_with_client_speed can be 'yes' or 'no'\n");
  			free(yylval.STRPTR);
  		}
! 
  insert_via	: INSERT_VIA_T string L_EOS {
  			if ( !strcasecmp(yylval.STRPTR, "yes") )
  				insert_via = TRUE;
--- 258,264 ----
  				printf("fetch_with_client_speed can be 'yes' or 'no'\n");
  			free(yylval.STRPTR);
  		}
! 		;
  insert_via	: INSERT_VIA_T string L_EOS {
  			if ( !strcasecmp(yylval.STRPTR, "yes") )
  				insert_via = TRUE;
***************
*** 262,268 ****
  				printf("insert_via can be 'yes' or 'no'\n");
  			free(yylval.STRPTR);
  		}
! 
  accesslog	: ACCESSLOG string L_EOS {
  			verb_printf("ACCESSLOG:\t<<%s>>\n", $2);
  			strncpy(accesslog, $2, sizeof(accesslog)-1);
--- 269,275 ----
  				printf("insert_via can be 'yes' or 'no'\n");
  			free(yylval.STRPTR);
  		}
! 		;
  accesslog	: ACCESSLOG string L_EOS {
  			verb_printf("ACCESSLOG:\t<<%s>>\n", $2);
  			strncpy(accesslog, $2, sizeof(accesslog)-1);
***************
*** 319,325 ****
  			}
  			free($7);
  		}
! 
  refresh_pattern	: REFRESH_PATTERN_T string num string num L_EOS {
  			char	*buf;
  			int	len;
--- 326,332 ----
  			}
  			free($7);
  		}
! 		;
  refresh_pattern	: REFRESH_PATTERN_T string num string num L_EOS {
  			char	*buf;
  			int	len;
***************
*** 333,355 ****
  			free($2);
  			free($4);
  		}
  bind_acl	: BIND_ACL_T STRING L_EOS {
  			parse_bind_acl(yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
! 
  acl_allow	: ACL_ALLOW_T STRING L_EOS {
  			parse_acl_access(&acl_allow, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
  acl_deny	: ACL_DENY_T  STRING L_EOS {
  			parse_acl_access(&acl_deny, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
  stop_cache_acl	: STOP_CACHE_ACL_T  STRING L_EOS {
  			parse_acl_access(&stop_cache_acl, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
  acl		: ACL_T	STRING L_EOS {
  			char		  *token, *p, *tptr;
  			char		  *n=NULL, *type=NULL, *data=NULL;
--- 340,366 ----
  			free($2);
  			free($4);
  		}
+ 		;
  bind_acl	: BIND_ACL_T STRING L_EOS {
  			parse_bind_acl(yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
! 		;
  acl_allow	: ACL_ALLOW_T STRING L_EOS {
  			parse_acl_access(&acl_allow, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
+ 		;
  acl_deny	: ACL_DENY_T  STRING L_EOS {
  			parse_acl_access(&acl_deny, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
+ 		;
  stop_cache_acl	: STOP_CACHE_ACL_T  STRING L_EOS {
  			parse_acl_access(&stop_cache_acl, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
+ 		;
  acl		: ACL_T	STRING L_EOS {
  			char		  *token, *p, *tptr;
  			char		  *n=NULL, *type=NULL, *data=NULL;
***************
*** 408,426 ****
  		done:;
  			free(yylval.STRPTR);
  		}
! 
  statistics	: STATISTICS STRING L_EOS {
  			verb_printf("STATISTICS:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(statisticslog, yylval.STRPTR, sizeof(statisticslog)-1);
  			free(yylval.STRPTR);
  		}
! 
  pidfile		: PIDFILE STRING L_EOS {
  			verb_printf("PIDFILE:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(pidfile, yylval.STRPTR, sizeof(pidfile)-1);
  			free(yylval.STRPTR);
  		}
! 
  nameserver	: NAMESERVER STRING L_EOS {
  			verb_printf("NAMESERVER:\t<<%s>>\n", yylval.STRPTR);
  			if ( ns_curr < OOPSMAXNS ) {
--- 419,437 ----
  		done:;
  			free(yylval.STRPTR);
  		}
! 		;
  statistics	: STATISTICS STRING L_EOS {
  			verb_printf("STATISTICS:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(statisticslog, yylval.STRPTR, sizeof(statisticslog)-1);
  			free(yylval.STRPTR);
  		}
! 		;
  pidfile		: PIDFILE STRING L_EOS {
  			verb_printf("PIDFILE:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(pidfile, yylval.STRPTR, sizeof(pidfile)-1);
  			free(yylval.STRPTR);
  		}
! 		;
  nameserver	: NAMESERVER STRING L_EOS {
  			verb_printf("NAMESERVER:\t<<%s>>\n", yylval.STRPTR);
  			if ( ns_curr < OOPSMAXNS ) {
***************
*** 437,443 ****
  			}
  			free(yylval.STRPTR);
  		}
! 
  connect_from	: CONNECT_FROM STRING L_EOS {
  			char	*p;
  			strncpy(connect_from, yylval.STRPTR, sizeof(connect_from)-1);
--- 448,454 ----
  			}
  			free(yylval.STRPTR);
  		}
! 		;
  connect_from	: CONNECT_FROM STRING L_EOS {
  			char	*p;
  			strncpy(connect_from, yylval.STRPTR, sizeof(connect_from)-1);
***************
*** 446,524 ****
  			while ( *p ) { *p=tolower(*p); p++; }
  			verb_printf("CONNECT_FROM:\t<<%s>>\n", connect_from);
  		}
! 
  stop_cache	: STOP_CACHE STRING L_EOS {
  			verb_printf("STOP_CACHE:\t<<%s>>\n", yylval.STRPTR);
  			add_to_stop_cache(yylval.STRPTR);
  		}
  maxresident	: MAXRESIDENT NUMBER L_EOS {
  			verb_printf("MAXRESIDENT:\t %d\n", yylval.INT);
  			maxresident = yylval.INT;
  		}
! 
  bind		: BIND_T string L_EOS {
  			bind_addr = $2;
  		}
! 
  http_port	: HTTP_PORT NUMBER L_EOS {
  			verb_printf("HTTP_PORT\t<<%d>>\n", yylval.INT);
  			http_port = yylval.INT;
  		}
! 
  icp_port	: ICP_PORT NUMBER L_EOS {
  			verb_printf("ICP_PORT\t<<%d>>\n", yylval.INT);
  			icp_port = yylval.INT;
  		}
! 
  icp_timeout	: ICP_TIMEOUT NUMBER L_EOS {
  			verb_printf("ICP_TIMEOUT\t<<%d>>\n", yylval.INT);
  			icp_timeout = 1000*yylval.INT;
  		}
! 
  icons_host	: ICONS_HOST STRING L_EOS {
  			verb_printf("ICONS_HOST:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(icons_host, yylval.STRPTR, sizeof(icons_host)-1);
  			free(yylval.STRPTR);
  		}
! 
  icons_port	: ICONS_PORT NUMBER L_EOS {
  			verb_printf("ICONS_PORT:\t<<%d>>\n", yylval.INT);
  			sprintf(icons_port, "%d", yylval.INT);
  		}
! 
  icons_path	: ICONS_PATH STRING L_EOS {
  			verb_printf("ICONS_PATH:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(icons_path, yylval.STRPTR, sizeof(icons_path)-1);
  			free(yylval.STRPTR);
  		}
! 
  always_check_freshness : ALWAYS_CHECK_FRESHNESS_T L_EOS {
  			verb_printf("ALWAYS CHECK FRESHNESS\n");
  			always_check_freshness = TRUE;
  		}
  always_check_freshness_acl : ALWAYS_CHECK_FRESHNESS_ACL_T STRING L_EOS {
  			verb_printf("ALWAYS CHECK FRESHNESS ACL\n");
  			parse_acl_access(&always_check_freshness_acl, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
! 
  force_http11	: FORCE_HTTP11_T L_EOS {
  			verb_printf("FORCE_HTTP11\n");
  			force_http11 = TRUE;
  		}
  force_completion : FORCE_COMPLETION_T NUMBER L_EOS {
  			verb_printf("FORCE_COMPLETION: %d%%\n", yylval.INT);
  			force_completion = yylval.INT;
  		}
  last_modified_factor : LAST_MODIFIED_FACTOR_T NUMBER L_EOS {
  			verb_printf("LAST_MODIFIED_FACTOR: %d\n", yylval.INT);
  			last_modified_factor = yylval.INT;
  		}
  expire_value	: EXPIRE_VALUE NUMBER L_EOS {
  			verb_printf("EXPIRE_VALUE:\t<<%d days>>\n", yylval.INT);
  			default_expire_value=yylval.INT * 24 * 3600;
  		}
! 
  expiretime	: EXPIRE_TIME_T string_list {
  		    struct	denytime		*denytime;
  		    int		start_m, end_m;
--- 457,545 ----
  			while ( *p ) { *p=tolower(*p); p++; }
  			verb_printf("CONNECT_FROM:\t<<%s>>\n", connect_from);
  		}
! 		;
  stop_cache	: STOP_CACHE STRING L_EOS {
  			verb_printf("STOP_CACHE:\t<<%s>>\n", yylval.STRPTR);
  			add_to_stop_cache(yylval.STRPTR);
  		}
+ 		;
  maxresident	: MAXRESIDENT NUMBER L_EOS {
  			verb_printf("MAXRESIDENT:\t %d\n", yylval.INT);
  			maxresident = yylval.INT;
  		}
! 		;
! minresident	: MINRESIDENT NUMBER L_EOS {
! 			verb_printf("MINRESIDENT:\t %d\n", yylval.INT);
! 			minresident = yylval.INT;
! 		}
! 		;
  bind		: BIND_T string L_EOS {
  			bind_addr = $2;
  		}
! 		;
  http_port	: HTTP_PORT NUMBER L_EOS {
  			verb_printf("HTTP_PORT\t<<%d>>\n", yylval.INT);
  			http_port = yylval.INT;
  		}
! 		;
  icp_port	: ICP_PORT NUMBER L_EOS {
  			verb_printf("ICP_PORT\t<<%d>>\n", yylval.INT);
  			icp_port = yylval.INT;
  		}
! 		;
  icp_timeout	: ICP_TIMEOUT NUMBER L_EOS {
  			verb_printf("ICP_TIMEOUT\t<<%d>>\n", yylval.INT);
  			icp_timeout = 1000*yylval.INT;
  		}
! 		;
  icons_host	: ICONS_HOST STRING L_EOS {
  			verb_printf("ICONS_HOST:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(icons_host, yylval.STRPTR, sizeof(icons_host)-1);
  			free(yylval.STRPTR);
  		}
! 		;
  icons_port	: ICONS_PORT NUMBER L_EOS {
  			verb_printf("ICONS_PORT:\t<<%d>>\n", yylval.INT);
  			sprintf(icons_port, "%d", yylval.INT);
  		}
! 		;
  icons_path	: ICONS_PATH STRING L_EOS {
  			verb_printf("ICONS_PATH:\t<<%s>>\n", yylval.STRPTR);
  			strncpy(icons_path, yylval.STRPTR, sizeof(icons_path)-1);
  			free(yylval.STRPTR);
  		}
! 		;
  always_check_freshness : ALWAYS_CHECK_FRESHNESS_T L_EOS {
  			verb_printf("ALWAYS CHECK FRESHNESS\n");
  			always_check_freshness = TRUE;
  		}
+ 		;
  always_check_freshness_acl : ALWAYS_CHECK_FRESHNESS_ACL_T STRING L_EOS {
  			verb_printf("ALWAYS CHECK FRESHNESS ACL\n");
  			parse_acl_access(&always_check_freshness_acl, yylval.STRPTR);
  			free(yylval.STRPTR);
  		}
! 		;
  force_http11	: FORCE_HTTP11_T L_EOS {
  			verb_printf("FORCE_HTTP11\n");
  			force_http11 = TRUE;
  		}
+ 		;
  force_completion : FORCE_COMPLETION_T NUMBER L_EOS {
  			verb_printf("FORCE_COMPLETION: %d%%\n", yylval.INT);
  			force_completion = yylval.INT;
  		}
+ 		;
  last_modified_factor : LAST_MODIFIED_FACTOR_T NUMBER L_EOS {
  			verb_printf("LAST_MODIFIED_FACTOR: %d\n", yylval.INT);
  			last_modified_factor = yylval.INT;
  		}
+ 		;
  expire_value	: EXPIRE_VALUE NUMBER L_EOS {
  			verb_printf("EXPIRE_VALUE:\t<<%d days>>\n", yylval.INT);
  			default_expire_value=yylval.INT * 24 * 3600;
  		}
! 		;
  expiretime	: EXPIRE_TIME_T string_list {
  		    struct	denytime		*denytime;
  		    int		start_m, end_m;
***************
*** 531,574 ****
  		    }
  		    free_string_list($2);
  		}
  max_expire_value : MAX_EXPIRE_VALUE_T NUMBER L_EOS {
  			verb_printf("MAX_EXPIRE_VALUE:\t<<%d days>>\n", yylval.INT);
  			max_expire_value=yylval.INT * 24 * 3600;
  		}
! 
  ftp_expire_value : FTP_EXPIRE_VALUE_T NUMBER L_EOS {
  			verb_printf("FTP_EXPIRE_VALUE:\t<<%d days>>\n", yylval.INT);
  			ftp_expire_value=yylval.INT * 24 * 3600;
  		}
! 
  expire_interval	: EXPIRE_INTERVAL NUMBER L_EOS {
  			verb_printf("EXPIRE_INTERVAL:<<%d hours>>\n", yylval.INT);
  			default_expire_interval=yylval.INT * 3600;
  		}
! 
  disk_low_free	: DISK_LOW_FREE_T NUMBER L_EOS {
  			verb_printf("DISK_LOW_FREE:\t<<%d %%>>\n", yylval.INT);
  			disk_low_free=yylval.INT ;
  		}
! 
  disk_hi_free	: DISK_HI_FREE_T NUMBER L_EOS {
  			verb_printf("DISK_HI_FREE:\t<<%d %%>>\n", yylval.INT);
  			disk_hi_free=yylval.INT ;
  		}
! 
  parent		: PARENT_T string num L_EOS{
  			verb_printf("PARENT: %s:%d\n", $2, $3);
  			strncpy(parent_host, $2, sizeof(parent_host));
  			parent_port = $3;
  			free($2);
  		}
! 
  parent_auth	: PARENT_AUTH_T string L_EOS{
  			verb_printf("PARENT_AUTH: %s\n", $2);
  			parent_auth = base64_encode($2);
  			free($2);
  		}
! 
  local_domain	: LOCAL_DOMAIN_T domainlist L_EOS {
  		    struct domain_list *d;
  			verb_printf ("LOCAL_DOMAIN\n");
--- 552,596 ----
  		    }
  		    free_string_list($2);
  		}
+ 		;
  max_expire_value : MAX_EXPIRE_VALUE_T NUMBER L_EOS {
  			verb_printf("MAX_EXPIRE_VALUE:\t<<%d days>>\n", yylval.INT);
  			max_expire_value=yylval.INT * 24 * 3600;
  		}
! 		;
  ftp_expire_value : FTP_EXPIRE_VALUE_T NUMBER L_EOS {
  			verb_printf("FTP_EXPIRE_VALUE:\t<<%d days>>\n", yylval.INT);
  			ftp_expire_value=yylval.INT * 24 * 3600;
  		}
! 		;
  expire_interval	: EXPIRE_INTERVAL NUMBER L_EOS {
  			verb_printf("EXPIRE_INTERVAL:<<%d hours>>\n", yylval.INT);
  			default_expire_interval=yylval.INT * 3600;
  		}
! 		;
  disk_low_free	: DISK_LOW_FREE_T NUMBER L_EOS {
  			verb_printf("DISK_LOW_FREE:\t<<%d %%>>\n", yylval.INT);
  			disk_low_free=yylval.INT ;
  		}
! 		;
  disk_hi_free	: DISK_HI_FREE_T NUMBER L_EOS {
  			verb_printf("DISK_HI_FREE:\t<<%d %%>>\n", yylval.INT);
  			disk_hi_free=yylval.INT ;
  		}
! 		;
  parent		: PARENT_T string num L_EOS{
  			verb_printf("PARENT: %s:%d\n", $2, $3);
  			strncpy(parent_host, $2, sizeof(parent_host));
  			parent_port = $3;
  			free($2);
  		}
! 		;
  parent_auth	: PARENT_AUTH_T string L_EOS{
  			verb_printf("PARENT_AUTH: %s\n", $2);
  			parent_auth = base64_encode($2);
  			free($2);
  		}
! 		;
  local_domain	: LOCAL_DOMAIN_T domainlist L_EOS {
  		    struct domain_list *d;
  			verb_printf ("LOCAL_DOMAIN\n");
***************
*** 585,591 ****
  			    }
  			}
  		}
! 
  local_networks	: LOCAL_NETWORKS_T network_list L_EOS {
  		    struct cidr_net *n;
  			verb_printf ("LOCAL_NETWORKS\n");
--- 607,613 ----
  			    }
  			}
  		}
! 		;
  local_networks	: LOCAL_NETWORKS_T network_list L_EOS {
  		    struct cidr_net *n;
  			verb_printf ("LOCAL_NETWORKS\n");
***************
*** 601,648 ****
  			    }
  			}
  		}
! 
  dbhome		: DBHOME STRING L_EOS {
  			printf("WARNING!!!! dbhome must be moved to module berkeley_db\n");
  			free(yylval.STRPTR);
  		}
! 
  dbname		: DBNAME STRING L_EOS {
  			printf("WARNING!!!! dbname must be moved to module berkeley_db\n");
  			free(yylval.STRPTR);
  		}
! 
  db_cache_mem    : DB_CACHE_MEM num L_EOS {
  			printf("WARNING!!!! db_cache_mem must be moved to module berkeley_db\n");
  		}
! 
  mem_max		: MEM_MAX num L_EOS {
  			verb_printf("MEM_MAX:\t<<%d>>\n", $2);
  			mem_max_val = $2 ;
  		}
! 
  lo_mark		: LO_MARK num L_EOS {
  			verb_printf("LO_MARK:\t<<%d>>\n", $2);
  			lo_mark_val = $2 ;
  		}
! 
  swap_advance	: SWAP_ADVANCE_T num L_EOS {
  			verb_printf("SWAP_ADVANCE:\t<<%d>>\n", $2);
  			swap_advance = $2 ;
  			if ( swap_advance <= 0 ) swap_advance = 1;
  		}
! 
  hi_mark		: HI_MARK num L_EOS {
  			verb_printf("HI_MARK:\t<<%d>>\n", $2);
  			hi_mark_val = $2 ;
  		}
! 
  num		: NUMBER { $$ = yylval.INT;}
! 
  offset		: NUMBER { $$ = yylval.OFFSET;}
! 
  string		: STRING { $$ = yylval.STRPTR; }
! 
  module		: MODULE module_name '{' mod_ops '}' L_EOS {
  			struct string_list	*list = $4;
  			struct general_module	*mod;
--- 623,670 ----
  			    }
  			}
  		}
! 		;
  dbhome		: DBHOME STRING L_EOS {
  			printf("WARNING!!!! dbhome must be moved to module berkeley_db\n");
  			free(yylval.STRPTR);
  		}
! 		;
  dbname		: DBNAME STRING L_EOS {
  			printf("WARNING!!!! dbname must be moved to module berkeley_db\n");
  			free(yylval.STRPTR);
  		}
! 		;
  db_cache_mem    : DB_CACHE_MEM num L_EOS {
  			printf("WARNING!!!! db_cache_mem must be moved to module berkeley_db\n");
  		}
! 		;
  mem_max		: MEM_MAX num L_EOS {
  			verb_printf("MEM_MAX:\t<<%d>>\n", $2);
  			mem_max_val = $2 ;
  		}
! 		;
  lo_mark		: LO_MARK num L_EOS {
  			verb_printf("LO_MARK:\t<<%d>>\n", $2);
  			lo_mark_val = $2 ;
  		}
! 		;
  swap_advance	: SWAP_ADVANCE_T num L_EOS {
  			verb_printf("SWAP_ADVANCE:\t<<%d>>\n", $2);
  			swap_advance = $2 ;
  			if ( swap_advance <= 0 ) swap_advance = 1;
  		}
! 		;
  hi_mark		: HI_MARK num L_EOS {
  			verb_printf("HI_MARK:\t<<%d>>\n", $2);
  			hi_mark_val = $2 ;
  		}
! 		;
  num		: NUMBER { $$ = yylval.INT;}
! 		;
  offset		: NUMBER { $$ = yylval.OFFSET;}
! 		;
  string		: STRING { $$ = yylval.STRPTR; }
! 		;
  module		: MODULE module_name '{' mod_ops '}' L_EOS {
  			struct string_list	*list = $4;
  			struct general_module	*mod;
***************
*** 677,682 ****
--- 699,705 ----
  			if ( mod && mod->config_end ) (*mod->config_end)(0);
  			free($2);
  		}
+ 		;
  mod_ops		: mod_op {
  			$$ = $1;
  			verb_printf("mod_op: %s\n", $$->string);
***************
*** 688,694 ****
  			$$ = $1;
  			verb_printf("mod_op: %s\n", $2->string);
  		}
! 
  mod_op		: string {
  			struct string_list *new = xmalloc(sizeof(*new), "parser: mod_ops");
  			char		   *new_str;
--- 711,717 ----
  			$$ = $1;
  			verb_printf("mod_op: %s\n", $2->string);
  		}
! 		;
  mod_op		: string {
  			struct string_list *new = xmalloc(sizeof(*new), "parser: mod_ops");
  			char		   *new_str;
***************
*** 705,715 ****
  			new->string = new_str;
  			$$=new;
  		}
! 
  module_name	: STRING {
  			$$ = yylval.STRPTR;
  		}
! 
  
  storage		: STORAGE '{' st_ops '}' L_EOS {
  		    struct storage_st *new;
--- 728,738 ----
  			new->string = new_str;
  			$$=new;
  		}
! 		;
  module_name	: STRING {
  			$$ = yylval.STRPTR;
  		}
! 		;
  
  storage		: STORAGE '{' st_ops '}' L_EOS {
  		    struct storage_st *new;
***************
*** 740,746 ****
  		    storage_size = 0;
  		    storage_offset = 0;
  		}
! 
  peerconfig	: PEER_PARENT_T ';' {
  			if ( !peerc_ptr )
  				peerc_ptr = &peer_c;
--- 763,769 ----
  		    storage_size = 0;
  		    storage_offset = 0;
  		}
! 		;
  peerconfig	: PEER_PARENT_T ';' {
  			if ( !peerc_ptr )
  				peerc_ptr = &peer_c;
***************
*** 797,806 ****
  			$1->next = peerc_ptr->acls->deny;
  			peerc_ptr->acls->deny = $1;
  		  }
! 
  peerops		: peerconfig {}
  		| peerops peerconfig {}
! 
  peer		: PEER_T string num num '{' peerops '}' L_EOS {
  			struct	peer *peer,*p;
  			peer = malloc(sizeof(struct peer));
--- 820,829 ----
  			$1->next = peerc_ptr->acls->deny;
  			peerc_ptr->acls->deny = $1;
  		  }
! 		;
  peerops		: peerconfig {}
  		| peerops peerconfig {}
! 		;
  peer		: PEER_T string num num '{' peerops '}' L_EOS {
  			struct	peer *peer,*p;
  			peer = malloc(sizeof(struct peer));
***************
*** 831,845 ****
  			peer_c.type = PEER_SIBLING;
  			peerc_ptr = NULL;
  		}
! 
  st_ops		: st_op {}
  		| st_op st_ops {}
! 
  st_op		: SIZE offset ';' { storage_size = $2; }
  		| SIZE AUTO_T ';' { storage_size = -1; }
  		| STORAGE_OFFSET_T offset ';' {storage_offset = $2; }
  		| PATH STRING ';' { storage_path = yylval.STRPTR; }
! 
  group		: GROUP group_name '{' group_ops '}' L_EOS {
  			struct	group_ops_struct *ops, *next_ops;
  			struct	group	*new_grp, *g;
--- 854,868 ----
  			peer_c.type = PEER_SIBLING;
  			peerc_ptr = NULL;
  		}
! 		;
  st_ops		: st_op {}
  		| st_op st_ops {}
! 		;
  st_op		: SIZE offset ';' { storage_size = $2; }
  		| SIZE AUTO_T ';' { storage_size = -1; }
  		| STORAGE_OFFSET_T offset ';' {storage_offset = $2; }
  		| PATH STRING ';' { storage_path = yylval.STRPTR; }
! 		;
  group		: GROUP group_name '{' group_ops '}' L_EOS {
  			struct	group_ops_struct *ops, *next_ops;
  			struct	group	*new_grp, *g;
***************
*** 971,983 ****
                                  g->next = new_grp;
                          }
  		}
  group_name	: STRING {
  			$$ = yylval.STRPTR;
  		}
! 
  group_ops	: group_op { $$ = $1;}
  		| group_op group_ops { $1->next = $2; $$=$1;}
! 
  group_op	: NETWORKS network_list ';' {
  			struct	group_ops_struct	*new;
  			new = xmalloc(sizeof(*new), "parser: new group_op");
--- 994,1007 ----
                                  g->next = new_grp;
                          }
  		}
+ 		;
  group_name	: STRING {
  			$$ = yylval.STRPTR;
  		}
! 		;
  group_ops	: group_op { $$ = $1;}
  		| group_op group_ops { $1->next = $2; $$=$1;}
! 		;
  group_op	: NETWORKS network_list ';' {
  			struct	group_ops_struct	*new;
  			new = xmalloc(sizeof(*new), "parser: new group_op");
***************
*** 1028,1034 ****
  		| denytime	{ $$ = $1; }
  		| auth_mods	{ $$ = $1; }
  		| redir_mods	{ $$ = $1; }
! 
  denytime	: DENYTIME_T string_list {
  		    struct	group_ops_struct	*new_op;
  		    struct	denytime		*denytime;
--- 1052,1058 ----
  		| denytime	{ $$ = $1; }
  		| auth_mods	{ $$ = $1; }
  		| redir_mods	{ $$ = $1; }
! 		;
  denytime	: DENYTIME_T string_list {
  		    struct	group_ops_struct	*new_op;
  		    struct	denytime		*denytime;
***************
*** 1049,1054 ****
--- 1073,1079 ----
  			}
  			free_string_list($2);
  		}
+ 		;
  miss		: MISS_T DENY ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1079,1085 ****
  			    $$ = new_op;
  			}
  		}
! 
  auth_mods	: AUTH_MODS_T string_list ';' {
  		    struct	group_ops_struct	*new_op;
  
--- 1104,1110 ----
  			    $$ = new_op;
  			}
  		}
! 		;
  auth_mods	: AUTH_MODS_T string_list ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1095,1100 ****
--- 1120,1126 ----
  			    $$ = new_op;
  			}
  		}
+ 		;
  redir_mods	: REDIR_MODS_T string_list ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1110,1115 ****
--- 1136,1142 ----
  			    $$ = new_op;
  			}
  		}
+ 		;
  bandwidth	: BANDWIDTH_T num ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1125,1130 ****
--- 1152,1158 ----
  			    $$ = new_op;
  			}
  		}
+ 		;
  per_sess_bw	: PER_SESS_BW_T num ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1140,1145 ****
--- 1168,1174 ----
  			    $$ = new_op;
  			}
  		}
+ 		;
  per_ip_bw	: PER_IP_BW_T num ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1155,1160 ****
--- 1184,1190 ----
  			    $$ = new_op;
  			}
  		}
+ 		;
  per_ip_conn	: PER_IP_CONN_T num ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1170,1175 ****
--- 1200,1206 ----
  			    $$ = new_op;
  			}
  		}
+ 		;
  conn_from	: CONN_FROM_T string ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1199,1204 ****
--- 1230,1236 ----
  			$$ = new_op;
  		    }
  		}
+ 		;
  range		: '[' num ':' num ']'  {
  			if ( !badp_p ) badp_p = &badports[0];
  			badp_p->from = $2;
***************
*** 1236,1245 ****
  			    }
  			    free($2);
  			}
! 
  ranges		: range {}
  		| range ',' ranges {}
! 
  badports	: BADPORTS_T ranges ';' {
  		    struct	group_ops_struct	*new_op;
  
--- 1268,1277 ----
  			    }
  			    free($2);
  			}
! 		;
  ranges		: range {}
  		| range ',' ranges {}
! 		;
  badports	: BADPORTS_T ranges ';' {
  		    struct	group_ops_struct	*new_op;
  
***************
*** 1264,1270 ****
  			    }
  			}
  		}
! 
  icp		: ICP '{' deny_acls allow_acls '}' {
  			struct	acls			*new_acls;
  			struct	group_ops_struct	*new_op;
--- 1296,1302 ----
  			    }
  			}
  		}
! 		;
  icp		: ICP '{' deny_acls allow_acls '}' {
  			struct	acls			*new_acls;
  			struct	group_ops_struct	*new_op;
***************
*** 1365,1371 ****
  				}
  			}
  		}
! 
  http		: HTTP '{' deny_acls allow_acls '}' {
  			struct	acls			*new_acls;
  			struct	group_ops_struct	*new_op;
--- 1397,1403 ----
  				}
  			}
  		}
! 		;
  http		: HTTP '{' deny_acls allow_acls '}' {
  			struct	acls			*new_acls;
  			struct	group_ops_struct	*new_op;
***************
*** 1466,1474 ****
  				}
  			}
  		}
  deny_acls	: deny_acl 			{ $$ = $1; }
  		| deny_acl deny_acls 		{ $2->next = $1 ; $$ = $2; }
! 
  deny_acl	: DENY DSTDOMAIN string_list ';' { 
  			struct acl *new = xmalloc(sizeof(*new), "parser: deny_acl new acl 2");
  			if ( !new ) {
--- 1498,1507 ----
  				}
  			}
  		}
+ 		;
  deny_acls	: deny_acl 			{ $$ = $1; }
  		| deny_acl deny_acls 		{ $2->next = $1 ; $$ = $2; }
! 		;
  deny_acl	: DENY DSTDOMAIN string_list ';' { 
  			struct acl *new = xmalloc(sizeof(*new), "parser: deny_acl new acl 2");
  			if ( !new ) {
***************
*** 1489,1498 ****
  			}
  			free_string_list($3);
  		}
! 
  allow_acls	: allow_acl 			{ $$ = $1; }
  		| allow_acl allow_acls 		{ $1->next = $2 ; $$ = $1; }
! 
  allow_acl	: ALLOW  DSTDOMAIN string_list ';' {
  			struct acl *new = xmalloc(sizeof(*new), "parser: allow_acl new acl 2");
  			if ( !new ) {
--- 1522,1531 ----
  			}
  			free_string_list($3);
  		}
! 		;
  allow_acls	: allow_acl 			{ $$ = $1; }
  		| allow_acl allow_acls 		{ $1->next = $2 ; $$ = $1; }
! 		;
  allow_acl	: ALLOW  DSTDOMAIN string_list ';' {
  			struct acl *new = xmalloc(sizeof(*new), "parser: allow_acl new acl 2");
  			if ( !new ) {
***************
*** 1513,1519 ****
  			}
  			free_string_list($3);
  		}
! 
  string_list	: string_list_e { $$ = $1; }
  		| string_list_e string_list {
  			struct string_list *d;
--- 1546,1552 ----
  			}
  			free_string_list($3);
  		}
! 		;
  string_list	: string_list_e { $$ = $1; }
  		| string_list_e string_list {
  			struct string_list *d;
***************
*** 1533,1539 ****
  				d = d->next;
  			}
  		}
! 
  string_list_e	: string {
  		struct string_list	*new;
  			new = xmalloc(sizeof(*new),"parser: string_list_e");
--- 1566,1572 ----
  				d = d->next;
  			}
  		}
! 		;
  string_list_e	: string {
  		struct string_list	*new;
  			new = xmalloc(sizeof(*new),"parser: string_list_e");
***************
*** 1545,1550 ****
--- 1578,1584 ----
  			$$ = new;
  			free($1);
  		}
+ 		;
  domainlist	: domain {
  			struct domain_list *d=$1;
  			verb_printf("<%s>\n", d->domain);
***************
*** 1558,1565 ****
  				verb_printf("<%s>\n", d->domain);
  				d = d->next;
  			}
! 		};
! 
  domain		: STRING {
  			struct	domain_list *new;
  			char		    *s, *d;
--- 1592,1599 ----
  				verb_printf("<%s>\n", d->domain);
  				d = d->next;
  			}
! 		}
! 		;
  domain		: STRING {
  			struct	domain_list *new;
  			char		    *s, *d;
***************
*** 1582,1594 ****
  			new->next = NULL;
  			$$ = new;
  			}
- 
  
  network_list	: network
  		| network network_list {
  			$1->next = $2; $$ = $1;
  		}
! 
  network		: NETWORK {
  			char	*n, *l, *dot, *dot_holder, *t;
  			int	net = 0, masklen = 0, i = 24;
--- 1616,1628 ----
  			new->next = NULL;
  			$$ = new;
  			}
  
+ 		;
  network_list	: network
  		| network network_list {
  			$1->next = $2; $$ = $1;
  		}
! 		;
  network		: NETWORK {
  			char	*n, *l, *dot, *dot_holder, *t;
  			int	net = 0, masklen = 0, i = 24;
***************
*** 1626,1632 ****
  			free(yylval.STRPTR);
  			$$ = new;
  		}
! 
  
  %%
  
--- 1660,1666 ----
  			free(yylval.STRPTR);
  			$$ = new;
  		}
! 		;
  
  %%
  
***************
*** 1737,1742 ****
--- 1771,1777 ----
      }
      yyin = cf;
      atline = 1;
+     conf_file_name = strdup(name);
      ns_curr = 0;
      bzero(&peer_c, sizeof(peer_c));
      peer_c.type  = PEER_SIBLING;
Index: src/run.c
===================================================================
RCS file: /usr/local/cvs/oops/src/run.c,v
retrieving revision 1.43
retrieving revision 1.44
diff -c -r1.43 -r1.44
*** run.c	2001/12/02 09:14:44	1.43
--- run.c	2002/03/16 15:40:01	1.44
***************
*** 122,128 ****
  	return;
      }
  
!     if ( listen(server_so, 128) ) {
  	my_xlog(OOPS_LOG_SEVERE, "run(): Server can't listen: %n\n");
  	my_sleep(5);
  	CLOSE(server_so); server_so = -1;
--- 122,128 ----
  	return;
      }
  
!     if ( listen(server_so, 8196) ) {
  	my_xlog(OOPS_LOG_SEVERE, "run(): Server can't listen: %n\n");
  	my_sleep(5);
  	CLOSE(server_so); server_so = -1;
Index: src/run_client.c
===================================================================
RCS file: /usr/local/cvs/oops/src/run_client.c,v
retrieving revision 1.59
retrieving revision 1.66
diff -c -r1.59 -r1.66
*** run_client.c	2001/12/28 14:06:24	1.59
--- run_client.c	2002/12/16 07:28:17	1.66
***************
*** 21,85 ****
  #include	"oops.h"
  
  #include	"modules.h"
! extern struct	err_module	*err_first;
  
! #define		READ_REQ_TIMEOUT	(10*60)		/* 10 minutes */
  #define		READ_BUFF_SZ		(1500)
  
  #define		REQUEST_EMPTY	0
  #define		REQUEST_READY	1
  
! static	struct	mem_obj*	create_temp_obj(void);
! static	void	destroy_temp_obj(struct mem_obj *obj);
! static	u_short	hash(struct url *url);
! static	void	decrement_clients(void);
! static	void	increment_clients(void);
! static	int	in_stop_cache(struct request *);
! static	void	make_purge(int, struct request *);
! static	int	parse_connect_url(char* src, char *httpv, struct url *url, int so);
! static	int	parse_http_request(char *start, struct request *rq, int so);
! static	void	release_obj(struct mem_obj *);
! 
! inline	static	int	add_request_av(char* avtext, struct request *request);
! inline	static	int	check_headers(struct request *rq, char *beg, char *end, int *checked, int so);
! inline	static	void	free_request(struct request *rq);
! inline	static	void	insert_request_in_hash(struct request *);
! inline	static	void	remove_request_from_hash(struct request *);
! inline	static	void	insert_request_in_ip_hash(struct request *);
! inline	static	void	remove_request_from_ip_hash(struct request *);
  
  
  #if	defined(DEMO)
! static	int	served = 0;
  #endif
  
! void *
! run_client(void *arg)
  {
! u_char			*buf = NULL;
! int			got, rc;
! u_char			*cp, *ip;
! char			*headers;
! struct	request		request;
! time_t			started;
! struct	mem_obj		*stored_url;
! size_t			current_size;
! int			status, checked_len = 0, mod_flags;
! int			mem_send_flags = 0;
! socklen_t		clsalen = sizeof(request.client_sa);
! socklen_t		mysalen = sizeof(request.my_sa);
! struct	group		*group;
! int			miss_denied = TRUE;
! int			so, new_object, redir_mods_visited, auth_mods_visited;
! int			accepted_so;
! struct	work		*work;
! 
!     work = (struct work*)arg;
!     if ( !work ) return(NULL);
      so = work->so;
      accepted_so = work->accepted_so;
!     if ( fcntl(so, F_SETFL, fcntl(so, F_GETFL, 0)|O_NONBLOCK) )
! 	my_xlog(OOPS_LOG_SEVERE, "run_client(): fcntl(): %m\n");
  
      increment_clients();
      set_socket_options(so);
--- 21,86 ----
  #include	"oops.h"
  
  #include	"modules.h"
! extern struct err_module *err_first;
  
! #define		READ_REQ_TIMEOUT	(10*60) /* 10 minutes */
  #define		READ_BUFF_SZ		(1500)
  
  #define		REQUEST_EMPTY	0
  #define		REQUEST_READY	1
  
! static struct mem_obj *create_temp_obj(void);
! static void destroy_temp_obj(struct mem_obj *obj);
! static u_short hash(struct url *url);
! static void decrement_clients(void);
! static void increment_clients(void);
! static int in_stop_cache(struct request *);
! static void make_purge(int, struct request *);
! static void make_purge_site(int, struct request *, struct group *);
! static int parse_connect_url(char *src, char *httpv, struct url *url, int so);
! static int parse_http_request(char *start, struct request *rq, int so);
! static void release_obj(struct mem_obj *);
! 
! inline static int add_request_av(char *avtext, struct request *request);
! inline static int check_headers(struct request *rq, char *beg, char *end, int *checked, int so);
! inline static void free_request(struct request *rq);
! inline static void insert_request_in_hash(struct request *);
! inline static void remove_request_from_hash(struct request *);
! inline static void insert_request_in_ip_hash(struct request *);
! inline static void remove_request_from_ip_hash(struct request *);
  
  
  #if	defined(DEMO)
! static int served = 0;
  #endif
  
! void *run_client(void *arg)
  {
!     u_char *buf = NULL;
!     int got, rc;
!     u_char *cp, *ip;
!     char *headers;
!     struct request request;
!     time_t started;
!     struct mem_obj *stored_url;
!     size_t current_size;
!     int status, checked_len = 0, mod_flags;
!     int mem_send_flags = 0;
!     socklen_t clsalen = sizeof(request.client_sa);
!     socklen_t mysalen = sizeof(request.my_sa);
!     struct group *group;
!     int miss_denied = TRUE;
!     int so, new_object, redir_mods_visited, auth_mods_visited;
!     int accepted_so;
!     struct work *work;
! 
!     work = (struct work *) arg;
!     if (!work)
!         return (NULL);
      so = work->so;
      accepted_so = work->accepted_so;
!     if (fcntl(so, F_SETFL, fcntl(so, F_GETFL, 0) | O_NONBLOCK))
!         my_xlog(OOPS_LOG_SEVERE, "run_client(): fcntl(): %m\n");
  
      increment_clients();
      set_socket_options(so);
***************
*** 88,537 ****
      bzero(&request, sizeof(request));
      request.accepted_so = accepted_so;
      request.so = so;
!     if ( work ) memcpy(&request.client_sa, &work->sa, sizeof(request.client_sa));
!     IF_FREE(work);	/* we don't need it anymore	*/
      work = NULL;
- 
  
!     getsockname(so, (struct sockaddr*)&request.my_sa, &mysalen);
      request.request_time = started = time(NULL);
      insert_request_in_hash(&request);
      insert_request_in_ip_hash(&request);
      redir_mods_visited = FALSE;
!     auth_mods_visited  = FALSE;
      buf = xmalloc(READ_BUFF_SZ, "run_client(): For client request.");
!     if ( !buf ) {
! 	my_xlog(OOPS_LOG_SEVERE, "run_client(): No mem for header!\n");
! 	goto done;
      }
      current_size = READ_BUFF_SZ;
!     cp = buf; ip = buf;
  
      forever() {
! 	got = readt(so, (char*)cp, current_size-(cp-ip), 100);
! 	if ( got == 0 ) {
! 	    my_xlog(OOPS_LOG_FTP|OOPS_LOG_HTTP|OOPS_LOG_DBG, "run_client(): Client closed connection.\n");
! 	    goto done;
! 	}
! 	if ( got == -2 ) {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "Read client input timeout.\n");
! 	    if ( time(NULL) - started > READ_REQ_TIMEOUT ) {
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "run_client(): Client send too slow.\n");
! 		goto done;
! 	    }
! 	    continue;
! 	}
! 	if ( got <  0 ) {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "run_client(): Failed to read from client.\n");
! 	    goto done;
! 	}
! 	cp += got;
! 	if ( (unsigned)(cp - ip) >= current_size ) {
! 	    char *nb = xmalloc(current_size+CHUNK_SIZE, "run_client(): new block");
! 	    /* resize buf */
! 	    if ( !nb ) {
! 		my_xlog(OOPS_LOG_SEVERE, "run_client(): No mem to read request.\n");
! 		goto done;
! 	    }	    
! 	    memcpy(nb, buf, current_size);
! 	    xfree(buf);
! 	    buf=ip=(u_char*)nb;
! 	    cp=ip+current_size;
! 	    *cp=0;
! 	    current_size=current_size+CHUNK_SIZE;
! 	} else
! 	    *cp=0;
! 	status = check_headers(&request, (char*)ip, (char*)cp, &checked_len, so);
! 	if ( status ) {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "run_client(): Failed to check headers.\n");
! 	    say_bad_request(so, "Bad request format.\n", "",
! 		    ERR_BAD_URL, &request);
! 	    goto done;
! 	}
! 	if ( request.state == REQUEST_READY )
! 	    break;
!     }
!     if ( request.headers_off <= 0 ) {
! 	my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "run_client(): Something wrong with headers_off: %d\n", request.headers_off);
! 	goto done;
!     }
!     headers = (char*)buf + request.headers_off;
!     RDLOCK_CONFIG ;
! ck_group:
      group = rq_to_group(&request);
!     if ( ! group ) {
! 	UNLOCK_CONFIG;
! 	say_bad_request(so, "Please contact cachemaster\n", "No group found. Proxy access denied.\n",
! 	    ERR_ACC_DENIED, &request);
! 	my_xlog(OOPS_LOG_SEVERE, "run_client(): No group found. Access banned.\n");
! 	goto done;
      }
      miss_denied = group->miss_deny;
!     if ( (rc = deny_http_access(so, &request, group)) != 0 ) {
! 	UNLOCK_CONFIG ;
! 	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "run_client(): Access banned.\n");
! 	switch ( rc ) {
! 	case ACCESS_PORT:
! 		say_bad_request(so, "<font color=red>Access denied for requestsd port.\n</font>", "",
! 			ERR_BAD_PORT, &request);
! 		break;
! 	case ACCESS_DOMAIN:
! 		say_bad_request(so, "<font color=red>Access denied for requested domain.\n</font>", "",
! 			ERR_ACC_DOMAIN, &request);
! 		break;
! 	case ACCESS_METHOD:
! 		say_bad_request(so, "<font color=red>Access denied for requestsd method.\n</font>", "",
! 			ERR_BAD_PORT, &request);
! 		break;
! 	default:
! 		say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
! 			ERR_ACC_DENIED, &request);
! 		break;
! 	}
! 	IF_STRDUP(request.tag, "TCP_DENIED");
! 	request.code = 555;
! 	log_access(0, &request, NULL);
! 	goto done;
!     }
!     if ( !group ) {
! 	UNLOCK_CONFIG ;
! 	goto done;
!     }
!     if ( group->denytimes && (rc = denytime_check(group->denytimes)) ) {
! 	UNLOCK_CONFIG ;
! 	say_bad_request(so, "<font color=red>Your access to proxy service denied at this time.\n</font>", "",
! 		ERR_ACC_DENIED, &request);
! 	IF_STRDUP(request.tag,"TCP_DENIED");
! 	IF_STRDUP(request.source, "DENY_TIME");
! 	request.code = 555;
! 	log_access(0, &request, NULL);
! 	goto done;
      }
      /* copy redir modules reference to struct request, so we will
         not lookup for group again
!     */
!     if ( !redir_mods_visited ) {
! 	mod_flags = 0;
! 	request.redir_mods = lock_l_mod_call_list(group->redir_mods);
! 	/* check for redirects */
! 	if ( check_redirect(so, &request, group, &mod_flags) ) {
! 	    UNLOCK_CONFIG;
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "run_client(): check_redirect denied.\n");
! 	    IF_STRDUP(request.tag, "TCP_DENIED");
! 	    IF_STRDUP(request.source, "REDIR_MOD");
! 	    request.code = 555;
! 	    log_access(0, &request, NULL);
! 	    goto done;
! 	}
!         if ( TEST(mod_flags, MOD_AFLAG_OUT) ) {
! 	    UNLOCK_CONFIG;
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "run_client(): check_redirect finished req.\n");
! 	    IF_STRDUP(request.tag, "TCP_REDIR");
! 	    IF_STRDUP(request.source, "REDIR_MOD");
! 	    request.code = 555;
! 	    log_access(0, &request, NULL);
! 	    goto done;
!         }
! 	redir_mods_visited = TRUE;
! 	if ( TEST(mod_flags, MOD_AFLAG_CKACC) )
! 	    goto ck_group;	/* we must get group again, as it my-be 
! 				   changed because of redir		*/
!     }
!     if ( !auth_mods_visited ) {
! 	/* time to visit auth modules */
! 	mod_flags = 0;
! 	if ( check_auth(so, &request, group, &mod_flags) == MOD_CODE_ERR) {
! 	    UNLOCK_CONFIG;
! 	    if ( !TEST(mod_flags, MOD_AFLAG_OUT) ) {
! 		/* there was no output */
! 		say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
! 			ERR_ACC_DENIED, &request);
! 	    }
! 	    IF_STRDUP(request.tag, "TCP_DENIED");
! 	    IF_STRDUP(request.source, "AUTH_MOD");
! 	    request.code = 555;
! 	    log_access(0, &request, NULL);
! 	    goto done;
! 	}
! 	auth_mods_visited = TRUE;
! 	if ( TEST(mod_flags, MOD_AFLAG_CKACC) )
! 	    goto ck_group;	/* we must get group again, as it my-be 
! 				   changed because of redir		*/
!     }
! 
!     if ( acl_deny && (check_acl_access(acl_deny, &request) == TRUE) ) {
! 	UNLOCK_CONFIG;
! 	say_bad_request(so, "Please contact cachemaster\n",
! 			     request.matched_acl, ERR_ACL_DENIED, &request);
! 	goto done;
!     }
!     if (   !request.refresh_pattern.valid	/* if not set by redir mods 	*/
! 	   && global_refresh_pattern )		/* and we have global refr_patt	*/
! 
! 	set_refresh_pattern(&request, global_refresh_pattern);
! 
!     if ( group && group->bandwidth )
! 	request.flags |= RQ_HAS_BANDWIDTH;
!     if ( group && group->per_sess_bw )
! 	request.sess_bw = group->per_sess_bw;
!     if ( group && group->per_ip_bw ) {
! 	request.flags |= RQ_HAVE_PER_IP_BW;
! 	request.per_ip_bw = group->per_ip_bw;
      }
      memcpy(&request.conn_from_sa, &connect_from_sa, sizeof(request.conn_from_sa));
!     if ( group && group->conn_from_sa.sin_addr.s_addr ) {
! 	memcpy(&request.conn_from_sa, &group->conn_from_sa, sizeof(request.conn_from_sa));
      }
!     if ( group && ( group->miss_deny == TRUE ) ) {
          request.flags |= RQ_HAS_ONLY_IF_CACHED;
      }
!     if ( request.ip_hash_ptr &&
! 	 group->per_ip_conn &&
! 	 (request.ip_hash_ptr->refcount > group->per_ip_conn) ) {
! 	UNLOCK_CONFIG;
! 	say_bad_request(so, "Please contact cachemaster\n",
! 			     "Connections limit.", ERR_ACC_DENIED, &request);
! 	goto done;
      }
      pthread_mutex_lock(&group->group_mutex);
      group->cs0.requests++;
      pthread_mutex_unlock(&group->group_mutex);
!     if ( group->maxreqrate && (group->cs0.requests > group->maxreqrate) ) {
! 	/* request rate limit reached, drop connection 	*/
! 	/* this is crude and must be used as last resort	*/
! 	UNLOCK_CONFIG ;
! 	goto done;
      }
  
!     UNLOCK_CONFIG ;
  
      /* now:
! 	buf  - contain complete client request
!     */
  
!     if ( request.url.proto && !strcasecmp(request.url.proto, "http") )
! 	request.proto = PROTO_HTTP;
!       else
!     if ( request.url.proto && !strcasecmp(request.url.proto, "ftp") )
! 	request.proto = PROTO_FTP;
!       else
! 	request.proto = PROTO_OTHER;
      /* if request state to send not cached info - send directly from origin */
!     if ( request.meth == METH_CONNECT ) {
! 	if ( miss_denied ) {
! 	    say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
! 		ERR_ACC_DENIED, &request);
! 	    goto done;
! 	}
! 	/* make ssl connect	*/
! 	send_ssl(so, &request);
! 	goto done;
!     }
! 
!     if ( request.meth == METH_PURGE ) {
! 	make_purge(so, &request);
! 	goto done;
!     }
! 
!     if ( !request.url.host || !request.url.host[0] ) {
! 	    say_bad_request(so, "No host part in URL\n", "",
! 		    ERR_BAD_URL, &request);
! 	    goto done;
!     }
! 
!     if ( (request.proto != PROTO_FTP)   && /* ftp processed below */
! 	((!request.meth==METH_GET) 		||
! 	 ( request.flags & RQ_HAS_NO_STORE) 	||
! 	 ( request.flags & RQ_HAS_AUTHORIZATION)||
! 	 ( request.url.login )) ) {
! 	if ( miss_denied ) {
! 	    say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
! 		ERR_ACC_DENIED, &request);
! 	    goto done;
! 	}
! 	send_not_cached(so, &request, headers);
! 	CLOSE(so); so = -1;
! 	goto done;
!     }
!     if ( (request.proto != PROTO_FTP) && !request.refresh_pattern.valid && in_stop_cache(&request) ) {
! 	if ( miss_denied ) {
! 	    say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
! 		ERR_ACC_DENIED, &request);
! 	    goto done;
! 	}
! 	send_not_cached(so, &request, headers);
! 	CLOSE(so); so = -1;
! 	goto done;
!     }
!     if ( request.flags & RQ_HAS_ONLY_IF_CACHED ) {
! 	stored_url = locate_in_mem(&request.url, AND_USE, &new_object, &request);
! 	if ( !stored_url ) {
! 	    send_error(so, 504, "Gateway Timeout. Or not in cache");
! 	    goto done;
! 	}
! 	send_from_mem(so, &request, headers, stored_url, mem_send_flags);
! 	CLOSE(so); so = -1;
! 	leave_obj(stored_url);
! 	goto done;
!     }
! 
!     if ( always_check_freshness && (request.proto == PROTO_HTTP) )
! 	mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!     if ( request.flags & RQ_HAS_NO_CACHE )
! 	mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!     if ( request.flags &
! 	(RQ_HAS_MAX_AGE|RQ_HAS_MAX_STALE|RQ_HAS_MIN_FRESH) ) {
! 	stored_url = locate_in_mem(&request.url, AND_USE|AND_PUT, &new_object, &request);
! 	if ( !stored_url ) {
! 	    my_xlog(OOPS_LOG_SEVERE, "run_client(): Can't create or find memory object.\n");
! 	    say_bad_request(so, "Can't create memory object.\n", "No memory?",
! 	    	ERR_INTERNAL, &request);
! 	    goto done;
! 	}
! 	if ( new_object ) {
! 	    /* it is new object, it probably can be stored	*/
! 	    /* it can be forwarded to client			*/
! 	    goto read_net;
! 	}
! 
! 	if ( !(request.flags & MEM_OBJ_MUST_REVALIDATE) &&
! 	      (request.flags & RQ_HAS_MAX_AGE) ) {
! 	    time_t age = current_obj_age(stored_url);
! 	    if ( age > request.max_age ) {
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	    }
! 	}
! 
! 	if ( !(request.flags & MEM_OBJ_MUST_REVALIDATE) &&
! 	      (request.flags & RQ_HAS_MAX_STALE) ) {
! 	    time_t freshness_lifetime;
! 	    time_t freshness_val = obj_freshness_lifetime(stored_url);
! 	
! 	    if ( freshness_val < 0 ) {
! 		/* this is heuristic */
! 		freshness_lifetime = -freshness_val;
! 		mem_send_flags |= MEM_OBJ_WARNING_113;
! 	    } else
! 		freshness_lifetime = freshness_val;
! 	    if ( freshness_lifetime < request.max_stale ) {
! 		my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "run_client(): Must revalidate: freshness_lifetime = %d, request.max_stale: %d\n",
! 				freshness_lifetime, request.max_stale);
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	    } else {
! 		/* we probably will send stale document - need warning */
! 		if ( freshness_lifetime < current_obj_age(stored_url) )
! 		    mem_send_flags |= MEM_OBJ_WARNING_110;
! 	    }
! 	}
! 
! 	if ( !(request.flags & MEM_OBJ_MUST_REVALIDATE) &&
! 	      (request.flags & RQ_HAS_MAX_STALE) ) {
! 	    time_t freshness_lifetime;
! 	    time_t freshness_val = obj_freshness_lifetime(stored_url);
! 	    if ( freshness_val < 0 ) {
! 		/* this is heuristic */
! 		freshness_lifetime = -freshness_val;
! 		mem_send_flags |= MEM_OBJ_WARNING_113;
! 	    } else
! 		freshness_lifetime = freshness_val;
! 	    if ( freshness_lifetime < current_obj_age(stored_url) + request.min_fresh)
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	}
! 	if ( !TEST(mem_send_flags, MEM_OBJ_MUST_REVALIDATE) 
! 		&& always_check_freshness_acl
! 		&& obj_check_acl_access(always_check_freshness_acl, stored_url, &request) )
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	send_from_mem(so, &request, headers, stored_url, mem_send_flags);
! 	CLOSE(so); so = -1;
! 	leave_obj(stored_url);
! 	goto done;
!     }
!     stored_url = locate_in_mem(&request.url, AND_PUT|AND_USE, &new_object, &request);
!     if ( !stored_url ) {
! 	my_xlog(OOPS_LOG_SEVERE, "run_client(): Can't create or find memory object.\n");
! 	say_bad_request(so, "Can't create memory object.\n", "No memory?",
! 		ERR_INTERNAL, &request);
! 	goto done;
!     }
! 
!     if ( new_object ) {
! read_net:
! 	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "run_client(): read <%s><%s><%d><%s> from the net.\n",
! 		request.url.proto, request.url.host, request.url.port, request.url.path);
! 	if ( miss_denied ) {
! 	    say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
! 		ERR_ACC_DENIED, &request);
! 	    stored_url->flags |= FLAG_DEAD;
! 	} else {
! 	    if ( !strcasecmp(request.url.proto, "ftp") )
! 		ftp_fill_mem_obj(so, &request, headers, stored_url);
! 	    else if ( !strcasecmp(request.url.proto, "http") )
! 		fill_mem_obj(so, &request, headers, stored_url, 0, 0, NULL);
! 	    else {
! 		say_bad_request(so, "Unsupported protocol\n", request.url.proto,
! 		    ERR_BAD_URL, &request);
! 		stored_url->flags |= FLAG_DEAD;
! 	    }
! 	}
! 	CLOSE(so); so = -1;
! 	leave_obj(stored_url);
      } else {
! 	if ( stored_url->flags & ANSW_HAS_MAX_AGE ) {
! 	    time_t age = current_obj_age(stored_url);
! 	    if ( stored_url->times.max_age &&
! 	         (age > stored_url->times.max_age) ) {
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	    }
! 	}
! 	if ( TEST(stored_url->flags, ANSW_HAS_EXPIRES) ) {
! 	     if ( stored_url->times.expires < global_sec_timer )
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	}
! 	if ( !TEST(mem_send_flags, MEM_OBJ_MUST_REVALIDATE) 
! 		&& always_check_freshness_acl
! 		&& obj_check_acl_access(always_check_freshness_acl, stored_url, &request) )
! 		mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
! 	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "run_client(): read <%s:%s:%s> from mem.\n",
! 		request.url.proto, request.url.host, request.url.path);
! 	send_from_mem(so, &request, headers, stored_url, mem_send_flags);
! 	CLOSE(so); so = -1;
          leave_obj(stored_url);
      }
  /*persistent:*/
  
! done:
      IF_FREE(buf);
      remove_request_from_hash(&request);
      free_request(&request);
!     if ( so != -1 ) CLOSE(so);
      decrement_clients();
      LOCK_STATISTICS(oops_stat);
! 	oops_stat.requests_http++;
! 	oops_stat.requests_http0++;
      UNLOCK_STATISTICS(oops_stat);
!     return(NULL);
  }
  
  /* create absolutely empty object	*/
  /* which is not included in any lists	*/
  
! static struct mem_obj*
! create_temp_obj(void)
  {
! struct mem_obj	*obj = NULL;
  
      obj = xmalloc(sizeof(*obj), "create_temp_obj(): 1");
!     if ( !obj )
! 	return(NULL);
      bzero(obj, sizeof(*obj));
      pthread_mutex_init(&obj->lock, NULL);
      pthread_mutex_init(&obj->state_lock, NULL);
      pthread_cond_init(&obj->state_cond, NULL);
!     return(obj);
  }
  
! static void
! destroy_temp_obj(struct mem_obj *obj)
  {
      free_url(&obj->url);
      free_container(obj->container);
--- 89,600 ----
      bzero(&request, sizeof(request));
      request.accepted_so = accepted_so;
      request.so = so;
!     if (work)
!         memcpy(&request.client_sa, &work->sa, sizeof(request.client_sa));
!     IF_FREE(work);              /* we don't need it anymore     */
      work = NULL;
  
!     getsockname(so, (struct sockaddr *) &request.my_sa, &mysalen);
      request.request_time = started = time(NULL);
      insert_request_in_hash(&request);
      insert_request_in_ip_hash(&request);
      redir_mods_visited = FALSE;
!     auth_mods_visited = FALSE;
      buf = xmalloc(READ_BUFF_SZ, "run_client(): For client request.");
!     if (!buf) {
!         my_xlog(OOPS_LOG_SEVERE, "run_client(): No mem for header!\n");
!         goto done;
!     }
!     /*
!      * check per_ip_connects here to block attacks
!      */
!     RDLOCK_CONFIG;
!     group = rq_to_group(&request);
!     if (group && request.ip_hash_ptr && group->per_ip_conn) {
!         if (request.ip_hash_ptr->refcount > group->per_ip_conn) {
!             UNLOCK_CONFIG;
!             say_bad_request(so, "Please contact cachemaster\n",
!                             "Connections limit.", ERR_ACC_DENIED, &request);
!             goto done;
!         }
      }
+     UNLOCK_CONFIG;
+ 
      current_size = READ_BUFF_SZ;
!     cp = buf;
!     ip = buf;
  
      forever() {
!         got = readt(so, (char *) cp, current_size - (cp - ip), 100);
!         if (got == 0) {
!             my_xlog(OOPS_LOG_FTP | OOPS_LOG_HTTP | OOPS_LOG_DBG,
!                     "run_client(): Client closed connection.\n");
!             goto done;
!         }
!         if (got == -2) {
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG, "Read client input timeout.\n");
!             if (time(NULL) - started > READ_REQ_TIMEOUT) {
!                 my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG,
!                         "run_client(): Client send too slow.\n");
!                 goto done;
!             }
!             continue;
!         }
!         if (got < 0) {
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG,
!                     "run_client(): Failed to read from client.\n");
!             goto done;
!         }
!         cp += got;
!         if ((unsigned) (cp - ip) >= current_size) {
!             char *nb = xmalloc(current_size + CHUNK_SIZE, "run_client(): new block");
!             /* resize buf */
!             if (!nb) {
!                 my_xlog(OOPS_LOG_SEVERE, "run_client(): No mem to read request.\n");
!                 goto done;
!             }
!             memcpy(nb, buf, current_size);
!             xfree(buf);
!             buf = ip = (u_char *) nb;
!             cp = ip + current_size;
!             *cp = 0;
!             current_size = current_size + CHUNK_SIZE;
!         } else
!             *cp = 0;
!         status = check_headers(&request, (char *) ip, (char *) cp, &checked_len, so);
!         if (status) {
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG,
!                     "run_client(): Failed to check headers.\n");
!             say_bad_request(so, "Bad request format.\n", "", ERR_BAD_URL, &request);
!             goto done;
!         }
!         if (request.state == REQUEST_READY)
!             break;
!     }
!     if (request.headers_off <= 0) {
!         my_xlog(OOPS_LOG_NOTICE | OOPS_LOG_DBG | OOPS_LOG_INFORM,
!                 "run_client(): Something wrong with headers_off: %d\n", request.headers_off);
!         goto done;
!     }
!     headers = (char *) buf + request.headers_off;
!     /*
!      * Time to check dst_ip. Currently we use resolver only BEFORE redirector.
!      * If we can take destination from URI, then resolve it.
!      * otherwise we have to take it from Host:
!      */
!     if (dst_ip_acl_present) {
!         if (request.url.host) {
!             str_to_sa(request.url.host, (struct sockaddr *) &request.dst_sa);
!         } else {
!             char *h = attr_value(request.av_pairs, "host");
!             if (h) {
!                 str_to_sa(h, (struct sockaddr *) &request.dst_sa);
!             }
!         }
!     }
!     /*
!      * done
!      */
!     RDLOCK_CONFIG;
!   ck_group:
      group = rq_to_group(&request);
!     if (!group) {
!         UNLOCK_CONFIG;
!         say_bad_request(so, "Please contact cachemaster\n",
!                         "No group found. Proxy access denied.\n", ERR_ACC_DENIED, &request);
!         my_xlog(OOPS_LOG_SEVERE, "run_client(): No group found. Access banned.\n");
!         goto done;
      }
      miss_denied = group->miss_deny;
!     if ((rc = deny_http_access(so, &request, group)) != 0) {
!         UNLOCK_CONFIG;
!         my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG, "run_client(): Access banned.\n");
!         switch (rc) {
!         case ACCESS_PORT:
!             say_bad_request(so, "<font color=red>Access denied for requestsd port.\n</font>", "",
!                             ERR_BAD_PORT, &request);
!             break;
!         case ACCESS_DOMAIN:
!             say_bad_request(so, "<font color=red>Access denied for requested domain.\n</font>", "",
!                             ERR_ACC_DOMAIN, &request);
!             break;
!         case ACCESS_METHOD:
!             say_bad_request(so, "<font color=red>Access denied for requestsd method.\n</font>", "",
!                             ERR_BAD_PORT, &request);
!             break;
!         default:
!             say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
!                             ERR_ACC_DENIED, &request);
!             break;
!         }
!         IF_STRDUP(request.tag, "TCP_DENIED");
!         request.code = 555;
!         log_access(0, &request, NULL);
!         goto done;
!     }
!     if (!group) {
!         UNLOCK_CONFIG;
!         goto done;
!     }
!     if (group->denytimes && (rc = denytime_check(group->denytimes))) {
!         UNLOCK_CONFIG;
!         say_bad_request(so,
!                         "<font color=red>Your access to proxy service denied at this time.\n</font>",
!                         "", ERR_ACC_DENIED, &request);
!         IF_STRDUP(request.tag, "TCP_DENIED");
!         IF_STRDUP(request.source, "DENY_TIME");
!         request.code = 555;
!         log_access(0, &request, NULL);
!         goto done;
      }
      /* copy redir modules reference to struct request, so we will
         not lookup for group again
!      */
!     if (!redir_mods_visited) {
!         mod_flags = 0;
!         request.redir_mods = lock_l_mod_call_list(group->redir_mods);
!         /* check for redirects */
!         if (check_redirect(so, &request, group, &mod_flags)) {
!             UNLOCK_CONFIG;
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_DBG, "run_client(): check_redirect denied.\n");
!             IF_STRDUP(request.tag, "TCP_DENIED");
!             IF_STRDUP(request.source, "REDIR_MOD");
!             request.code = 555;
!             log_access(0, &request, NULL);
!             goto done;
!         }
!         if (TEST(mod_flags, MOD_AFLAG_OUT)) {
!             UNLOCK_CONFIG;
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_DBG, "run_client(): check_redirect finished req.\n");
!             IF_STRDUP(request.tag, "TCP_REDIR");
!             IF_STRDUP(request.source, "REDIR_MOD");
!             request.code = 555;
!             log_access(0, &request, NULL);
!             goto done;
!         }
!         redir_mods_visited = TRUE;
!         if (TEST(mod_flags, MOD_AFLAG_CKACC))
!             goto ck_group;      /* we must get group again, as it my-be 
!                                    changed because of redir             */
!     }
!     if (!auth_mods_visited) {
!         /* time to visit auth modules */
!         mod_flags = 0;
!         if (check_auth(so, &request, group, &mod_flags) == MOD_CODE_ERR) {
!             UNLOCK_CONFIG;
!             if (!TEST(mod_flags, MOD_AFLAG_OUT)) {
!                 /* there was no output */
!                 say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
!                                 ERR_ACC_DENIED, &request);
!             }
!             IF_STRDUP(request.tag, "TCP_DENIED");
!             IF_STRDUP(request.source, "AUTH_MOD");
!             request.code = 555;
!             log_access(0, &request, NULL);
!             goto done;
!         }
!         auth_mods_visited = TRUE;
!         if (TEST(mod_flags, MOD_AFLAG_CKACC))
!             goto ck_group;      /* we must get group again, as it my-be 
!                                    changed because of redir             */
!     }
! 
!     if (acl_deny && (check_acl_access(acl_deny, &request) == TRUE)) {
!         UNLOCK_CONFIG;
!         say_bad_request(so, "Please contact cachemaster\n",
!                         request.matched_acl, ERR_ACL_DENIED, &request);
!         goto done;
!     }
!     if (!request.refresh_pattern.valid  /* if not set by redir mods     */
!         && global_refresh_pattern)
!         /* and we have global refr_patt     */
!         set_refresh_pattern(&request, global_refresh_pattern);
! 
!     if (group && group->bandwidth)
!         request.flags |= RQ_HAS_BANDWIDTH;
!     if (group && group->per_sess_bw)
!         request.sess_bw = group->per_sess_bw;
!     if (group && group->per_ip_bw) {
!         request.flags |= RQ_HAVE_PER_IP_BW;
!         request.per_ip_bw = group->per_ip_bw;
      }
      memcpy(&request.conn_from_sa, &connect_from_sa, sizeof(request.conn_from_sa));
!     if (group && group->conn_from_sa.sin_addr.s_addr) {
!         memcpy(&request.conn_from_sa, &group->conn_from_sa, sizeof(request.conn_from_sa));
      }
!     if (group && (group->miss_deny == TRUE)) {
          request.flags |= RQ_HAS_ONLY_IF_CACHED;
      }
!     if (request.ip_hash_ptr &&
!         group->per_ip_conn && (request.ip_hash_ptr->refcount > group->per_ip_conn)) {
!         UNLOCK_CONFIG;
!         say_bad_request(so, "Please contact cachemaster\n",
!                         "Connections limit.", ERR_ACC_DENIED, &request);
!         goto done;
      }
      pthread_mutex_lock(&group->group_mutex);
      group->cs0.requests++;
      pthread_mutex_unlock(&group->group_mutex);
!     if (group->maxreqrate && (group->cs0.requests > group->maxreqrate)) {
!         /* request rate limit reached, drop connection  */
!         /* this is crude and must be used as last resort        */
!         UNLOCK_CONFIG;
!         goto done;
      }
  
!     UNLOCK_CONFIG;
  
      /* now:
!        buf  - contain complete client request
!      */
  
!     if (request.url.proto && !strcasecmp(request.url.proto, "http"))
!         request.proto = PROTO_HTTP;
!     else if (request.url.proto && !strcasecmp(request.url.proto, "ftp"))
!         request.proto = PROTO_FTP;
!     else
!         request.proto = PROTO_OTHER;
      /* if request state to send not cached info - send directly from origin */
!     if (request.meth == METH_CONNECT) {
!         if (miss_denied) {
!             say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
!                             ERR_ACC_DENIED, &request);
!             goto done;
!         }
!         /* make ssl connect     */
!         send_ssl(so, &request);
!         goto done;
!     }
! 
!     if (request.meth == METH_PURGE) {
!         make_purge(so, &request);
!         goto done;
!     }
!     if ((request.meth == METH_PURGE_SITE) || (request.meth == METH_PURGE_SITE_R)) {
!         make_purge_site(so, &request, group);
!         goto done;
!     }
! 
!     if (!request.url.host || !request.url.host[0]) {
!         say_bad_request(so, "No host part in URL\n", "", ERR_BAD_URL, &request);
!         goto done;
!     }
! 
!     if ((request.proto != PROTO_FTP) && /* ftp processed below */
!         ((!request.meth == METH_GET) ||
!          (request.flags & RQ_HAS_NO_STORE) ||
!          (request.flags & RQ_HAS_AUTHORIZATION) || (request.url.login))) {
!         if (miss_denied) {
!             say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
!                             ERR_ACC_DENIED, &request);
!             goto done;
!         }
!         send_not_cached(so, &request, headers);
!         CLOSE(so);
!         so = -1;
!         goto done;
!     }
!     if ((request.proto != PROTO_FTP) && !request.refresh_pattern.valid && in_stop_cache(&request)) {
!         if (miss_denied) {
!             say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
!                             ERR_ACC_DENIED, &request);
!             goto done;
!         }
!         send_not_cached(so, &request, headers);
!         CLOSE(so);
!         so = -1;
!         goto done;
!     }
!     if (request.flags & RQ_HAS_ONLY_IF_CACHED) {
!         stored_url = locate_in_mem(&request.url, AND_USE, &new_object, &request);
!         if (!stored_url) {
!             send_error(so, 504, "Gateway Timeout. Or not in cache");
!             goto done;
!         }
!         send_from_mem(so, &request, headers, stored_url, mem_send_flags);
!         CLOSE(so);
!         so = -1;
!         leave_obj(stored_url);
!         goto done;
!     }
! 
!     if (always_check_freshness && (request.proto == PROTO_HTTP))
!         mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!     if (request.flags & RQ_HAS_NO_CACHE)
!         mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!     if (request.flags & (RQ_HAS_MAX_AGE | RQ_HAS_MAX_STALE | RQ_HAS_MIN_FRESH)) {
! find_object_0:
!         stored_url = locate_in_mem(&request.url, AND_USE | AND_PUT, &new_object, &request);
!         if (!stored_url) {
!             my_xlog(OOPS_LOG_SEVERE, "run_client(): Can't create or find memory object.\n");
!             say_bad_request(so, "Can't create memory object.\n", "No memory?",
!                             ERR_INTERNAL, &request);
!             goto done;
!         }
!         if (new_object) {
!             /* it is new object, it probably can be stored      */
!             /* it can be forwarded to client                    */
!             goto read_net;
!         }
! 
!         if (!(request.flags & MEM_OBJ_MUST_REVALIDATE) && (request.flags & RQ_HAS_MAX_AGE)) {
!             time_t age = current_obj_age(stored_url);
!             if (age > request.max_age) {
!                 mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!             }
!         }
! 
!         if (!(request.flags & MEM_OBJ_MUST_REVALIDATE) && (request.flags & RQ_HAS_MAX_STALE)) {
!             time_t freshness_lifetime;
!             time_t freshness_val = obj_freshness_lifetime(stored_url);
! 
!             if (freshness_val < 0) {
!                 /* this is heuristic */
!                 freshness_lifetime = -freshness_val;
!                 mem_send_flags |= MEM_OBJ_WARNING_113;
!             } else
!                 freshness_lifetime = freshness_val;
!             if (freshness_lifetime < request.max_stale) {
!                 my_xlog(OOPS_LOG_NOTICE | OOPS_LOG_DBG | OOPS_LOG_INFORM,
!                         "run_client(): Must revalidate: freshness_lifetime = %d, request.max_stale: %d\n",
!                         freshness_lifetime, request.max_stale);
!                 mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!             } else {
!                 /* we probably will send stale document - need warning */
!                 if (freshness_lifetime < current_obj_age(stored_url))
!                     mem_send_flags |= MEM_OBJ_WARNING_110;
!             }
!         }
! 
!         if (!(request.flags & MEM_OBJ_MUST_REVALIDATE) && (request.flags & RQ_HAS_MAX_STALE)) {
!             time_t freshness_lifetime;
!             time_t freshness_val = obj_freshness_lifetime(stored_url);
!             if (freshness_val < 0) {
!                 /* this is heuristic */
!                 freshness_lifetime = -freshness_val;
!                 mem_send_flags |= MEM_OBJ_WARNING_113;
!             } else
!                 freshness_lifetime = freshness_val;
!             if (freshness_lifetime < current_obj_age(stored_url) + request.min_fresh)
!                 mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!         }
!         if (!TEST(mem_send_flags, MEM_OBJ_MUST_REVALIDATE)
!             && always_check_freshness_acl
!             && obj_check_acl_access(always_check_freshness_acl, stored_url, &request))
!             mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!         /* here we process SITE_PURGE option from accel.c */
!         if ( request.site_purged > stored_url->times.date ) {
!             /* kill this object */
!             stored_url->flags |= FLAG_DEAD;
!             leave_obj(stored_url);
!             /* and find it again */
!             goto find_object_0;
!         }
!         send_from_mem(so, &request, headers, stored_url, mem_send_flags);
!         CLOSE(so);
!         so = -1;
!         leave_obj(stored_url);
!         goto done;
!     }
! 
! find_object_1:
! 
!     stored_url = locate_in_mem(&request.url, AND_PUT | AND_USE, &new_object, &request);
!     if (!stored_url) {
!         my_xlog(OOPS_LOG_SEVERE, "run_client(): Can't create or find memory object.\n");
!         say_bad_request(so, "Can't create memory object.\n", "No memory?", ERR_INTERNAL, &request);
!         goto done;
!     }
! 
!     if (new_object) {
!       read_net:
!         my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG,
!                 "run_client(): read <%s><%s><%d><%s> from the net.\n", request.url.proto,
!                 request.url.host, request.url.port, request.url.path);
!         if (miss_denied) {
!             say_bad_request(so, "Please contact cachemaster\n", "Proxy access denied.\n",
!                             ERR_ACC_DENIED, &request);
!             stored_url->flags |= FLAG_DEAD;
!         } else {
!             if (!strcasecmp(request.url.proto, "ftp"))
!                 ftp_fill_mem_obj(so, &request, headers, stored_url);
!             else if (!strcasecmp(request.url.proto, "http"))
!                 fill_mem_obj(so, &request, headers, stored_url, 0, 0, NULL);
!             else {
!                 say_bad_request(so, "Unsupported protocol\n", request.url.proto,
!                                 ERR_BAD_URL, &request);
!                 stored_url->flags |= FLAG_DEAD;
!             }
!         }
!         CLOSE(so);
!         so = -1;
!         leave_obj(stored_url);
      } else {
!         if (stored_url->flags & ANSW_HAS_MAX_AGE) {
!             time_t age = current_obj_age(stored_url);
!             if (stored_url->times.max_age && (age > stored_url->times.max_age)) {
!                 mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!             }
!         }
!         if (TEST(stored_url->flags, ANSW_HAS_EXPIRES)) {
!             if (stored_url->times.expires < global_sec_timer)
!                 mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!         }
!         if (!TEST(mem_send_flags, MEM_OBJ_MUST_REVALIDATE)
!             && always_check_freshness_acl
!             && obj_check_acl_access(always_check_freshness_acl, stored_url, &request))
!             mem_send_flags |= MEM_OBJ_MUST_REVALIDATE;
!         /* here we process SITE_PURGE option from accel.c */
!         if (!TEST(mem_send_flags, MEM_OBJ_MUST_REVALIDATE)
!              && (request.site_purged > stored_url->times.date)) {
!             /* kill this object */
!             stored_url->flags |= FLAG_DEAD;
!             leave_obj(stored_url);
!             /* and find it again */
!             goto find_object_1;
!         }
!         my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG,
!                 "run_client(): read <%s:%s:%s> from mem.\n", request.url.proto, request.url.host,
!                 request.url.path);
!         send_from_mem(so, &request, headers, stored_url, mem_send_flags);
!         CLOSE(so);
!         so = -1;
          leave_obj(stored_url);
      }
  /*persistent:*/
  
!   done:
      IF_FREE(buf);
      remove_request_from_hash(&request);
      free_request(&request);
!     if (so != -1)
!         CLOSE(so);
      decrement_clients();
      LOCK_STATISTICS(oops_stat);
!     oops_stat.requests_http++;
!     oops_stat.requests_http0++;
      UNLOCK_STATISTICS(oops_stat);
!     return (NULL);
  }
  
  /* create absolutely empty object	*/
  /* which is not included in any lists	*/
  
! static struct mem_obj *create_temp_obj(void)
  {
!     struct mem_obj *obj = NULL;
  
      obj = xmalloc(sizeof(*obj), "create_temp_obj(): 1");
!     if (!obj)
!         return (NULL);
      bzero(obj, sizeof(*obj));
      pthread_mutex_init(&obj->lock, NULL);
      pthread_mutex_init(&obj->state_lock, NULL);
      pthread_cond_init(&obj->state_cond, NULL);
!     return (obj);
  }
  
! static void destroy_temp_obj(struct mem_obj *obj)
  {
      free_url(&obj->url);
      free_container(obj->container);
***************
*** 542,552 ****
      xfree(obj);
  }
  
! void
! unlink_obj(struct mem_obj *obj)
  {
!     if ( obj->prev ) obj->prev->next=obj->next;
!     if ( obj->next ) obj->next->prev=obj->prev;
  /*    if ( obj->older )
  	obj->older->younger = obj->younger;
      if ( obj->younger )
--- 605,616 ----
      xfree(obj);
  }
  
! void unlink_obj(struct mem_obj *obj)
  {
!     if (obj->prev)
!         obj->prev->next = obj->next;
!     if (obj->next)
!         obj->next->prev = obj->prev;
  /*    if ( obj->older )
  	obj->older->younger = obj->younger;
      if ( obj->younger )
***************
*** 562,575 ****
      obj->hash_back = NULL;
      obj->prev = obj->next
  /*  =  obj->older = obj->younger */
!     = NULL;
  }
  
! void
! destroy_obj(struct mem_obj *obj)
  {
!     if ( obj->prev ) obj->prev->next=obj->next;
!     if ( obj->next ) obj->next->prev=obj->prev;
  /*    if ( obj->older )
  	obj->older->younger = obj->younger;
      if ( obj->younger )
--- 626,640 ----
      obj->hash_back = NULL;
      obj->prev = obj->next
  /*  =  obj->older = obj->younger */
!         = NULL;
  }
  
! void destroy_obj(struct mem_obj *obj)
  {
!     if (obj->prev)
!         obj->prev->next = obj->next;
!     if (obj->next)
!         obj->next->prev = obj->prev;
  /*    if ( obj->older )
  	obj->older->younger = obj->younger;
      if ( obj->younger )
***************
*** 595,711 ****
      xfree(obj);
  }
  
! struct mem_obj*
! locate_in_mem(struct url *url, int flags, int *new_object, struct request *rq)
  {
! struct	mem_obj	*obj=NULL;
! u_short 	url_hash = hash(url);
! int		found=0, mod_flags = 0;
  
!     if ( new_object ) *new_object = FALSE;
      MY_TNF_PROBE_0(obj_chain_lock_start, "contention", "obj_chain_lock begin")
  /*    if ( pthread_mutex_lock(&obj_chain) ) {
  	fprintf(stderr, "locate_in_mem(): Failed mutex lock.\n");
  	return(NULL);
      }
  */
!     MY_TNF_PROBE_0(obj_chain_lock_stop, "contention", "obj_chain_lock end")
!     /* lock hash entry */
!     if ( pthread_mutex_lock(&hash_table[url_hash].lock) ) {
! 	fprintf(stderr, "locate_in_mem(): Failed mutex lock\n");
  /*	pthread_mutex_unlock(&obj_chain);*/
! 	return(NULL);
      }
! 	obj=hash_table[url_hash].next;
! 	if ( !(flags & PUT_NEW_ANYWAY) ) while(obj) {
! 	    if ( (url->port==obj->url.port) &&
! 	         !strcmp(url->path, obj->url.path) &&
! 	         !strcasecmp(url->host, obj->url.host) &&
! 	         !strcasecmp(url->proto, obj->url.proto) &&
! 	         !(obj->flags & (FLAG_DEAD|ANSW_NO_CACHE)) &&
! 		 (!TEST(flags, READY_ONLY) || (obj->state==OBJ_READY) )
! 		    && ( rq && (check_headers_match(obj, rq, &mod_flags) == MOD_CODE_OK) )
! 	         ) {
! 
! 		    found=1;
! 		    if (  flags & AND_USE ) {
! 			if ( pthread_mutex_lock(&obj->lock) ) {
! 			    pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*			    pthread_mutex_unlock(&obj_chain);*/
! 			    return(NULL);
! 			}
! 			obj->refs++;
! 			pthread_mutex_unlock(&obj->lock);
! 		    }
! 		    obj->last_access = global_sec_timer;
! 		    obj->accessed += 1;
! 		    obj->rate = obj_rate(obj);
! 		    pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*		    pthread_mutex_unlock(&obj_chain);*/
! 		    return(obj);
! 		}
! 	    obj=obj->next;
! 	}
! 	if ( !found && ( flags & AND_PUT ) ) {
! 		/* need to insert */
! 		obj = xmalloc(sizeof(struct mem_obj), "locate_in_mem(): for object");
! 		if ( obj ) {
! 		    bzero(obj, sizeof(struct mem_obj));
! 		    obj->created = global_sec_timer;
! 		    obj->last_access = global_sec_timer;
! 		    obj->accessed = 1;
! 		    obj->rate = 0;
! 		    /* copy url */
! 		    obj->url.port = url->port;
! 		    obj->url.proto = xmalloc(strlen(url->proto)+1, "locate_in_mem(): for obj->url.proto");
! 		    if ( obj->url.proto ) {
! 			strcpy(obj->url.proto, url->proto);
! 		    } else {
! 			xfree(obj); obj = NULL;
! 			goto done;
! 		    }
! 		    obj->url.host = xmalloc(strlen(url->host)+1, "locate_in_mem(): for obj->url.host");
! 		    if ( obj->url.host ) {
! 			strcpy(obj->url.host, url->host);
! 		    } else {
! 			xfree(obj->url.proto);
! 			xfree(obj); obj = NULL;
! 			goto done;
! 		    }
! 		    obj->url.path = xmalloc(strlen(url->path)+1, "locate_in_mem(): for obj->url.path");
! 		    if ( obj->url.path ) {
! 			strcpy(obj->url.path, url->path);
! 		    } else {
! 			xfree(obj->url.proto);
! 			xfree(obj->url.host);
! 			xfree(obj); obj = NULL;
! 			goto done;
! 		    }
! 		    obj->url.httpv = xmalloc(strlen(url->httpv)+1, "locate_in_mem(): locate_in_mem4");
! 		    if ( obj->url.httpv ) {
! 			strcpy(obj->url.httpv, url->httpv);
! 		    } else {
! 			xfree(obj->url.proto);
! 			xfree(obj->url.host);
! 			xfree(obj->url.path);
! 			xfree(obj); obj = NULL;
! 			goto done;
! 		    }
! 		    found = 1;
! 		    pthread_mutex_init(&obj->lock, NULL);
! 		    pthread_mutex_init(&obj->state_lock, NULL);
! 		    pthread_cond_init(&obj->state_cond, NULL);
! 		    pthread_mutex_init(&obj->decision_lock, NULL);
! 		    pthread_cond_init(&obj->decision_cond, NULL);
! 		    if ( new_object ) *new_object = TRUE;
! 		    obj->next    = hash_table[url_hash].next;
! 		    obj->prev    = (struct mem_obj*)&hash_table[url_hash];
! 		    obj->flags  |= ANSW_NO_CACHE; /* we dont know yet if obj is cachable */
! 		    obj->decision_done = TRUE;
! 		    obj->writers = 1;
! 		    if (obj->next) obj->next->prev = obj;
! 		    hash_table[url_hash].next=obj;
! 		    obj->hash_back = &hash_table[url_hash];
  /*		    if ( youngest_obj) {
  			obj->older = youngest_obj;
  			youngest_obj->younger = obj;
--- 660,783 ----
      xfree(obj);
  }
  
! struct mem_obj *locate_in_mem(struct url *url, int flags, int *new_object, struct request *rq)
  {
!     struct mem_obj *obj = NULL;
!     u_short url_hash = hash(url);
!     int found = 0, mod_flags = 0;
  
!     if (new_object)
!         *new_object = FALSE;
      MY_TNF_PROBE_0(obj_chain_lock_start, "contention", "obj_chain_lock begin")
  /*    if ( pthread_mutex_lock(&obj_chain) ) {
  	fprintf(stderr, "locate_in_mem(): Failed mutex lock.\n");
  	return(NULL);
      }
  */
!         MY_TNF_PROBE_0(obj_chain_lock_stop, "contention", "obj_chain_lock end")
!         /* lock hash entry */
!         if (pthread_mutex_lock(&hash_table[url_hash].lock)) {
!         fprintf(stderr, "locate_in_mem(): Failed mutex lock\n");
  /*	pthread_mutex_unlock(&obj_chain);*/
!         return (NULL);
      }
!     obj = hash_table[url_hash].next;
!     if (!(flags & PUT_NEW_ANYWAY))
!         while (obj) {
!             if ((url->port == obj->url.port) &&
!                 !strcmp(url->path, obj->url.path) &&
!                 !strcasecmp(url->host, obj->url.host) &&
!                 !strcasecmp(url->proto, obj->url.proto) &&
!                 !(obj->flags & (FLAG_DEAD | ANSW_NO_CACHE)) &&
!                 (!TEST(flags, READY_ONLY) || (obj->state == OBJ_READY))
!                 && (rq && (check_headers_match(obj, rq, &mod_flags) == MOD_CODE_OK))
!                 ) {
! 
!                 found = 1;
!                 if (flags & AND_USE) {
!                     if (pthread_mutex_lock(&obj->lock)) {
!                         pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*			    pthread_mutex_unlock(&obj_chain);*/
!                         return (NULL);
!                     }
!                     obj->refs++;
!                     pthread_mutex_unlock(&obj->lock);
!                 }
!                 obj->last_access = global_sec_timer;
!                 obj->accessed += 1;
!                 obj->rate = obj_rate(obj);
!                 pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*		    pthread_mutex_unlock(&obj_chain);*/
!                 return (obj);
!             }
!             obj = obj->next;
!         }
!     if (!found && (flags & AND_PUT)) {
!         /* need to insert */
!         obj = xmalloc(sizeof(struct mem_obj), "locate_in_mem(): for object");
!         if (obj) {
!             bzero(obj, sizeof(struct mem_obj));
!             obj->created = global_sec_timer;
!             obj->last_access = global_sec_timer;
!             obj->accessed = 1;
!             obj->rate = 0;
!             /* copy url */
!             obj->url.port = url->port;
!             obj->url.proto = xmalloc(strlen(url->proto) + 1, "locate_in_mem(): for obj->url.proto");
!             if (obj->url.proto) {
!                 strcpy(obj->url.proto, url->proto);
!             } else {
!                 xfree(obj);
!                 obj = NULL;
!                 goto done;
!             }
!             obj->url.host = xmalloc(strlen(url->host) + 1, "locate_in_mem(): for obj->url.host");
!             if (obj->url.host) {
!                 strcpy(obj->url.host, url->host);
!             } else {
!                 xfree(obj->url.proto);
!                 xfree(obj);
!                 obj = NULL;
!                 goto done;
!             }
!             obj->url.path = xmalloc(strlen(url->path) + 1, "locate_in_mem(): for obj->url.path");
!             if (obj->url.path) {
!                 strcpy(obj->url.path, url->path);
!             } else {
!                 xfree(obj->url.proto);
!                 xfree(obj->url.host);
!                 xfree(obj);
!                 obj = NULL;
!                 goto done;
!             }
!             obj->url.httpv = xmalloc(strlen(url->httpv) + 1, "locate_in_mem(): locate_in_mem4");
!             if (obj->url.httpv) {
!                 strcpy(obj->url.httpv, url->httpv);
!             } else {
!                 xfree(obj->url.proto);
!                 xfree(obj->url.host);
!                 xfree(obj->url.path);
!                 xfree(obj);
!                 obj = NULL;
!                 goto done;
!             }
!             found = 1;
!             pthread_mutex_init(&obj->lock, NULL);
!             pthread_mutex_init(&obj->state_lock, NULL);
!             pthread_cond_init(&obj->state_cond, NULL);
!             pthread_mutex_init(&obj->decision_lock, NULL);
!             pthread_cond_init(&obj->decision_cond, NULL);
!             if (new_object)
!                 *new_object = TRUE;
!             obj->next = hash_table[url_hash].next;
!             obj->prev = (struct mem_obj *) &hash_table[url_hash];
!             obj->flags |= ANSW_NO_CACHE;        /* we dont know yet if obj is cachable */
!             obj->decision_done = TRUE;
!             obj->writers = 1;
!             if (obj->next)
!                 obj->next->prev = obj;
!             hash_table[url_hash].next = obj;
!             obj->hash_back = &hash_table[url_hash];
  /*		    if ( youngest_obj) {
  			obj->older = youngest_obj;
  			youngest_obj->younger = obj;
***************
*** 715,1510 ****
  		       oldest_obj = obj;
  		    }
  */
! 		    if ( found && ( flags & AND_USE ) ) {
! 			pthread_mutex_lock(&obj->lock);
! 			obj->refs++;
! 			pthread_mutex_unlock(&obj->lock);
! 		    }
! 		    ++total_objects;
! 		    pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*		    pthread_mutex_unlock(&obj_chain);*/
! 		    /* now try to load obj from disk */
! 		    if ( !(flags & NO_DISK_LOOKUP) ) {
! 			int			rc, resident_size;
! 			struct	disk_ref	*disk_ref;
! 			struct	storage_st	*storage;
! 			RDLOCK_CONFIG;
  #if     !defined(USE_INTERNAL_DB_LOCKS)
! 			RDLOCK_DB;
  #endif
!                         MY_TNF_PROBE_0(locate_url_on_disk_start, "contention", "obj_chain_lock begin");
! 			rc = locate_url_on_disk(url, &disk_ref);
!                         MY_TNF_PROBE_0(locate_url_on_disk_stop, "contention", "obj_chain_lock begin");
! 			if ( rc >= 0 && disk_ref ) {
! 			    /* it is on disk */
! 			    storage = locate_storage_by_id(disk_ref->id);
! 			    if ( storage && (storage->flags&ST_READY) ) {
! 				my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_STOR|OOPS_LOG_DBG, "locate_in_mem(): Found on disk: %s\n", storage->path);
! 				/* order important. flags must be changed
! 				   when all done
! 				*/
! 				obj->disk_ref = disk_ref ;
! 				if ( new_object ) *new_object = FALSE;
! 				obj->writers = 0; /* like old object */
!                                 MY_TNF_PROBE_0(load_obj_from_disk_start, "contention", "obj_chain_lock begin");
! 				if ( load_obj_from_disk(obj, disk_ref) ) {
!                                     MY_TNF_PROBE_0(load_obj_from_disk_stop, "contention", "obj_chain_lock begin");
! 				    obj->disk_ref = NULL ;
! 				    if ( new_object ) *new_object = TRUE ;
! 				    obj->writers = 1; /* like old object */
! 				    xfree(disk_ref);
! 				    goto nf;
! 				}
!                                 MY_TNF_PROBE_0(load_obj_from_disk_stop, "contention", "obj_chain_lock begin");
! 				/* ok, obj was loaded */
! 				resident_size = calculate_resident_size(obj);
!         			obj->resident_size = resident_size;
!                 		increase_hash_size(obj->hash_back, obj->resident_size);
! 				if ( !strcasecmp(url->proto,"ftp") ) obj->doc_type = FTP_DOC;
! 				SET(obj->flags, FLAG_FROM_DISK);
! 				if ( rq && (check_headers_match(obj, rq, &mod_flags) != MOD_CODE_OK) ) {
! 				    /* obj don't match request	*/
! 				    struct	mem_obj	*n_obj;
! 
! 				    if ( new_object ) *new_object = TRUE ;
! 				    SET(obj->flags, FLAG_DEAD);
  #if     !defined(USE_INTERNAL_DB_LOCKS)
! 				    UNLOCK_DB;
  #endif
! 				    UNLOCK_CONFIG ;
! 				    leave_obj(obj);
! 				    n_obj = locate_in_mem(&rq->url,
! 					AND_PUT|AND_USE|PUT_NEW_ANYWAY|NO_DISK_LOOKUP, NULL, NULL);
! 				    /* old content will be dead */
! 				    return(n_obj);
! 				} else
! 				    CLR(obj->flags, ANSW_NO_CACHE);
! 				pthread_cond_broadcast(&obj->decision_cond);
! 			    }
! 			} else {
! 			    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_DBG, "locate_in_mem(): Not found.\n");
! 			}
! 		nf:
  #if     !defined(USE_INTERNAL_DB_LOCKS)
! 			UNLOCK_DB;
  #endif
! 			UNLOCK_CONFIG;
! 		    }
! 		    return(obj);
! 		}
! 	}
! done:
      pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*    pthread_mutex_unlock(&obj_chain);*/
!     return(obj);
  }
  
  
! inline
! static int
! add_request_av(char* avtext, struct request *request)
  {
! struct	av	*new=NULL, *next;
! char		*attr=avtext, *sp=avtext, *val,holder;
! char		*new_attr=NULL, *new_val=NULL;
  
!     while( *sp && !IS_SPACE(*sp) && (*sp != ':') ) sp++;
!     if ( !*sp ) {
! 	my_xlog(OOPS_LOG_SEVERE, "add_request_av(): Invalid request string: %s\n", avtext);
! 	return(-1);
      }
!     if ( *sp ==':' ) sp++;
      holder = *sp;
      *sp = 0;
      new = xmalloc(sizeof(*new), "add_request_av(): for av pair");
!     if ( !new ) goto failed;
!     new_attr=xmalloc( strlen(attr)+1, "add_request_av(): for new_attr" );
!     if ( !new_attr ) goto failed;
      strcpy(new_attr, attr);
      *sp = holder;
!     val = sp; while( *val && IS_SPACE(*val) ) val++;
!     if ( !*val ) goto failed;
!     new_val = xmalloc( strlen(val) + 1, "add_request_av(): for val");
!     if ( !new_val ) goto failed;
      strcpy(new_val, val);
      new->attr = new_attr;
!     new->val  = new_val;
      new->next = NULL;
!     if ( !request->av_pairs ) {
! 	request->av_pairs = new;
      } else {
! 	next = request->av_pairs;
! 	while (next->next) next=next->next;
! 	next->next=new;
      }
!     return(0);
! failed:
      *sp = holder;
      IF_FREE(new);
      IF_FREE(new_attr);
      IF_FREE(new_val);
!     return(-1);
  }
  
  /* check any new headers we received and update struct request
     and checked accordingly.
     checked poins to the character next to the last recognized header
   */
! inline
! static int
! check_headers(struct request *request, char *beg, char *end, int *checked, int so)
! {
! char	*start;
! char	*p = NULL, saved;
! int	r;
! 
! go:
!     if ( request->state == REQUEST_READY ) return(0);
      start = beg + *checked;
!     if ( !*checked ) {
!         char    *pn, *pr;
!         pr = memchr(beg, '\r', end-beg);
!         pn = memchr(beg, '\n', end-beg);
!         if        ( (pn == NULL) && (pr != NULL) ) {
              p = pr;
              saved = '\r';
!         } else if ( (pr == NULL) && (pn != NULL) ) {
              p = pn;
              saved = '\n';
!         } else if ( (pr != NULL) && (pn != NULL) ) {
!             if ( pr < pn ) {
                  p = pr;
                  saved = '\r';
              } else {
                  p = pn;
                  saved = '\n';
              }
          }
!         if ( p == NULL ) return(0);
! 	/* first line in request */
! 	*p = 0;
! 	r = parse_http_request(start, request, so);
! 	*checked = strlen(start);
! 	*p = saved;
! 	request->headers_off = p-beg+2;
! 	if ( r ) {
! 	    return(-1);
! 	}
! 	if ( !*checked ) return(-1);
! 	goto go;
      }
      /* checked points to last visited \r */
!     if ( !request->data && (end - start >= 4) && !strncmp(start, "\r\n\r\n", 4) ) {
! 	if ( !request->content_length ) {
! 	    request->state = REQUEST_READY;
! 	    return(0);
! 	} else
! 	if ( request->content_length && !request->data ) {
! 	    request->leave_to_read = request->content_length;
! 	    if ( request->content_length <= 0 ) {
! 		request->state = REQUEST_READY;
! 		return(0);
! 	    }
! 	    request->data = alloc_buff(CHUNK_SIZE);
! 	    if ( !request->data ) {
! 		my_xlog(OOPS_LOG_DBG|OOPS_LOG_INFORM, "check_headers(): req_data.\n");
! 	    	return(-1);
! 	    }
! 	    start += 4;
! 	}
!     } else
!     if ( !request->data && (end - start >= 2) && !strncmp(start, "\n\n", 2) ) {
! 	if ( !request->content_length ) {
! 	    request->state = REQUEST_READY;
! 	    return(0);
! 	} else
! 	if ( request->content_length && !request->data ) {
! 	    request->leave_to_read = request->content_length;
! 	    request->data = alloc_buff(CHUNK_SIZE);
! 	    if ( !request->data ) return(-1);
! 	    start += 2;
! 	}
!     }
!     if ( request->content_length && request->leave_to_read ) {
! 	if ( request->data && (end-start > 0) ) {
! 	    if ( attach_data(start, end-start, request->data ) )
! 		return(-1);
! 	}
! 	request->leave_to_read -= end - start;
! 	/* we will read/send request body directly from/to client/server */
! 	request->state = REQUEST_READY;
! 	*checked = end-beg;
! 	return(0);
      }
      p = start;
!     while( *p && ( *p == '\r' || *p == '\n' ) ) p++;
!     if ( *p ) {
! 	char *t, saver = '\n';
! 
! 	if ( !request->headers_off ) request->headers_off = p-beg;
! 	t = strchr(p, '\n');
! 	if ( !t ) {
! 	    t = strchr(p, '\r');
! 	    saver = '\r';
! 	}
! 	if ( !t ) return(0);
! 	if ( *t == '\n' && *(t-1) =='\r' ) {
! 	    t--;
! 	    saver = '\r';
! 	}
! 	*t = 0;
! 	/* check headers of my interest */
! 	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "check_headers(): ---> `%s'\n", p);
! 	if ( !request->data ) /* we don't parse POST data now */
! 		add_request_av(p, request);
! 	if ( !strncasecmp(p, "Content-length: ", 16) ) {
! 	    char	*x;
! 	    /* length */
! 	    x=p + 16; /* strlen("content-length: ") */
! 	    while( *x && IS_SPACE(*x) ) x++;
! 	    request->content_length = atoi(x);
! 	    request->flags |= RQ_HAS_CONTENT_LEN;
! 	}
! 	if ( !strncasecmp(p, "If-Modified-Since: ", 19) ) {
! 	    char	*x;
! 	    x=p + 19; /* strlen("content-length: ") */
! 	    while( *x && IS_SPACE(*x) ) x++;
! 	    bzero(&request->if_modified_since, sizeof(request->if_modified_since));
! 	    if (!http_date(x, &request->if_modified_since))
! 	    	request->flags |= RQ_HAS_IF_MOD_SINCE;
! 	}
! 	if ( !strncasecmp(p, "Pragma: ", 8) ) {
! 	    char	*x;
! 	    x=p + 8; /* strlen("pragma: ") */
! 	    while( *x && IS_SPACE(*x) ) x++;
! 	    if ( strstr(x, "no-cache") ) request->flags |= RQ_HAS_NO_CACHE;
! 	}
! 	if ( !strncasecmp(p, "Authorization: ", 15) ) {
! 	    request->flags |= RQ_HAS_AUTHORIZATION;
! 	}
! 	if ( !strncasecmp(p, "Host: ", 6) ) {
! 	    request->flags |= RQ_HAS_HOST;
! 	}
! 	if ( !strncasecmp(p, "Connection: ", 12) ) {
! 	    char *x = p+12;
! 
! 	    while( *x && IS_SPACE(*x) ) x++;
! 	    if ( !strncasecmp(x, "close", 5) )
! 		request->flags |= RQ_HAS_CLOSE_CONNECTION;
! 	}
! 	if ( !strncasecmp(p, "Cache-Control: ", 15) ) {
! 	    char	*x;
! 
! 	    x=p + 15; /* strlen("Cache-Control: ") */
! 	    while( *x && IS_SPACE(*x) ) x++;
! 	    if      ( !strncasecmp(x, "no-store", 8) )
! 			request->flags |= RQ_HAS_NO_STORE;
! 	    else if ( !strncasecmp(x, "no-cache", 8) )
! 			request->flags |= RQ_HAS_NO_CACHE;
! 	    else if ( !strncasecmp(x, "no-transform", 12) )
! 			request->flags |= RQ_HAS_NO_TRANSFORM;
! 	    else if ( !strncasecmp(x, "only-if-cached", 14) )
! 			request->flags |= RQ_HAS_ONLY_IF_CACHED;
! 	    else if ( sscanf(x, "max-age = %d", &request->max_age) == 1 )
! 			request->flags |= RQ_HAS_MAX_AGE;
! 	    else if ( sscanf(x, "min-fresh = %d", &request->min_fresh) == 1 )
! 			request->flags |= RQ_HAS_MIN_FRESH;
! 	    else if ( !strncasecmp(x, "max-stale", 9) ) {
! 		request->flags |= RQ_HAS_MAX_STALE;
! 		request->max_stale = 0;
! 		sscanf(x, "max-stale = %d", &request->max_stale);
! 	    }
! 	} else
! 	if ( !strncasecmp(p, "Range: ", 7) ) {
! 	    char *x;
! 	    /* we recognize "Range: bytes=xxx-" */
! 	    x = p + 7;
! 	    while( *x && IS_SPACE(*x) ) x++;
! 	    if ( !strncasecmp(x, "bytes=", 6) ) {
! 		int	from=-1,to=-1;
! 		/* x+6 must be 'xxx-' */
! 		sscanf(x+6,"%d-%d", &from, &to);
! 		if ( (from >= 0 ) && (to == -1 ) ) {
! 		    request->range_from = from;
! 		    request->range_to = to;
! 		}
! 	    }
! 	    request->flags |= RQ_HAVE_RANGE;
! 	}
! 	*t = saver;
! 	*checked = t - beg;
! 	goto go;
      }
!     return(0);
  }
  
! static int
! parse_http_request(char* src, struct request *rq, int so)
  {
! char	*p, *httpv;
! int	http_major, http_minor;
  
      p = strchr(src, ' ');
!     if ( !p )
! 	return(-1);
!     *p=0;
!          if ( !strcasecmp(src, "get") )  rq->meth = METH_GET;
!     else if ( !strcasecmp(src, "head") ) rq->meth = METH_HEAD;
!     else if ( !strcasecmp(src, "put") )  rq->meth = METH_PUT;
!     else if ( !strcasecmp(src, "post") ) rq->meth = METH_POST;
!     else if ( !strcasecmp(src, "trace") ) rq->meth = METH_TRACE;
!     else if ( !strcasecmp(src, "connect") ) rq->meth = METH_CONNECT;
!     else if ( !strcasecmp(src, "PROPFIND") ) rq->meth = METH_PROPFIND;
!     else if ( !strcasecmp(src, "PROPPATCH") ) rq->meth = METH_PROPPATCH;
!     else if ( !strcasecmp(src, "MKCOL") ) rq->meth = METH_MKCOL;
!     else if ( !strcasecmp(src, "DELETE") ) rq->meth = METH_DELETE;
!     else if ( !strcasecmp(src, "COPY") ) rq->meth = METH_COPY;
!     else if ( !strcasecmp(src, "MOVE") ) rq->meth = METH_MOVE;
!     else if ( !strcasecmp(src, "LOCK") ) rq->meth = METH_LOCK;
!     else if ( !strcasecmp(src, "UNLOCK") ) rq->meth = METH_UNLOCK;
!     else if ( !strcasecmp(src, "PURGE") ) rq->meth = METH_PURGE;
!     else if ( !strcasecmp(src, "OPTIONS") ) rq->meth = METH_OPTIONS;
      else {
! 	my_xlog(OOPS_LOG_SEVERE, "parse_http_request(): Unrecognized method `%s'.\n", src);
! 	*p = ' ';
! 	return(-1);
      }
!     IF_FREE(rq->method); rq->method = strdup(src);
      *p = ' ';
      p++;
      /* next space must be before HTTP */
      httpv = strrchr(p, 'H');
!     if ( rq->meth == METH_CONNECT ) {
!         if ( httpv )
              *httpv = 0;
! 	if ( parse_connect_url(p, httpv+1, &rq->url, so) ) {
! 	    if ( httpv ) *httpv = ' ';
! 	    return(-1);
! 	}
! 	if ( httpv ) *httpv = ' ';
!         return(0);
!     }
!     if ( !httpv )
! 	return(-1);
!     if ( (httpv <= p) )
! 	return(-1);
      httpv--;
      *httpv = 0;
!     if ( parse_url(p, httpv+1, &rq->url, so) ) {
! 	*httpv = ' ';
! 	return(-1);
      }
      *httpv = ' ';
!     if ( sscanf(httpv+1, "HTTP/%d.%d", &http_major, &http_minor) == 2 ) {
! 	rq->http_major = http_major;
! 	rq->http_minor = http_minor;
      } else
! 	return(-1);
!     return(0);
  }
  
! static int
! parse_connect_url(char* src, char *httpv, struct url *url, int so)
  {
! char	*ss, *host=NULL;
  
!     if ( !src ) return(-1);
      ss = strchr(src, ':');
!     if ( !ss ) {
! 	say_bad_request(so, "Bad request, no proto:", src, ERR_BAD_URL, NULL);
! 	return(-1);
      }
      *ss = 0;
!     host = xmalloc(strlen(src)+1, "parse_connect_url():");
      if (!host)
! 	goto err;
!     memcpy_to_lower(host, src, strlen(src)+1);
      url->host = host;
!     url->port = atoi(ss+1);
      goto done;
! err:
      *ss = ':';
!     if (host) xfree(host);
!     return(-1);
! done:
      *ss = ':';
!     return(0);
  }
  
! int
! parse_url(char *src, char *httpv, struct url *url, int so)
  {
! char	*proto=NULL, *host=NULL, *path=NULL, *httpver = NULL;
! char	*ss, *se, *he, *sx, *sa, holder;
! char	number[10];
! char	*login = NULL, *password = NULL;
! int	p_len, h_len, i;
! u_short	pval;
! 
!     if ( !src )
! 	return(-1);
!     if ( *src == '/' ) {/* this is 'GET /path HTTP/1.x' request */
! 	se = src;
! 	proto = strdup("http");
! 	goto only_path;
      }
      ss = strchr(src, ':');
!     if ( !ss ) {
! 	say_bad_request(so, "Bad request, no proto:", src, ERR_BAD_URL, NULL);
! 	return(-1);
!     }
!     if ( memcmp(ss, "://", 3) ) {
! 	say_bad_request(so, "Bad request:", src, ERR_BAD_URL, NULL);
! 	return(-1);
      }
      p_len = ss - src;
!     proto = xmalloc(p_len+1, "parse_url(): proto");
!     if ( !proto )
! 	return(-1);
!     memcpy(proto, src, p_len); proto[p_len] = 0;
!     ss += 3; /* skip :// */
      sx = strchr(ss, '/');
      se = strchr(ss, ':');
      sa = strchr(ss, '@');
!     /* if we have @ and (there is no '/' or @ stay before '/') */ 
!     if ( sa && ( !sx || ( sa < sx )) ) {
! 	/* ss   points to login				*/
! 	/* se+1 points to password			*/
! 	/* sa+1 points to host...			*/
! 	/* ss	se	 sa				*/
! 	/* login:password@hhost:port/path		*/
! 	if ( se < sa ) {
! 	    if ( se ) {
! 		*se = 0;
! 		login = xmalloc(ROUND(strlen(ss)+1, CHUNK_SIZE), "parse_url(): login");
! 		strcpy(login, ss);
! 		*se = ':';
! 		holder = *(sa);
! 		*(sa) = 0;
! 		password = xmalloc(ROUND(strlen(se+1)+1, CHUNK_SIZE), "parse_url(): password");
! 		strcpy(password, se+1);
! 	    	*(sa) = holder;
! 	    } else {
! 		holder = *sa;
! 		*sa = 0;
! 		login = xmalloc(ROUND(strlen(ss)+1, CHUNK_SIZE), "parse_url(): login2");
! 		strcpy(login, ss);
! 	        password = NULL;
! 		*sa = holder;
! 	    }
! 	    ss = sa+1;
! 	    sx = strchr(ss, '/');
! 	    se = strchr(ss, ':');
! 	    goto normal;
! 	} else {
! 	    /* ss   sa	 se			*/
! 	    /* login@host:port/path		*/
! 	    holder = *sa;
! 	    *sa = 0;
! 	    login = xmalloc(ROUND(strlen(ss)+1, CHUNK_SIZE), "parse_url(): login3");
! 	    strcpy(login, ss);
! 	    password = NULL;
! 	    *sa = holder;
! 	    ss = sa+1;
! 	    sx = strchr(ss, '/');
! 	    goto normal;
! 	}
!     }
! normal:;
!     if ( se && (!sx || (sx>se)) ) {
! 	/* port is here */
! 	he = se;
! 	h_len = se-ss;
! 	host = xmalloc(h_len+1, "parse_url(): host");
! 	if ( !host ) {
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    xfree(proto);
! 	    return(-1);
! 	}
! 	memcpy_to_lower(host, ss, h_len); host[h_len] = 0;
! 	se++;
! 	for(i=0; (i<10) && *se && IS_DIGIT(*se); i++,se++ ) {
! 	    number[i]=*se;
! 	}
! 	number[i] = 0;
! 	if ( (pval=atoi(number)) != 0 )
! 		url->port = pval;
! 	    else {
! 		if ( so > 0) {
! 		    /* so can be -1 if called from icp.c */
! 		    say_bad_request(so, "Bad port value:", number,
! 			ERR_BAD_PORT, NULL);
! 		}
! 		IF_FREE(login);
! 		IF_FREE(password);
! 		xfree(proto);
! 		xfree(host);
! 		return(-1);
! 	}
!     } else { /* there was no port */
! 	
! 	se = strchr(ss, '/');
! 	if ( !se )
! 	    se = src+strlen(src);
! 	h_len = se-ss;
! 	host = xmalloc(h_len+1, "parse_url(): host2");
! 	if ( !host ) {
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    xfree(proto);
! 	    return(-1);
! 	}
! 	memcpy_to_lower(host, ss, h_len); host[h_len] = 0;
! 	if ( !strcasecmp(proto, "http") ) url->port=80;
! 	if ( !strcasecmp(proto, "ftp") )  url->port=21;
!     }
! only_path:
!     if ( *se == '/' ) {
! 	ss = se;
! 	for(i=0;*se++;i++);
! 	if ( i ) {
! 	    path = xmalloc(i+1, "parse_url(): 4");
! 	    if ( !path ) {
! 		IF_FREE(login);
! 		IF_FREE(password);
! 		IF_FREE(host);
! 		IF_FREE(proto);
! 		return(-1);
! 	    }
! 	    memcpy(path, ss, i);
! 	    path[i] = 0;
! 	}
      } else {
! 	path=xmalloc(2, "parse_url(): 5");
! 	if ( !path ) {
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    IF_FREE(host);
! 	    IF_FREE(proto);
! 	    return(-1);
! 	}
! 	path[0] = '/'; path[1] = 0;
!     }
!     if ( httpv ) {
! 	httpver = xmalloc(strlen(httpv) + 1, "parse_url(): httpver");
! 	if ( !httpver ) {
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    IF_FREE(host);
! 	    IF_FREE(proto);
! 	    return(-1);
! 	}
! 	memcpy(httpver, httpv, strlen(httpv)+1);
      }
!     url->host  = host;
      url->proto = proto;
!     url->path  = path;
      url->httpv = httpver;
      url->login = login;
      url->password = password;
!     return(0);
  }
  
! int
! parse_raw_url(char *src, struct url *url)
  {
! char	*proto=NULL, *host=NULL, *path=NULL;
! char	*ss, *se, *he, *sx, *sa, holder;
! char	number[10];
! char	*login = NULL, *password = NULL;
! int	p_len, h_len, i;
! u_short	pval;
! 
!     if ( !src )
! 	return(-1);
!     if ( *src == '/' ) {/* this is 'GET /path HTTP/1.x' request */
! 	se = src;
! 	proto = strdup("http");
! 	goto only_path;
      }
      ss = strchr(src, ':');
!     if ( !ss ) {
! 	proto = strdup("http");
! 	ss = src;
! 	goto only_host_here;
!     }
!     if ( memcmp(ss, "://", 3) ) {
! 	proto = strdup("http");
! 	ss = src;
! 	goto only_host_here;
      }
      p_len = ss - src;
!     proto = xmalloc(p_len+1, "parse_raw_url(): proto");
!     if ( !proto )
! 	return(-1);
!     memcpy(proto, src, p_len); proto[p_len] = 0;
!     ss += 3; /* skip :// */
! only_host_here:
      sx = strchr(ss, '/');
      se = strchr(ss, ':');
      sa = strchr(ss, '@');
!     /* if we have @ and (there is no '/' or @ stay before '/') */ 
!     if ( sa && ( !sx || ( sa < sx )) ) {
! 	/* ss   points to login				*/
! 	/* se+1 points to password			*/
! 	/* sa+1 points to host...			*/
! 	/* ss	se	 sa				*/
! 	/* login:password@hhost:port/path		*/
! 	if ( se < sa ) {
! 	    if ( se ) {
! 		*se = 0;
! 		login = xmalloc(ROUND(strlen(ss)+1, CHUNK_SIZE), "parse_raw_url(): login");
! 		strcpy(login, ss);
! 		*se = ':';
! 		holder = *(sa);
! 		*(sa) = 0;
! 		password = xmalloc(ROUND(strlen(se+1)+1, CHUNK_SIZE), "parse_raw_url(): password");
! 		strcpy(password, se+1);
! 	    	*(sa) = holder;
! 	    } else {
! 		holder = *sa;
! 		*sa = 0;
! 		login = xmalloc(ROUND(strlen(ss)+1, CHUNK_SIZE), "parse_raw_url(): login2");
! 		strcpy(login, ss);
! 	        password = NULL;
! 		*sa = holder;
! 	    }
! 	    ss = sa+1;
! 	    sx = strchr(ss, '/');
! 	    se = strchr(ss, ':');
! 	    goto normal;
! 	} else {
! 	    /* ss   sa	 se			*/
! 	    /* login@host:port/path		*/
! 	    holder = *sa;
! 	    *sa = 0;
! 	    login = xmalloc(ROUND(strlen(ss)+1, CHUNK_SIZE), "parse_raw_url(): login3");
! 	    strcpy(login, ss);
! 	    password = NULL;
! 	    *sa = holder;
! 	    ss = sa+1;
! 	    sx = strchr(ss, '/');
! 	    goto normal;
! 	}
!     }
! normal:;
!     if ( se && (!sx || (sx>se)) ) {
! 	/* port is here */
! 	he = se;
! 	h_len = se-ss;
! 	host = xmalloc(h_len+1, "parse_raw_url(): host");
! 	if ( !host ) {
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    xfree(proto);
! 	    return(-1);
! 	}
! 	memcpy_to_lower(host, ss, h_len); host[h_len] = 0;
! 	se++;
! 	for(i=0; (i<10) && *se && IS_DIGIT(*se); i++,se++ ) {
! 	    number[i]=*se;
! 	}
! 	number[i] = 0;
! 	if ( (pval=atoi(number)) != 0 )
! 		url->port = pval;
! 	    else {
! 		IF_FREE(login);
! 		IF_FREE(password);
! 		xfree(proto);
! 		xfree(host);
! 		return(-1);
! 	}
!     } else { /* there was no port */
! 	
! 	se = strchr(ss, '/');
! 	if ( !se )
! 	    se = src+strlen(src);
! 	h_len = se-ss;
! 	host = xmalloc(h_len+1, "parse_raw_url(): host2");
! 	if ( !host ) {
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    xfree(proto);
! 	    return(-1);
! 	}
! 	memcpy_to_lower(host, ss, h_len); host[h_len] = 0;
! 	if ( !strcasecmp(proto, "http") ) url->port=0;
! 	if ( !strcasecmp(proto, "ftp") )  url->port=21;
!     }
! only_path:
!     if ( *se == '/' ) {
! 	ss = se;
! 	for(i=0;*se++;i++);
! 	if ( i ) {
! 	    path = xmalloc(i+1, "parse_raw_url(): 4");
! 	    if ( !path ) {
! 		IF_FREE(login);
! 		IF_FREE(password);
! 		IF_FREE(host);
! 		IF_FREE(proto);
! 		return(-1);
! 	    }
! 	    memcpy(path, ss, i);
! 	    path[i] = 0;
! 	}
      } else {
! 	path = xmalloc(2, "parse_raw_url(): 5");
! 	if ( !path ){
! 	    IF_FREE(login);
! 	    IF_FREE(password);
! 	    IF_FREE(host);
! 	    IF_FREE(proto);
! 	    return(-1);
! 	}
! 	path[0] = '/'; path[1] = 0;
      }
!     url->host  = host;
      url->proto = proto;
!     url->path  = path;
      url->login = login;
      url->password = password;
!     return(0);
  }
  
! static u_short
! hash(struct url *url)
  {
! u_short		res = 0;
! int		i;
! char		*p;
  
      p = url->host;
!     if ( p && *p ) {
! 	p = p+strlen(p)-1;
! 	i = 35;
! 	while ( (p >= url->host) && i ) i--,res += *p**p--;
      }
      p = url->path;
!     if ( p && *p ) {
! 	p = p+strlen(p)-1;
! 	i = 35;
! 	while ( (p >= url->path) && i ) i--,res += *p**p--;
      }
!     return(res & HASH_MASK);
  }
  
! static void
! release_obj(struct mem_obj *obj)
  {
  /* just decrement refs */
  
      pthread_mutex_lock(&obj->lock);
! 	obj->refs--;
      pthread_mutex_unlock(&obj->lock);
!     if ( obj->refs < 0 ) {
!     	my_xlog(OOPS_LOG_DBG|OOPS_LOG_INFORM, "release_obj(): obj->refs < 0 = %d\n", obj->refs);
! 	exit(0);
      }
  }
  
! void
! leave_obj(struct mem_obj *obj)
  {
  /* thread leave this object
  	1) decrement ref counter.
--- 787,1638 ----
  		       oldest_obj = obj;
  		    }
  */
!             if (found && (flags & AND_USE)) {
!                 pthread_mutex_lock(&obj->lock);
!                 obj->refs++;
!                 pthread_mutex_unlock(&obj->lock);
!             }
!             ++total_objects;
!             pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*		    pthread_mutex_unlock(&obj_chain);*/
!             /* now try to load obj from disk */
!             if (!(flags & NO_DISK_LOOKUP)) {
!                 int rc, resident_size;
!                 struct disk_ref *disk_ref;
!                 struct storage_st *storage;
!                 RDLOCK_CONFIG;
  #if     !defined(USE_INTERNAL_DB_LOCKS)
!                 RDLOCK_DB;
  #endif
!                 MY_TNF_PROBE_0(locate_url_on_disk_start, "contention", "obj_chain_lock begin");
!                 rc = locate_url_on_disk(url, &disk_ref);
!                 MY_TNF_PROBE_0(locate_url_on_disk_stop, "contention", "obj_chain_lock begin");
!                 if (rc >= 0 && disk_ref) {
!                     /* it is on disk */
!                     storage = locate_storage_by_id(disk_ref->id);
!                     if (storage && (storage->flags & ST_READY)) {
!                         my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_STOR | OOPS_LOG_DBG,
!                                 "locate_in_mem(): Found on disk: %s\n", storage->path);
!                         /* order important. flags must be changed
!                            when all done
!                          */
!                         obj->disk_ref = disk_ref;
!                         if (new_object)
!                             *new_object = FALSE;
!                         obj->writers = 0;       /* like old object */
!                         MY_TNF_PROBE_0(load_obj_from_disk_start, "contention",
!                                        "obj_chain_lock begin");
!                         if (load_obj_from_disk(obj, disk_ref)) {
!                             MY_TNF_PROBE_0(load_obj_from_disk_stop, "contention",
!                                            "obj_chain_lock begin");
!                             obj->disk_ref = NULL;
!                             if (new_object)
!                                 *new_object = TRUE;
!                             obj->writers = 1;   /* like old object */
!                             xfree(disk_ref);
!                             goto nf;
!                         }
!                         MY_TNF_PROBE_0(load_obj_from_disk_stop, "contention",
!                                        "obj_chain_lock begin");
!                         /* ok, obj was loaded */
!                         resident_size = calculate_resident_size(obj);
!                         obj->resident_size = resident_size;
!                         increase_hash_size(obj->hash_back, obj->resident_size);
!                         if (!strcasecmp(url->proto, "ftp"))
!                             obj->doc_type = FTP_DOC;
!                         SET(obj->flags, FLAG_FROM_DISK);
!                         if (rq && (check_headers_match(obj, rq, &mod_flags) != MOD_CODE_OK)) {
!                             /* obj don't match request  */
!                             struct mem_obj *n_obj;
! 
!                             if (new_object)
!                                 *new_object = TRUE;
!                             SET(obj->flags, FLAG_DEAD);
  #if     !defined(USE_INTERNAL_DB_LOCKS)
!                             UNLOCK_DB;
  #endif
!                             UNLOCK_CONFIG;
!                             leave_obj(obj);
!                             n_obj = locate_in_mem(&rq->url,
!                                                   AND_PUT | AND_USE | PUT_NEW_ANYWAY |
!                                                   NO_DISK_LOOKUP, NULL, NULL);
!                             /* old content will be dead */
!                             return (n_obj);
!                         } else
!                             CLR(obj->flags, ANSW_NO_CACHE);
!                         pthread_cond_broadcast(&obj->decision_cond);
!                     }
!                 } else {
!                     my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_DBG,
!                             "locate_in_mem(): Not found.\n");
!                 }
!               nf:
  #if     !defined(USE_INTERNAL_DB_LOCKS)
!                 UNLOCK_DB;
  #endif
!                 UNLOCK_CONFIG;
!             }
!             return (obj);
!         }
!     }
!   done:
      pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*    pthread_mutex_unlock(&obj_chain);*/
!     return (obj);
  }
  
  
! inline static int add_request_av(char *avtext, struct request *request)
  {
!     struct av *new = NULL, *next;
!     char *attr = avtext, *sp = avtext, *val, holder;
!     char *new_attr = NULL, *new_val = NULL;
  
!     while (*sp && !IS_SPACE(*sp) && (*sp != ':'))
!         sp++;
!     if (!*sp) {
!         my_xlog(OOPS_LOG_SEVERE, "add_request_av(): Invalid request string: %s\n", avtext);
!         return (-1);
      }
!     if (*sp == ':')
!         sp++;
      holder = *sp;
      *sp = 0;
      new = xmalloc(sizeof(*new), "add_request_av(): for av pair");
!     if (!new)
!         goto failed;
!     new_attr = xmalloc(strlen(attr) + 1, "add_request_av(): for new_attr");
!     if (!new_attr)
!         goto failed;
      strcpy(new_attr, attr);
      *sp = holder;
!     val = sp;
!     while (*val && IS_SPACE(*val))
!         val++;
!     if (!*val)
!         goto failed;
!     new_val = xmalloc(strlen(val) + 1, "add_request_av(): for val");
!     if (!new_val)
!         goto failed;
      strcpy(new_val, val);
      new->attr = new_attr;
!     new->val = new_val;
      new->next = NULL;
!     if (!request->av_pairs) {
!         request->av_pairs = new;
      } else {
!         next = request->av_pairs;
!         while (next->next)
!             next = next->next;
!         next->next = new;
      }
!     return (0);
!   failed:
      *sp = holder;
      IF_FREE(new);
      IF_FREE(new_attr);
      IF_FREE(new_val);
!     return (-1);
  }
  
  /* check any new headers we received and update struct request
     and checked accordingly.
     checked poins to the character next to the last recognized header
   */
! inline static int check_headers(struct request *request, char *beg, char *end, int *checked, int so)
! {
!     char *start;
!     char *p = NULL, saved;
!     int r;
! 
!   go:
!     if (request->state == REQUEST_READY)
!         return (0);
      start = beg + *checked;
!     if (!*checked) {
!         char *pn, *pr;
!         pr = memchr(beg, '\r', end - beg);
!         pn = memchr(beg, '\n', end - beg);
!         if ((pn == NULL) && (pr != NULL)) {
              p = pr;
              saved = '\r';
!         } else if ((pr == NULL) && (pn != NULL)) {
              p = pn;
              saved = '\n';
!         } else if ((pr != NULL) && (pn != NULL)) {
!             if (pr < pn) {
                  p = pr;
                  saved = '\r';
              } else {
                  p = pn;
                  saved = '\n';
              }
+         }
+         if (p == NULL)
+             return (0);
+         /* first line in request */
+         *p = 0;
+         r = parse_http_request(start, request, so);
+         *checked = strlen(start);
+         *p = saved;
+         request->headers_off = p - beg + 2;
+         if (r) {
+             return (-1);
          }
!         if (!*checked)
!             return (-1);
!         goto go;
      }
      /* checked points to last visited \r */
!     if (!request->data && (end - start >= 4) && !strncmp(start, "\r\n\r\n", 4)) {
!         if (!request->content_length) {
!             request->state = REQUEST_READY;
!             return (0);
!         } else if (request->content_length && !request->data) {
!             request->leave_to_read = request->content_length;
!             if (request->content_length <= 0) {
!                 request->state = REQUEST_READY;
!                 return (0);
!             }
!             request->data = alloc_buff(CHUNK_SIZE);
!             if (!request->data) {
!                 my_xlog(OOPS_LOG_DBG | OOPS_LOG_INFORM, "check_headers(): req_data.\n");
!                 return (-1);
!             }
!             start += 4;
!         }
!     } else if (!request->data && (end - start >= 2) && !strncmp(start, "\n\n", 2)) {
!         if (!request->content_length) {
!             request->state = REQUEST_READY;
!             return (0);
!         } else if (request->content_length && !request->data) {
!             request->leave_to_read = request->content_length;
!             request->data = alloc_buff(CHUNK_SIZE);
!             if (!request->data)
!                 return (-1);
!             start += 2;
!         }
      }
+     if (request->content_length && request->leave_to_read) {
+         if (request->data && (end - start > 0)) {
+             if (attach_data(start, end - start, request->data))
+                 return (-1);
+         }
+         request->leave_to_read -= end - start;
+         /* we will read/send request body directly from/to client/server */
+         request->state = REQUEST_READY;
+         *checked = end - beg;
+         return (0);
+     }
      p = start;
!     while (*p && (*p == '\r' || *p == '\n'))
!         p++;
!     if (*p) {
!         char *t, saver = '\n';
! 
!         if (!request->headers_off)
!             request->headers_off = p - beg;
!         t = strchr(p, '\n');
!         if (!t) {
!             t = strchr(p, '\r');
!             saver = '\r';
!         }
!         if (!t)
!             return (0);
!         if (*t == '\n' && *(t - 1) == '\r') {
!             t--;
!             saver = '\r';
!         }
!         *t = 0;
!         /* check headers of my interest */
!         my_xlog(OOPS_LOG_HTTP | OOPS_LOG_DBG, "check_headers(): ---> `%s'\n", p);
!         if (!request->data)     /* we don't parse POST data now */
!             add_request_av(p, request);
!         if (!strncasecmp(p, "Content-length: ", 16)) {
!             char *x;
!             /* length */
!             x = p + 16;         /* strlen("content-length: ") */
!             while (*x && IS_SPACE(*x))
!                 x++;
!             request->content_length = atoi(x);
!             request->flags |= RQ_HAS_CONTENT_LEN;
!         }
!         if (!strncasecmp(p, "If-Modified-Since: ", 19)) {
!             char *x;
!             x = p + 19;         /* strlen("content-length: ") */
!             while (*x && IS_SPACE(*x))
!                 x++;
!             bzero(&request->if_modified_since, sizeof(request->if_modified_since));
!             if (!http_date(x, &request->if_modified_since))
!                 request->flags |= RQ_HAS_IF_MOD_SINCE;
!         }
!         if (!strncasecmp(p, "Pragma: ", 8)) {
!             char *x;
!             x = p + 8;          /* strlen("pragma: ") */
!             while (*x && IS_SPACE(*x))
!                 x++;
!             if (strstr(x, "no-cache"))
!                 request->flags |= RQ_HAS_NO_CACHE;
!         }
!         if (!strncasecmp(p, "Authorization: ", 15)) {
!             request->flags |= RQ_HAS_AUTHORIZATION;
!         }
!         if (!strncasecmp(p, "Host: ", 6)) {
!             request->flags |= RQ_HAS_HOST;
!         }
!         if (!strncasecmp(p, "Connection: ", 12)) {
!             char *x = p + 12;
! 
!             while (*x && IS_SPACE(*x))
!                 x++;
!             if (!strncasecmp(x, "close", 5))
!                 request->flags |= RQ_HAS_CLOSE_CONNECTION;
!         }
!         if (!strncasecmp(p, "Cache-Control: ", 15)) {
!             char *x;
! 
!             x = p + 15;         /* strlen("Cache-Control: ") */
!             while (*x && IS_SPACE(*x))
!                 x++;
!             if (!strncasecmp(x, "no-store", 8))
!                 request->flags |= RQ_HAS_NO_STORE;
!             else if (!strncasecmp(x, "no-cache", 8))
!                 request->flags |= RQ_HAS_NO_CACHE;
!             else if (!strncasecmp(x, "no-transform", 12))
!                 request->flags |= RQ_HAS_NO_TRANSFORM;
!             else if (!strncasecmp(x, "only-if-cached", 14))
!                 request->flags |= RQ_HAS_ONLY_IF_CACHED;
!             else if (sscanf(x, "max-age = %d", &request->max_age) == 1)
!                 request->flags |= RQ_HAS_MAX_AGE;
!             else if (sscanf(x, "min-fresh = %d", &request->min_fresh) == 1)
!                 request->flags |= RQ_HAS_MIN_FRESH;
!             else if (!strncasecmp(x, "max-stale", 9)) {
!                 request->flags |= RQ_HAS_MAX_STALE;
!                 request->max_stale = 0;
!                 sscanf(x, "max-stale = %d", &request->max_stale);
!             }
!         } else if (!strncasecmp(p, "Range: ", 7)) {
!             char *x;
!             /* we recognize "Range: bytes=xxx-yyy" */
!             x = p + 7;
!             while (*x && IS_SPACE(*x))
!                 x++;
!             if (!strncasecmp(x, "bytes=", 6)) {
!                 int from = -1, to = -1;
!                 sscanf(x + 6, "%d-%d", &from, &to);
!                 if (from >= 0) {
!                     request->range_from = from;
!                     request->range_to = to;
!                 }
!                 request->flags |= RQ_HAVE_RANGE;
!             }
!         }
!         *t = saver;
!         *checked = t - beg;
!         goto go;
      }
!     return (0);
  }
  
! static int parse_http_request(char *src, struct request *rq, int so)
  {
!     char *p, *httpv;
!     int http_major, http_minor;
  
      p = strchr(src, ' ');
!     if (!p)
!         return (-1);
!     *p = 0;
!     if (!strcasecmp(src, "get"))
!         rq->meth = METH_GET;
!     else if (!strcasecmp(src, "head"))
!         rq->meth = METH_HEAD;
!     else if (!strcasecmp(src, "put"))
!         rq->meth = METH_PUT;
!     else if (!strcasecmp(src, "post"))
!         rq->meth = METH_POST;
!     else if (!strcasecmp(src, "trace"))
!         rq->meth = METH_TRACE;
!     else if (!strcasecmp(src, "connect"))
!         rq->meth = METH_CONNECT;
!     else if (!strcasecmp(src, "PROPFIND"))
!         rq->meth = METH_PROPFIND;
!     else if (!strcasecmp(src, "PROPPATCH"))
!         rq->meth = METH_PROPPATCH;
!     else if (!strcasecmp(src, "MKCOL"))
!         rq->meth = METH_MKCOL;
!     else if (!strcasecmp(src, "DELETE"))
!         rq->meth = METH_DELETE;
!     else if (!strcasecmp(src, "COPY"))
!         rq->meth = METH_COPY;
!     else if (!strcasecmp(src, "MOVE"))
!         rq->meth = METH_MOVE;
!     else if (!strcasecmp(src, "LOCK"))
!         rq->meth = METH_LOCK;
!     else if (!strcasecmp(src, "UNLOCK"))
!         rq->meth = METH_UNLOCK;
!     else if (!strcasecmp(src, "PURGE"))
!         rq->meth = METH_PURGE;
!     else if (!strcasecmp(src, "PURGE_SITE"))
!         rq->meth = METH_PURGE_SITE;
!     else if (!strcasecmp(src, "PURGE_SITE_R"))
!         rq->meth = METH_PURGE_SITE_R;
!     else if (!strcasecmp(src, "OPTIONS"))
!         rq->meth = METH_OPTIONS;
      else {
!         my_xlog(OOPS_LOG_SEVERE, "parse_http_request(): Unrecognized method `%s'.\n", src);
!         *p = ' ';
!         return (-1);
      }
!     IF_FREE(rq->method);
!     rq->method = strdup(src);
      *p = ' ';
      p++;
      /* next space must be before HTTP */
      httpv = strrchr(p, 'H');
!     if (rq->meth == METH_CONNECT) {
!         if (httpv)
              *httpv = 0;
!         if (parse_connect_url(p, httpv + 1, &rq->url, so)) {
!             if (httpv)
!                 *httpv = ' ';
!             return (-1);
!         }
!         if (httpv)
!             *httpv = ' ';
!         return (0);
!     }
!     if (!httpv)
!         return (-1);
!     if ((httpv <= p))
!         return (-1);
      httpv--;
      *httpv = 0;
!     if (parse_url(p, httpv + 1, &rq->url, so)) {
!         *httpv = ' ';
!         return (-1);
      }
      *httpv = ' ';
!     if (sscanf(httpv + 1, "HTTP/%d.%d", &http_major, &http_minor) == 2) {
!         rq->http_major = http_major;
!         rq->http_minor = http_minor;
      } else
!         return (-1);
!     return (0);
  }
  
! static int parse_connect_url(char *src, char *httpv, struct url *url, int so)
  {
!     char *ss, *host = NULL;
  
!     if (!src)
!         return (-1);
      ss = strchr(src, ':');
!     if (!ss) {
!         say_bad_request(so, "Bad request, no proto:", src, ERR_BAD_URL, NULL);
!         return (-1);
      }
      *ss = 0;
!     host = xmalloc(strlen(src) + 1, "parse_connect_url():");
      if (!host)
!         goto err;
!     memcpy_to_lower(host, src, strlen(src) + 1);
      url->host = host;
!     url->port = atoi(ss + 1);
      goto done;
!   err:
      *ss = ':';
!     if (host)
!         xfree(host);
!     return (-1);
!   done:
      *ss = ':';
!     return (0);
  }
  
! int parse_url(char *src, char *httpv, struct url *url, int so)
  {
!     char *proto = NULL, *host = NULL, *path = NULL, *httpver = NULL;
!     char *ss, *se, *he, *sx, *sa, holder;
!     char number[10];
!     char *login = NULL, *password = NULL;
!     int p_len, h_len, i;
!     u_short pval;
! 
!     if (!src)
!         return (-1);
!     if (*src == '/') {          /* this is 'GET /path HTTP/1.x' request */
!         se = src;
!         proto = strdup("http");
!         goto only_path;
      }
      ss = strchr(src, ':');
!     if (!ss) {
!         say_bad_request(so, "Bad request, no proto:", src, ERR_BAD_URL, NULL);
!         return (-1);
!     }
!     if (memcmp(ss, "://", 3)) {
!         say_bad_request(so, "Bad request:", src, ERR_BAD_URL, NULL);
!         return (-1);
      }
      p_len = ss - src;
!     proto = xmalloc(p_len + 1, "parse_url(): proto");
!     if (!proto)
!         return (-1);
!     memcpy(proto, src, p_len);
!     proto[p_len] = 0;
!     ss += 3;                    /* skip :// */
      sx = strchr(ss, '/');
      se = strchr(ss, ':');
      sa = strchr(ss, '@');
!     /* if we have @ and (there is no '/' or @ stay before '/') */
!     if (sa && (!sx || (sa < sx))) {
!         /* ss   points to login                         */
!         /* se+1 points to password                      */
!         /* sa+1 points to host...                       */
!         /* ss   se       sa                             */
!         /* login:password@hhost:port/path               */
!         if (se < sa) {
!             if (se) {
!                 *se = 0;
!                 login = xmalloc(ROUND(strlen(ss) + 1, CHUNK_SIZE), "parse_url(): login");
!                 strcpy(login, ss);
!                 *se = ':';
!                 holder = *(sa);
!                 *(sa) = 0;
!                 password = xmalloc(ROUND(strlen(se + 1) + 1, CHUNK_SIZE), "parse_url(): password");
!                 strcpy(password, se + 1);
!                 *(sa) = holder;
!             } else {
!                 holder = *sa;
!                 *sa = 0;
!                 login = xmalloc(ROUND(strlen(ss) + 1, CHUNK_SIZE), "parse_url(): login2");
!                 strcpy(login, ss);
!                 password = NULL;
!                 *sa = holder;
!             }
!             ss = sa + 1;
!             sx = strchr(ss, '/');
!             se = strchr(ss, ':');
!             goto normal;
!         } else {
!             /* ss   sa   se                     */
!             /* login@host:port/path             */
!             holder = *sa;
!             *sa = 0;
!             login = xmalloc(ROUND(strlen(ss) + 1, CHUNK_SIZE), "parse_url(): login3");
!             strcpy(login, ss);
!             password = NULL;
!             *sa = holder;
!             ss = sa + 1;
!             sx = strchr(ss, '/');
!             goto normal;
!         }
!     }
!   normal:;
!     if (se && (!sx || (sx > se))) {
!         /* port is here */
!         he = se;
!         h_len = se - ss;
!         host = xmalloc(h_len + 1, "parse_url(): host");
!         if (!host) {
!             IF_FREE(login);
!             IF_FREE(password);
!             xfree(proto);
!             return (-1);
!         }
!         memcpy_to_lower(host, ss, h_len);
!         host[h_len] = 0;
!         se++;
!         for (i = 0; (i < 10) && *se && IS_DIGIT(*se); i++, se++) {
!             number[i] = *se;
!         }
!         number[i] = 0;
!         if ((pval = atoi(number)) != 0)
!             url->port = pval;
!         else {
!             if (so > 0) {
!                 /* so can be -1 if called from icp.c */
!                 say_bad_request(so, "Bad port value:", number, ERR_BAD_PORT, NULL);
!             }
!             IF_FREE(login);
!             IF_FREE(password);
!             xfree(proto);
!             xfree(host);
!             return (-1);
!         }
!     } else {                    /* there was no port */
! 
!         se = strchr(ss, '/');
!         if (!se)
!             se = src + strlen(src);
!         h_len = se - ss;
!         host = xmalloc(h_len + 1, "parse_url(): host2");
!         if (!host) {
!             IF_FREE(login);
!             IF_FREE(password);
!             xfree(proto);
!             return (-1);
!         }
!         memcpy_to_lower(host, ss, h_len);
!         host[h_len] = 0;
!         if (!strcasecmp(proto, "http"))
!             url->port = 80;
!         if (!strcasecmp(proto, "ftp"))
!             url->port = 21;
!     }
!   only_path:
!     if (*se == '/') {
!         ss = se;
!         for (i = 0; *se++; i++);
!         if (i) {
!             path = xmalloc(i + 1, "parse_url(): 4");
!             if (!path) {
!                 IF_FREE(login);
!                 IF_FREE(password);
!                 IF_FREE(host);
!                 IF_FREE(proto);
!                 return (-1);
!             }
!             memcpy(path, ss, i);
!             path[i] = 0;
!         }
      } else {
!         path = xmalloc(2, "parse_url(): 5");
!         if (!path) {
!             IF_FREE(login);
!             IF_FREE(password);
!             IF_FREE(host);
!             IF_FREE(proto);
!             return (-1);
!         }
!         path[0] = '/';
!         path[1] = 0;
!     }
!     if (httpv) {
!         httpver = xmalloc(strlen(httpv) + 1, "parse_url(): httpver");
!         if (!httpver) {
!             IF_FREE(login);
!             IF_FREE(password);
!             IF_FREE(host);
!             IF_FREE(proto);
!             return (-1);
!         }
!         memcpy(httpver, httpv, strlen(httpv) + 1);
      }
!     url->host = host;
      url->proto = proto;
!     url->path = path;
      url->httpv = httpver;
      url->login = login;
      url->password = password;
!     return (0);
  }
  
! int parse_raw_url(char *src, struct url *url)
  {
!     char *proto = NULL, *host = NULL, *path = NULL;
!     char *ss, *se, *he, *sx, *sa, holder;
!     char number[10];
!     char *login = NULL, *password = NULL;
!     int p_len, h_len, i;
!     u_short pval;
! 
!     if (!src)
!         return (-1);
!     if (*src == '/') {          /* this is 'GET /path HTTP/1.x' request */
!         se = src;
!         proto = strdup("http");
!         goto only_path;
      }
      ss = strchr(src, ':');
!     if (!ss) {
!         proto = strdup("http");
!         ss = src;
!         goto only_host_here;
!     }
!     if (memcmp(ss, "://", 3)) {
!         proto = strdup("http");
!         ss = src;
!         goto only_host_here;
      }
      p_len = ss - src;
!     proto = xmalloc(p_len + 1, "parse_raw_url(): proto");
!     if (!proto)
!         return (-1);
!     memcpy(proto, src, p_len);
!     proto[p_len] = 0;
!     ss += 3;                    /* skip :// */
!   only_host_here:
      sx = strchr(ss, '/');
      se = strchr(ss, ':');
      sa = strchr(ss, '@');
!     /* if we have @ and (there is no '/' or @ stay before '/') */
!     if (sa && (!sx || (sa < sx))) {
!         /* ss   points to login                         */
!         /* se+1 points to password                      */
!         /* sa+1 points to host...                       */
!         /* ss   se       sa                             */
!         /* login:password@hhost:port/path               */
!         if (se < sa) {
!             if (se) {
!                 *se = 0;
!                 login = xmalloc(ROUND(strlen(ss) + 1, CHUNK_SIZE), "parse_raw_url(): login");
!                 strcpy(login, ss);
!                 *se = ':';
!                 holder = *(sa);
!                 *(sa) = 0;
!                 password =
!                     xmalloc(ROUND(strlen(se + 1) + 1, CHUNK_SIZE), "parse_raw_url(): password");
!                 strcpy(password, se + 1);
!                 *(sa) = holder;
!             } else {
!                 holder = *sa;
!                 *sa = 0;
!                 login = xmalloc(ROUND(strlen(ss) + 1, CHUNK_SIZE), "parse_raw_url(): login2");
!                 strcpy(login, ss);
!                 password = NULL;
!                 *sa = holder;
!             }
!             ss = sa + 1;
!             sx = strchr(ss, '/');
!             se = strchr(ss, ':');
!             goto normal;
!         } else {
!             /* ss   sa   se                     */
!             /* login@host:port/path             */
!             holder = *sa;
!             *sa = 0;
!             login = xmalloc(ROUND(strlen(ss) + 1, CHUNK_SIZE), "parse_raw_url(): login3");
!             strcpy(login, ss);
!             password = NULL;
!             *sa = holder;
!             ss = sa + 1;
!             sx = strchr(ss, '/');
!             goto normal;
!         }
!     }
!   normal:;
!     if (se && (!sx || (sx > se))) {
!         /* port is here */
!         he = se;
!         h_len = se - ss;
!         host = xmalloc(h_len + 1, "parse_raw_url(): host");
!         if (!host) {
!             IF_FREE(login);
!             IF_FREE(password);
!             xfree(proto);
!             return (-1);
!         }
!         memcpy_to_lower(host, ss, h_len);
!         host[h_len] = 0;
!         se++;
!         for (i = 0; (i < 10) && *se && IS_DIGIT(*se); i++, se++) {
!             number[i] = *se;
!         }
!         number[i] = 0;
!         if ((pval = atoi(number)) != 0)
!             url->port = pval;
!         else {
!             IF_FREE(login);
!             IF_FREE(password);
!             xfree(proto);
!             xfree(host);
!             return (-1);
!         }
!     } else {                    /* there was no port */
! 
!         se = strchr(ss, '/');
!         if (!se)
!             se = src + strlen(src);
!         h_len = se - ss;
!         host = xmalloc(h_len + 1, "parse_raw_url(): host2");
!         if (!host) {
!             IF_FREE(login);
!             IF_FREE(password);
!             xfree(proto);
!             return (-1);
!         }
!         memcpy_to_lower(host, ss, h_len);
!         host[h_len] = 0;
!         if (!strcasecmp(proto, "http"))
!             url->port = 0;
!         if (!strcasecmp(proto, "ftp"))
!             url->port = 21;
!     }
!   only_path:
!     if (*se == '/') {
!         ss = se;
!         for (i = 0; *se++; i++);
!         if (i) {
!             path = xmalloc(i + 1, "parse_raw_url(): 4");
!             if (!path) {
!                 IF_FREE(login);
!                 IF_FREE(password);
!                 IF_FREE(host);
!                 IF_FREE(proto);
!                 return (-1);
!             }
!             memcpy(path, ss, i);
!             path[i] = 0;
!         }
      } else {
!         path = xmalloc(2, "parse_raw_url(): 5");
!         if (!path) {
!             IF_FREE(login);
!             IF_FREE(password);
!             IF_FREE(host);
!             IF_FREE(proto);
!             return (-1);
!         }
!         path[0] = '/';
!         path[1] = 0;
      }
!     url->host = host;
      url->proto = proto;
!     url->path = path;
      url->login = login;
      url->password = password;
!     return (0);
  }
  
! static u_short hash(struct url *url)
  {
!     u_short res = 0;
!     int i;
!     char *p;
  
      p = url->host;
!     if (p && *p) {
!         p = p + strlen(p) - 1;
!         i = 35;
!         while ((p >= url->host) && i)
!             i--, res += *p ** p--;
      }
      p = url->path;
!     if (p && *p) {
!         p = p + strlen(p) - 1;
!         i = 35;
!         while ((p >= url->path) && i)
!             i--, res += *p ** p--;
      }
!     return (res & HASH_MASK);
  }
  
! static void release_obj(struct mem_obj *obj)
  {
  /* just decrement refs */
  
      pthread_mutex_lock(&obj->lock);
!     obj->refs--;
      pthread_mutex_unlock(&obj->lock);
!     if (obj->refs < 0) {
!         my_xlog(OOPS_LOG_DBG | OOPS_LOG_INFORM, "release_obj(): obj->refs < 0 = %d\n", obj->refs);
!         exit(0);
      }
  }
  
! void leave_obj(struct mem_obj *obj)
  {
  /* thread leave this object
  	1) decrement ref counter.
***************
*** 1512,1523 ****
  	3) if doc expired, then set DEAD
  	4) if doc was from disk and it must be erased - do it.
  */
! u_short 		url_hash = hash(&obj->url);
! struct	mem_obj		*child = NULL;
! int			must_be_erased = FALSE, urll;
! struct	disk_ref	*disk_ref = NULL;
! char			*url_str = NULL;
! struct	url		*url;
  
      MY_TNF_PROBE_0(obj_chain_lock_start, "contention", "obj_chain_lock begin");
  /*    if ( pthread_mutex_lock(&obj_chain) ) {
--- 1640,1651 ----
  	3) if doc expired, then set DEAD
  	4) if doc was from disk and it must be erased - do it.
  */
!     u_short url_hash = hash(&obj->url);
!     struct mem_obj *child = NULL;
!     int must_be_erased = FALSE, urll;
!     struct disk_ref *disk_ref = NULL;
!     char *url_str = NULL;
!     struct url *url;
  
      MY_TNF_PROBE_0(obj_chain_lock_start, "contention", "obj_chain_lock begin");
  /*    if ( pthread_mutex_lock(&obj_chain) ) {
***************
*** 1526,1609 ****
      }
  */
      MY_TNF_PROBE_0(obj_chain_lock_stop, "contention", " obj_chain_lock end");
!     if ( pthread_mutex_lock(&hash_table[url_hash].lock) ) {
! 	fprintf(stderr, "leave_obj(): Failed mutex lock in leave.\n");
  /*	pthread_mutex_unlock(&obj_chain);*/
! 	return;
      }
      release_obj(obj);
!     if ( !obj->refs ) {
! 	/* it is possible that object expired, but not changed,
! 	   and long time stay in memory (e.g. accelerator). in 
! 	   this case we will repeatedly check document freshness on server,
! 	   wasting server resources. So I'll delete all expired docs from
! 	   memory and from disk.
! 	*/
! 	if ( TEST(obj->flags, ANSW_HAS_EXPIRES) 
! 	     && (obj->times.expires <= global_sec_timer) )
! 	     	SET(obj->flags, FLAG_DEAD);
! 	else
! 	if ( TEST(obj->flags, ANSW_HAS_MAX_AGE)
! 	     && (obj->times.max_age <= current_obj_age(obj)) )
! 	     	SET(obj->flags, FLAG_DEAD);
!     }
!     if ( (obj->flags & (FLAG_DEAD|ANSW_NO_CACHE)) && !obj->refs ) {
! 	child = obj->child_obj;
! 	if ( obj->flags & FLAG_FROM_DISK ) {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_FTP|OOPS_LOG_STOR|OOPS_LOG_DBG, "leave_obj(): Must be erased from storage.\n");
! 	    must_be_erased = TRUE;
! 	    url = &obj->url;
! 	    urll = strlen(url->proto)+strlen(url->host)+strlen(url->path)+10;
! 	    urll+= 3 + 1; /* :// + \0 */
! 	    url_str = xmalloc(urll, "leave_obj(): url_str");
! 	    if ( obj->doc_type == HTTP_DOC )
! 		snprintf(url_str, urll, "%s%s:%d", url->host, url->path, url->port);
! 	      else
! 		snprintf(url_str, urll, "%s://%s%s:%d", url->proto, url->host, url->path, url->port);
! 	    disk_ref = obj->disk_ref;
! 	    obj->disk_ref = NULL;
! 	}
! 	destroy_obj(obj);
      }
      pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*    pthread_mutex_unlock(&obj_chain);*/
!     if ( child ) leave_obj(child);
!     if ( must_be_erased && url_str && disk_ref) {
! 	eraser_data_t	*ed;
! 
! 	ed = xmalloc(sizeof(*ed), "");
! 	if ( ed ) {
! 	    ed->url = url_str;
! 	    ed->disk_ref = disk_ref;
! 	    dataq_enqueue(&eraser_queue, ed);
! 	} else {
! 	    xfree(url_str);
! 	    xfree(disk_ref);
! 	}
      }
  }
  
! inline
! static void
! free_request( struct request *rq)
  {
! struct	av	*av, *next;
  
      free_url(&rq->url);
      av = rq->av_pairs;
!     while(av) {
! 	xfree(av->attr);
! 	xfree(av->val);
! 	next = av->next;
! 	xfree(av);
! 	av = next;
      }
!     IF_FREE( rq->method );
      IF_FREE(rq->original_host);
!     if ( rq->data ) free_container(rq->data);
!     if ( rq->redir_mods ) leave_l_mod_call_list(rq->redir_mods);
!     if ( rq->cs_to_server_table ) leave_l_string_list(rq->cs_to_server_table);
!     if ( rq->cs_to_client_table ) leave_l_string_list(rq->cs_to_client_table);
      IF_FREE(rq->matched_acl);
      IF_FREE(rq->source);
      IF_FREE(rq->tag);
--- 1654,1746 ----
      }
  */
      MY_TNF_PROBE_0(obj_chain_lock_stop, "contention", " obj_chain_lock end");
!     if (pthread_mutex_lock(&hash_table[url_hash].lock)) {
!         fprintf(stderr, "leave_obj(): Failed mutex lock in leave.\n");
  /*	pthread_mutex_unlock(&obj_chain);*/
!         return;
      }
      release_obj(obj);
!     if (0 && !obj->refs) {
!         /* it is possible that object expired, but not changed,
!            and long time stay in memory (e.g. accelerator). in 
!            this case we will repeatedly check document freshness on server,
!            wasting server resources. So I'll delete all expired docs from
!            memory and from disk.
!          */
!         if (TEST(obj->flags, ANSW_HAS_EXPIRES)
!             && (obj->times.expires <= global_sec_timer)) {
!             SET(obj->flags, FLAG_DEAD);
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_STOR | OOPS_LOG_DBG,
!                     "leave_obj(): doc expired, delete.\n");
!         } else if (TEST(obj->flags, ANSW_HAS_MAX_AGE)
!                  && (obj->times.max_age <= current_obj_age(obj))) {
!             SET(obj->flags, FLAG_DEAD);
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_STOR | OOPS_LOG_DBG,
!                     "leave_obj(): doc aged, delete.\n");
!         }
!     }
!     if ((obj->flags & (FLAG_DEAD | ANSW_NO_CACHE)) && !obj->refs) {
!         child = obj->child_obj;
!         if (obj->flags & FLAG_FROM_DISK) {
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_FTP | OOPS_LOG_STOR | OOPS_LOG_DBG,
!                     "leave_obj(): Must be erased from storage.\n");
!             must_be_erased = TRUE;
!             url = &obj->url;
!             urll = strlen(url->proto) + strlen(url->host) + strlen(url->path) + 10;
!             urll += 3 + 1;      /* :// + \0 */
!             url_str = xmalloc(urll, "leave_obj(): url_str");
!             if (obj->doc_type == HTTP_DOC)
!                 snprintf(url_str, urll, "%s%s:%d", url->host, url->path, url->port);
!             else
!                 snprintf(url_str, urll, "%s://%s%s:%d", url->proto, url->host, url->path,
!                          url->port);
!             disk_ref = obj->disk_ref;
!             obj->disk_ref = NULL;
!         }
!         destroy_obj(obj);
      }
      pthread_mutex_unlock(&hash_table[url_hash].lock);
  /*    pthread_mutex_unlock(&obj_chain);*/
!     if (child)
!         leave_obj(child);
!     if (must_be_erased && url_str && disk_ref) {
!         eraser_data_t *ed;
! 
!         ed = xmalloc(sizeof(*ed), "");
!         if (ed) {
!             ed->url = url_str;
!             ed->disk_ref = disk_ref;
!             dataq_enqueue(&eraser_queue, ed);
!         } else {
!             xfree(url_str);
!             xfree(disk_ref);
!         }
      }
  }
  
! inline static void free_request(struct request *rq)
  {
!     struct av *av, *next;
  
      free_url(&rq->url);
      av = rq->av_pairs;
!     while (av) {
!         xfree(av->attr);
!         xfree(av->val);
!         next = av->next;
!         xfree(av);
!         av = next;
      }
!     IF_FREE(rq->method);
      IF_FREE(rq->original_host);
!     if (rq->data)
!         free_container(rq->data);
!     if (rq->redir_mods)
!         leave_l_mod_call_list(rq->redir_mods);
!     if (rq->cs_to_server_table)
!         leave_l_string_list(rq->cs_to_server_table);
!     if (rq->cs_to_client_table)
!         leave_l_string_list(rq->cs_to_client_table);
      IF_FREE(rq->matched_acl);
      IF_FREE(rq->source);
      IF_FREE(rq->tag);
***************
*** 1616,1623 ****
      remove_request_from_ip_hash(rq);
  }
  
! void
! free_url(struct url *url)
  {
      IF_FREE(url->host);
      IF_FREE(url->proto);
--- 1753,1759 ----
      remove_request_from_ip_hash(rq);
  }
  
! void free_url(struct url *url)
  {
      IF_FREE(url->host);
      IF_FREE(url->proto);
***************
*** 1632,1873 ****
   * %R - reason (strerror, or free text)
   * %U - URL
   */
! void
! say_bad_request(int so, char* reason, char *r, int code, struct request *rq)
  {
! char	*hdr = "HTTP/1.0 400 Bad Request\nConent-Type: text/html\n\n<html>\
  		<body>\
  		<i><h2>Invalid request:</h2></i><p><pre>";
! char	*rf= "</pre><b>";
! char	*trailer="\
  		</b><p>Please, check URL.<p>\
  		<hr>\
  		Generated by Oops.\
  		</body>\
  		</html>";
! struct	err_module	*mod = err_first;
! int			modflags = 0;
  
!     while ( mod ) {
! 	mod->err(so, reason, r, code, rq, &modflags);
! 	mod = (struct err_module*)MOD_NEXT(mod);
! 	if ( TEST(modflags, MOD_AFLAG_BRK|MOD_AFLAG_OUT) )
! 	    break;
      }
!     if ( !TEST(modflags, MOD_AFLAG_OUT) )
!     {
! 	if (hdr ) writet(so, hdr, strlen(hdr), READ_ANSW_TIMEOUT);
! 	if ( r  ) writet(so, r, strlen(r), READ_ANSW_TIMEOUT);
! 	if ( rf ) writet(so, rf, strlen(rf), READ_ANSW_TIMEOUT);
! 	if ( reason ) writet(so, reason, strlen(reason), READ_ANSW_TIMEOUT);
! 	if ( trailer) writet(so, trailer, strlen(trailer), READ_ANSW_TIMEOUT);
      }
  }
  
! static int
! in_stop_cache(struct request *rq)
  {
! struct	string_list	*l = stop_cache;
  
!     while(l) {
! 	if ( strstr((*rq).url.path, l->string) )
! 	    return(1);
! 	l = l->next;
      }
  
!     if ( stop_cache_acl )
! 	return(check_acl_access(stop_cache_acl, rq));
  
!     return(0);
  }
  
! static void
! increment_clients(void)
  {
!     if ( !pthread_mutex_lock(&clients_lock) ) {
! 	clients_number++;
! 	pthread_mutex_unlock(&clients_lock);
      } else {
! 	my_xlog(OOPS_LOG_SEVERE, "increment_clients(): Can't lock clients_lock in increment.\n");
      }
      LOCK_STATISTICS(oops_stat);
! 	oops_stat.clients++;
      UNLOCK_STATISTICS(oops_stat);
  }
  
! static void
! decrement_clients(void)
  {
!     if ( !pthread_mutex_lock(&clients_lock) ) {
! 	clients_number--;
! 	pthread_mutex_unlock(&clients_lock);
      } else {
! 	my_xlog(OOPS_LOG_SEVERE, "decrement_clients(): Can't lock clients_lock in decrement.\n");
      }
      LOCK_STATISTICS(oops_stat);
! 	oops_stat.clients--;
      UNLOCK_STATISTICS(oops_stat);
  }
  
! int
! set_socket_options(int so)
  {
  #if	!defined(FREEBSD)
! int	on = -1;
  #if	defined(TCP_NODELAY)
!      setsockopt(so, IPPROTO_TCP, TCP_NODELAY, (char*)&on, sizeof(on));
  #endif
! #endif /* !FREEBSD */
!     return(0);
  }
  
! static void
! make_purge(int so, struct request *rq)
  {
! struct	mem_obj		*obj;
! struct	output_object	*output;
! char			*res, *result="<body>Unknown status</body>";
! char			*succ = "200 Purged Successfully";
! char			*fail = "404 Not Found";
! int			newobj;
! 
!     if ( !rq->url.path ||
! 	 !rq->url.host ) return;
!     obj = locate_in_mem(&rq->url, AND_USE|AND_PUT, &newobj, rq);
!     if ( obj ) {
! 	if ( !newobj ) {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "make_purge(): Document destroyed.\n");
! 	    res = succ;
! 	    result = "<body>Successfully removed</body>\n";
! 	    IF_STRDUP(rq->tag, "TCP_HIT");
! 	} else {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "make_purge(): Document not found.\n");
! 	    res = fail;
! 	    result = "<body>Document not found\n</body>";
! 	    IF_STRDUP(rq->tag, "TCP_MISS");
! 	}
! 	SET(obj->flags, FLAG_DEAD);
! 	leave_obj(obj);
      } else {
! 	/* not found */
! 	res = fail;
! 	my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "make_purge(): Document not found.\n");
! 	IF_STRDUP(rq->tag, "TCP_MISS");
      }
      output = malloc(sizeof(*output));
!     if ( output ) {
! 	bzero(output, sizeof(*output));
! 	output->body = alloc_buff(128);
! 	put_av_pair(&output->headers,"HTTP/1.0", res);
! 	put_av_pair(&output->headers,"Expires:", "Thu, 01 Jan 1970 00:00:01 GMT");
! 	put_av_pair(&output->headers,"Content-Type:", "text/html");
! 
! 	if ( output->body ) {
! 	    attach_data(result, strlen(result), output->body);
! 	}
  
! 	process_output_object(so, output, rq);
! 	free_output_obj(output);
      }
      log_access(0, rq, NULL);
  }
  
! int
! obj_rate(struct mem_obj *obj)
  {
!     return(0);
  }
  
! inline
! static void
! insert_request_in_hash(struct request *rq)
  {
! int	index;
!     if ( !rq ) return;
      index = rq->so % RQ_HASH_MASK;
      pthread_mutex_lock(&(rq_hash[index].lock));
      rq->next = rq_hash[index].link;
!     if ( rq->next ) rq->next->prev = rq;
      rq->prev = NULL;
      rq_hash[index].link = rq;
      pthread_mutex_unlock(&(rq_hash[index].lock));
  }
  
! inline
! static void
! remove_request_from_hash(struct request *rq)
  {
! int	index;
!     if ( !rq ) return;
      index = rq->so % RQ_HASH_MASK;
      pthread_mutex_lock(&(rq_hash[index].lock));
!     if ( rq->next ) rq->next->prev = rq->prev;
!     if ( rq->prev )
! 	rq->prev->next = rq->next;
!       else
! 	rq_hash[index].link = rq->next;
      pthread_mutex_unlock(&(rq_hash[index].lock));
  }
  
! inline
! static void
! insert_request_in_ip_hash(struct request *rq)
  {
! int		index;
! ip_hash_entry_t	*he = NULL;
  
!     if ( !rq ) return;
      /* if it is already there */
!     index = ((rq->client_sa.sin_addr.s_addr >> 16) ^ 
!     	    (rq->client_sa.sin_addr.s_addr) ) % IP_HASH_MASK;
      pthread_mutex_lock(&ip_hash[index].lock);
      he = ip_hash[index].link;
!     while ( he ) {
! 	if ( he->addr.s_addr == rq->client_sa.sin_addr.s_addr ) /* it is */
! 	    break;
! 	he = he->next;
!     }
!     if ( he ) {
! 	pthread_mutex_lock(&he->lock);
! 	he->refcount++;
! 	he->access = global_sec_timer;
! 	rq->ip_hash_ptr = he;
! 	pthread_mutex_unlock(&he->lock);
      } else {
! 	he = calloc(sizeof(*he),1);
! 	if ( he ) {
! 	    pthread_mutex_init(&he->lock, NULL);
! 	    he->addr = rq->client_sa.sin_addr;
! 	    he->refcount = 1;
! 	    he->access = global_sec_timer;
! 	    he->prev = NULL;
! 	    he->next = ip_hash[index].link;
! 	    if ( he->next ) he->next->prev = he;
! 	    ip_hash[index].link = he;
! 	    rq->ip_hash_ptr = he;
! 	}
      }
      pthread_mutex_unlock(&ip_hash[index].lock);
  }
  
! inline
! static void
! remove_request_from_ip_hash(struct request *rq)
  {
! int		index;
! ip_hash_entry_t	*he;
  
!     if ( !rq ) return;
      /* if it is already there */
!     index = ((rq->client_sa.sin_addr.s_addr >> 16) ^ 
!     	    (rq->client_sa.sin_addr.s_addr) ) % IP_HASH_MASK;
      pthread_mutex_lock(&ip_hash[index].lock);
      he = rq->ip_hash_ptr;
!     if ( he ) {
! 	/* leave this entry */
! 	pthread_mutex_lock(&he->lock);
! 	if ( he->refcount > 0 ) he->refcount--;
! 	pthread_mutex_unlock(&he->lock);
      }
      pthread_mutex_unlock(&ip_hash[index].lock);
  }
--- 1768,2014 ----
   * %R - reason (strerror, or free text)
   * %U - URL
   */
! void say_bad_request(int so, char *reason, char *r, int code, struct request *rq)
  {
!     char *hdr = "HTTP/1.0 400 Bad Request\nConent-Type: text/html\n\n<html>\
  		<body>\
  		<i><h2>Invalid request:</h2></i><p><pre>";
!     char *rf = "</pre><b>";
!     char *trailer = "\
  		</b><p>Please, check URL.<p>\
  		<hr>\
  		Generated by Oops.\
  		</body>\
  		</html>";
!     struct err_module *mod = err_first;
!     int modflags = 0;
  
!     while (mod) {
!         mod->err(so, reason, r, code, rq, &modflags);
!         mod = (struct err_module *) MOD_NEXT(mod);
!         if (TEST(modflags, MOD_AFLAG_BRK | MOD_AFLAG_OUT))
!             break;
      }
!     if (!TEST(modflags, MOD_AFLAG_OUT)) {
!         if (hdr)
!             writet(so, hdr, strlen(hdr), READ_ANSW_TIMEOUT);
!         if (r)
!             writet(so, r, strlen(r), READ_ANSW_TIMEOUT);
!         if (rf)
!             writet(so, rf, strlen(rf), READ_ANSW_TIMEOUT);
!         if (reason)
!             writet(so, reason, strlen(reason), READ_ANSW_TIMEOUT);
!         if (trailer)
!             writet(so, trailer, strlen(trailer), READ_ANSW_TIMEOUT);
      }
  }
  
! static int in_stop_cache(struct request *rq)
  {
!     struct string_list *l = stop_cache;
  
!     while (l) {
!         if (strstr((*rq).url.path, l->string))
!             return (1);
!         l = l->next;
      }
  
!     if (stop_cache_acl)
!         return (check_acl_access(stop_cache_acl, rq));
  
!     return (0);
  }
  
! static void increment_clients(void)
  {
!     if (!pthread_mutex_lock(&clients_lock)) {
!         clients_number++;
!         pthread_mutex_unlock(&clients_lock);
      } else {
!         my_xlog(OOPS_LOG_SEVERE, "increment_clients(): Can't lock clients_lock in increment.\n");
      }
      LOCK_STATISTICS(oops_stat);
!     oops_stat.clients++;
      UNLOCK_STATISTICS(oops_stat);
  }
  
! static void decrement_clients(void)
  {
!     if (!pthread_mutex_lock(&clients_lock)) {
!         clients_number--;
!         pthread_mutex_unlock(&clients_lock);
      } else {
!         my_xlog(OOPS_LOG_SEVERE, "decrement_clients(): Can't lock clients_lock in decrement.\n");
      }
      LOCK_STATISTICS(oops_stat);
!     oops_stat.clients--;
      UNLOCK_STATISTICS(oops_stat);
  }
  
! int set_socket_options(int so)
  {
  #if	!defined(FREEBSD)
!     int on = -1;
  #if	defined(TCP_NODELAY)
!     setsockopt(so, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on));
  #endif
! #endif                          /* !FREEBSD */
!     return (0);
  }
  
! static void make_purge(int so, struct request *rq)
  {
!     struct mem_obj *obj;
!     struct output_object *output;
!     char *res, *result = "<body>Unknown status</body>";
!     char *succ = "200 Purged Successfully";
!     char *fail = "404 Not Found";
!     int newobj;
! 
!     if (!rq->url.path || !rq->url.host)
!         return;
!     obj = locate_in_mem(&rq->url, AND_USE | AND_PUT, &newobj, rq);
!     if (obj) {
!         if (!newobj) {
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_DBG, "make_purge(): Document destroyed.\n");
!             res = succ;
!             result = "<body>Successfully removed</body>\n";
!             IF_STRDUP(rq->tag, "TCP_HIT");
!         } else {
!             my_xlog(OOPS_LOG_HTTP | OOPS_LOG_DBG, "make_purge(): Document not found.\n");
!             res = fail;
!             result = "<body>Document not found\n</body>";
!             IF_STRDUP(rq->tag, "TCP_MISS");
!         }
!         SET(obj->flags, FLAG_DEAD);
!         leave_obj(obj);
      } else {
!         /* not found */
!         res = fail;
!         my_xlog(OOPS_LOG_HTTP | OOPS_LOG_DBG, "make_purge(): Document not found.\n");
!         IF_STRDUP(rq->tag, "TCP_MISS");
      }
      output = malloc(sizeof(*output));
!     if (output) {
!         bzero(output, sizeof(*output));
!         output->body = alloc_buff(128);
!         put_av_pair(&output->headers, "HTTP/1.0", res);
!         put_av_pair(&output->headers, "Expires:", "Thu, 01 Jan 1970 00:00:01 GMT");
!         put_av_pair(&output->headers, "Content-Type:", "text/html");
  
!         if (output->body) {
!             attach_data(result, strlen(result), output->body);
!         }
! 
!         process_output_object(so, output, rq);
!         free_output_obj(output);
      }
      log_access(0, rq, NULL);
  }
  
! static void make_purge_site(int so, struct request *rq, struct group *gr)
  {
!     int mod_flags;
! 
!     /* pass this request to accel, so it can set date when entire site was purged */
!     check_redir_control_request(so, rq, gr, &mod_flags);
  }
  
! int obj_rate(struct mem_obj *obj)
  {
!     return (0);
! }
! 
! inline static void insert_request_in_hash(struct request *rq)
! {
!     int index;
!     if (!rq)
!         return;
      index = rq->so % RQ_HASH_MASK;
      pthread_mutex_lock(&(rq_hash[index].lock));
      rq->next = rq_hash[index].link;
!     if (rq->next)
!         rq->next->prev = rq;
      rq->prev = NULL;
      rq_hash[index].link = rq;
      pthread_mutex_unlock(&(rq_hash[index].lock));
  }
  
! inline static void remove_request_from_hash(struct request *rq)
  {
!     int index;
!     if (!rq)
!         return;
      index = rq->so % RQ_HASH_MASK;
      pthread_mutex_lock(&(rq_hash[index].lock));
!     if (rq->next)
!         rq->next->prev = rq->prev;
!     if (rq->prev)
!         rq->prev->next = rq->next;
!     else
!         rq_hash[index].link = rq->next;
      pthread_mutex_unlock(&(rq_hash[index].lock));
  }
  
! inline static void insert_request_in_ip_hash(struct request *rq)
  {
!     int index;
!     ip_hash_entry_t *he = NULL;
  
!     if (!rq)
!         return;
      /* if it is already there */
!     index = ((rq->client_sa.sin_addr.s_addr >> 16) ^
!              (rq->client_sa.sin_addr.s_addr)) % IP_HASH_MASK;
      pthread_mutex_lock(&ip_hash[index].lock);
      he = ip_hash[index].link;
!     while (he) {
!         if (he->addr.s_addr == rq->client_sa.sin_addr.s_addr)   /* it is */
!             break;
!         he = he->next;
!     }
!     if (he) {
!         pthread_mutex_lock(&he->lock);
!         he->refcount++;
!         he->access = global_sec_timer;
!         rq->ip_hash_ptr = he;
!         pthread_mutex_unlock(&he->lock);
      } else {
!         he = calloc(sizeof(*he), 1);
!         if (he) {
!             pthread_mutex_init(&he->lock, NULL);
!             he->addr = rq->client_sa.sin_addr;
!             he->refcount = 1;
!             he->access = global_sec_timer;
!             he->prev = NULL;
!             he->next = ip_hash[index].link;
!             if (he->next)
!                 he->next->prev = he;
!             ip_hash[index].link = he;
!             rq->ip_hash_ptr = he;
!         }
      }
      pthread_mutex_unlock(&ip_hash[index].lock);
  }
  
! inline static void remove_request_from_ip_hash(struct request *rq)
  {
!     int index;
!     ip_hash_entry_t *he;
  
!     if (!rq)
!         return;
      /* if it is already there */
!     index = ((rq->client_sa.sin_addr.s_addr >> 16) ^
!              (rq->client_sa.sin_addr.s_addr)) % IP_HASH_MASK;
      pthread_mutex_lock(&ip_hash[index].lock);
      he = rq->ip_hash_ptr;
!     if (he) {
!         /* leave this entry */
!         pthread_mutex_lock(&he->lock);
!         if (he->refcount > 0)
!             he->refcount--;
!         pthread_mutex_unlock(&he->lock);
      }
      pthread_mutex_unlock(&ip_hash[index].lock);
  }
Index: src/ssl.c
===================================================================
RCS file: /usr/local/cvs/oops/src/ssl.c,v
retrieving revision 1.15
retrieving revision 1.17
diff -c -r1.15 -r1.17
*** ssl.c	2002/02/02 16:12:51	1.15
--- ssl.c	2002/12/06 09:09:26	1.17
***************
*** 48,60 ****
      if ( parent_port && !is_local_dom(rq->url.host)) {
          parent_req = malloc(64 + strlen(url->host));
          if ( parent_req ) {
!             sprintf(parent_req, "CONNECT %s:%d HTTP/1.0\r\n\r\n", url->host, url->port);
              r = writet(server_so, parent_req, strlen(parent_req), READ_ANSW_TIMEOUT);
              free(parent_req);
              if ( r < 0 ) goto done;
          } else
              goto done;
      } else {
          bind_server_so(server_so, rq);
          if ( str_to_sa(url->host, (struct sockaddr*)&server_sa) ) {
  	    say_bad_request(so, "Can't translate name to address", url->host, ERR_DNS_ERR, rq);
--- 48,68 ----
      if ( parent_port && !is_local_dom(rq->url.host)) {
          parent_req = malloc(64 + strlen(url->host));
          if ( parent_req ) {
!             char *fav = NULL;
! 
!             if ( parent_auth && 
!                 (fav = format_av_pair("Proxy-Authorization: Basic", rq->peer_auth))) {
!                 sprintf(parent_req, "CONNECT %s:%d HTTP/1.0\r\n%s\r\n", url->host, url->port,fav);
!                 xfree(fav);
!             } else
!                 sprintf(parent_req, "CONNECT %s:%d HTTP/1.0\r\n\r\n", url->host, url->port);
              r = writet(server_so, parent_req, strlen(parent_req), READ_ANSW_TIMEOUT);
              free(parent_req);
              if ( r < 0 ) goto done;
          } else
              goto done;
      } else {
+         SET(rq->flags, RQ_SERVED_DIRECT);
          bind_server_so(server_so, rq);
          if ( str_to_sa(url->host, (struct sockaddr*)&server_sa) ) {
  	    say_bad_request(so, "Can't translate name to address", url->host, ERR_DNS_ERR, rq);
Index: src/storage.c
===================================================================
RCS file: /usr/local/cvs/oops/src/storage.c,v
retrieving revision 1.64
retrieving revision 1.66
diff -c -r1.64 -r1.66
*** storage.c	2001/12/19 12:15:42	1.64
--- storage.c	2002/03/04 15:48:23	1.66
***************
*** 89,97 ****
--- 89,99 ----
      }
      res = pread(fd,rounded_data,rnbyte,off);
      if ( res <= 0 ) {
+         free(rounded_data);
          return(res);
      }
      memcpy(buf, rounded_data, MIN(res,nbyte));
+     free(rounded_data);
      return(MIN(res,nbyte));
  }
  
***************
*** 132,138 ****
  	if ( res > 0 ) {
  	    return(MIN(nbyte, res));
          }
! 	my_xlog(OOPS_LOG_SEVERE, "st_pread(%d, %d): %m\n", fd, nbyte);
  	return(res);
      }
      rnbyte = (nbyte/512)*512;
--- 134,140 ----
  	if ( res > 0 ) {
  	    return(MIN(nbyte, res));
          }
! 	my_xlog(OOPS_LOG_SEVERE, "st_pwrite(%d, %d): %m\n", fd, nbyte);
  	return(res);
      }
      rnbyte = (nbyte/512)*512;
Index: src/version
===================================================================
RCS file: /usr/local/cvs/oops/src/version,v
retrieving revision 1.49
retrieving revision 1.50
diff -c -r1.49 -r1.50
*** version	2002/02/01 14:02:26	1.49
--- version	2002/03/22 07:09:06	1.50
***************
*** 1 ****
! 1.5.22
--- 1 ----
! 1.5.22f1
Index: src/modules/accel.c
===================================================================
RCS file: /usr/local/cvs/oops/src/modules/accel.c,v
retrieving revision 1.32
retrieving revision 1.42
diff -c -r1.32 -r1.42
*** accel.c	2001/12/28 14:07:29	1.32
--- accel.c	2002/10/24 07:53:53	1.42
***************
*** 20,183 ****
  #include	"../oops.h"
  #include	"../modules.h"
  
! #define	MODULE_NAME	"accel"
! #define	MODULE_INFO	"WWW-accelerator"
  
  #if	defined(MODULES)
! char		module_type   = MODULE_REDIR ;
! char		module_name[] = MODULE_NAME ;
! char		module_info[] = MODULE_INFO ;
! int		mod_load(void);
! int		mod_unload(void);
! int		mod_config_beg(int), mod_config_end(int), mod_config(char*, int), mod_run(void);
! int		redir(int, struct group*, struct request*, int*, int);
! int		redir_connect(int*, struct request*, int*, int);
! int		redir_rewrite_header(char **, struct request*, int*, int);
! #define		MODULE_STATIC
  #else
! static	char	module_type   = MODULE_REDIR ;
! static	char	module_name[] = MODULE_NAME ;
! static	char	module_info[] = MODULE_INFO ;
! static	int	mod_load();
! static	int	mod_unload();
! static	int	mod_config_beg(int), mod_config_end(int), mod_config(char*, int), mod_run();
! static	int	redir(int, struct group*, struct request*, int*, int);
! static	int	redir_connect(int*, struct request*, int*, int);
! static	int	redir_rewrite_header(char **, struct request*, int*, int);
! #define		MODULE_STATIC	static
  #endif
  
  struct	redir_module	accel = {
! 	{
! 	NULL, NULL,
! 	MODULE_NAME,
! 	mod_load,
! 	mod_unload,
! 	mod_config_beg,
! 	mod_config_end,
! 	mod_config,
! 	NULL,
! 	MODULE_REDIR,
! 	MODULE_INFO,
! 	mod_run
! 	},
! 	redir,
! 	redir_connect,
! 	redir_rewrite_header
  };
  
! static	pthread_rwlock_t	accel_lock;
! #define	RDLOCK_ACCEL_CONFIG	pthread_rwlock_rdlock(&accel_lock)
! #define	WRLOCK_ACCEL_CONFIG	pthread_rwlock_wrlock(&accel_lock)
! #define	UNLOCK_ACCEL_CONFIG	pthread_rwlock_unlock(&accel_lock)
! 
! #define	MAP_STRING		1
! #define	MAP_REGEX		2
! #define	MAP_STRING_CS		3
! #define	MAP_REGEX_CS		4
! #define	MAP_ACL			5
! #define	MAP_EXTERNAL            6
! #define	MAP_EXTERNAL_REGEX      7
  
  char	*mapnames[9] = {
! 	"?",
! 	"string",
! 	"regex",
! 	"string+charset",
! 	"regex+charset",
! 	"acl",
          "external",
          "external+regex"
! 	"?"};
  
! #define	MAXMATCH		10
! #define	INIT_PMATCH(p)		do {\
! 				int i;\
! 				    for(i=0;i<MAXMATCH;i++)\
! 					p[i].rm_so = p[i].rm_eo = -1;\
! 				} while(0)
! #define	NMYPORTS	8
! static	myport_t	myports[NMYPORTS];	/* my ports		*/
! static	int		nmyports;		/* actual number	*/
! static	char		*myports_string = NULL;
! static	char		*access_string	= NULL;
  
  static	refresh_pattern_t	*refr_patts;
  
  struct	to_host {
! 	struct	to_host	*next;
! 	char		*name;
! 	u_short		port;
! 	char		*path;		/* if we have to prepend path	*/
! 	char		failed;		/* TRUE or FALSE 		*/
! 	time_t		last_failed;	/* when failed to connect 	*/
  };
  
! #define	MAP_REVERSE	1
  
  struct	map {
! 	struct	map	*next;
! 	int		type;
! 	char		*from_host;
! 	regex_t		preg;			/* regex if MAP_REGEX			*/
! 	int		acl_index;		/* acl index if type MAP_ACL		*/
! 	u_short		from_port;
! 	int		hosts;
! 	pthread_mutex_t	last_lock;
! 	struct	to_host	*to_hosts;
! 	struct	to_host	*last_used;
! 	l_string_list_t	*cs_to_server_table;	/* translation from client to server	*/
! 	l_string_list_t	*cs_to_client_table;	/* translation from server to client	*/
! 	char		*src_cs_name;		/* source charset name			*/
! 	struct	map	*next_in_hash;		/* link in hash	table for usual maps,
! 						   next map for acl, regex maps		*/
! 	int		ortho;			/* something orthogonal to hash function*/
! 	char		*config_line;		/* original config line			*/
! 	int		flags;			/* flags like 'reverse'			*/
  };
  
! typedef	struct	rewrite_location_ {
! 	struct  rewrite_location_	*next;
! 	int				acl_index;
! 	regex_t				preg;
! 	char				*dst;
  } rewrite_location_t ;
  
! typedef	struct	map_hash_ {
! 	struct	map	*next;
  } map_hash_t;
  
! static	struct	map	*maps, *default_map, *new_map(void), *last_map;
! static	struct	map	*find_map(struct request*, size_t, regmatch_t*, char*);
! static	struct	map	*other_maps_chain;
! static	map_hash_t	*map_hash_table;
! static	struct	to_host	*new_to_host(void);
! static	int		rewrite_host;
! static	int		use_host_hash;
! static	void		free_maps(struct map *);
! static	int		parse_access(char *string, myport_t *ports, int number);
! static	void		parse_map(char*);
! static	void		parse_map_acl(char*);
! static	void		parse_map_external(char*);
! static	void		parse_map_external_regex(char*);
! static	void		parse_map_regex(char*);
! static	void		parse_map_regex_charset(char*);
! static	void		parse_map_charset(char*);
! static	void		parse_map_file(char*);
! static  void		check_map_file_age(void);
! static	void		reload_map_file(void);
! static  int		on_my_port(struct request *);
! static	int		sleep_timeout, dead_timeout;
! static	char		*build_destination(char*,regmatch_t*, char*);
! static	char		*build_src(struct request *);
! static	rewrite_location_t	*rewrite_location;
! static	void		insert_rewrite_location(char*);
! static	void		free_rewrite_location(rewrite_location_t*);
! 
! static	char		map_file[MAXPATHLEN];
! static	time_t		map_file_mtime = 0, map_file_check_time = 0;
! static	int		deny_proxy_requests;
! static	int		ip_lookup;
  
  
  
--- 20,198 ----
  #include	"../oops.h"
  #include	"../modules.h"
  
! #define	MODULE_NAME "accel"
! #define	MODULE_INFO "WWW-accelerator"
  
  #if	defined(MODULES)
! char            module_type   = MODULE_REDIR ;
! char            module_name[] = MODULE_NAME ;
! char            module_info[] = MODULE_INFO ;
! int             mod_load(void);
! int             mod_unload(void);
! int             mod_config_beg(int), mod_config_end(int), mod_config(char*, int), mod_run(void);
! int             redir(int, struct group*, struct request*, int*, int);
! int             redir_connect(int*, struct request*, int*, int);
! int             redir_rewrite_header(char **, struct request*, int*, int);
! int             redir_control_request(int, struct group*, struct request*, int*, int);
! #define         MODULE_STATIC
  #else
! static  char    module_type   = MODULE_REDIR ;
! static  char    module_name[] = MODULE_NAME ;
! static  char    module_info[] = MODULE_INFO ;
! static  int     mod_load();
! static  int     mod_unload();
! static  int     mod_config_beg(int), mod_config_end(int), mod_config(char*, int), mod_run();
! static  int     redir(int, struct group*, struct request*, int*, int);
! static  int     redir_connect(int*, struct request*, int*, int);
! static  int     redir_rewrite_header(char **, struct request*, int*, int);
! static  int     redir_control_request(int, struct group*, struct request*, int*, int);
! #define         MODULE_STATIC   static
  #endif
  
  struct	redir_module	accel = {
!         {
!         NULL, NULL,
!         MODULE_NAME,
!         mod_load,
!         mod_unload,
!         mod_config_beg,
!         mod_config_end,
!         mod_config,
!         NULL,
!         MODULE_REDIR,
!         MODULE_INFO,
!         mod_run
!         },
!         redir,
!         redir_connect,
!         redir_rewrite_header,
!         redir_control_request
  };
  
! static  pthread_rwlock_t	accel_lock;
! #define RDLOCK_ACCEL_CONFIG     pthread_rwlock_rdlock(&accel_lock)
! #define WRLOCK_ACCEL_CONFIG     pthread_rwlock_wrlock(&accel_lock)
! #define UNLOCK_ACCEL_CONFIG     pthread_rwlock_unlock(&accel_lock)
! 
! #define MAP_STRING              1
! #define MAP_REGEX               2
! #define MAP_STRING_CS           3
! #define MAP_REGEX_CS            4
! #define MAP_ACL                 5
! #define MAP_EXTERNAL            6
! #define MAP_EXTERNAL_REGEX      7
  
  char	*mapnames[9] = {
!         "?",
!         "string",
!         "regex",
!         "string+charset",
!         "regex+charset",
!         "acl",
          "external",
          "external+regex"
!         "?"};
  
! #define MAXMATCH                10
! #define INIT_PMATCH(p)          do {\
!                                 int i;\
!                                         for(i=0;i<MAXMATCH;i++)\
!                                         p[i].rm_so = p[i].rm_eo = -1;\
!                                 } while(0)
! #define NMYPORTS        8
! static  myport_t        myports[NMYPORTS];      /* my ports             */
! static  int             nmyports;               /* actual number        */
! static  char            *myports_string = NULL;
! static  char            *access_string	= NULL;
  
  static	refresh_pattern_t	*refr_patts;
  
  struct	to_host {
!         struct	to_host	*next;
!         char		*name;
!         u_short		port;
!         char		*path;		/* if we have to prepend path	*/
!         char		failed;		/* TRUE or FALSE 		*/
!         time_t		last_failed;	/* when failed to connect 	*/
  };
  
! #define MAP_REVERSE     1
! #define MAP_CANPURGE    2
! #define MAP_CANPURGE_R  4
  
  struct	map {
!     struct map              *next;
!     int                     type;
!     char                    *from_host;
!     regex_t                 preg;                   /* regex if MAP_REGEX                   */
!     int                     acl_index;              /* acl index if type MAP_ACL            */
!     u_short                 from_port;
!     int                     hosts;
!     pthread_mutex_t         last_lock;
!     struct      to_host     *to_hosts;
!     struct      to_host     *last_used;
!     l_string_list_t         *cs_to_server_table;    /* translation from client to server    */
!     l_string_list_t         *cs_to_client_table;    /* translation from server to client    */
!     char                    *src_cs_name;           /* source charset name                  */
!     struct map              *next_in_hash;          /* link in hash     table for usual maps,
!                                                        next map for acl, regex maps         */
!     struct map              *next_in_reverse_hash;  /* link in reverse_hash                 */
!     int                     ortho;                  /* something orthogonal to hash function*/
!     int                     reverse_ortho;          /* something orthogonal to hash function*/
!     char                    *config_line;           /* original config line                 */
!     int                     flags;                  /* flags like 'reverse'                 */
!     time_t                  site_purged;            /* when site was purged                 */
  };
  
! typedef struct	rewrite_location_ {
!     struct  rewrite_location_   *next;
!     int                         acl_index;
!     regex_t                     preg;
!     char                        *dst;
  } rewrite_location_t ;
  
! typedef struct  map_hash_ {
!         struct  map     *next;
  } map_hash_t;
  
! static  struct  map         *maps, *default_map, *new_map(void), *last_map;
! static  struct  map         *find_map(struct request*, size_t, regmatch_t*, char*);
! static  struct  map         *lookup_map(size_t, regmatch_t*, char*, u_short);
! static  int                 set_purge_date_r(size_t, regmatch_t*, char*, u_short, time_t);
! static  struct  map         *other_maps_chain;
! static  map_hash_t          *map_hash_table;
! static  map_hash_t          *reverse_hash_table;
! static  struct to_host      *new_to_host(void);
! static  int                 rewrite_host;
! static  int                 use_host_hash;
! static  void                free_maps(struct map *);
! static  void                place_map_in_hash(struct map*);
! static  void                place_map_in_reverse_hash(struct map*);
! static  int                 parse_access(char *string, myport_t *ports, int number);
! static  void                parse_map(char*);
! static  void                parse_map_acl(char*);
! static  void                parse_map_external(char*);
! static  void                parse_map_external_regex(char*);
! static  void                parse_map_regex(char*);
! static  void                parse_map_regex_charset(char*);
! static  void                parse_map_charset(char*);
! static  void                parse_map_file(char*);
! static  void                check_map_file_age(void);
! static  void                reload_map_file(void);
! static  void                set_canpurge(char*);
! static  void                set_canpurge_r(char*);
! static  int                 on_my_port(struct request *);
! static  int                 sleep_timeout, dead_timeout;
! static  char                *build_destination(char*,regmatch_t*, char*);
! static  char                *build_src(struct request *);
! static  rewrite_location_t  *rewrite_location;
! static  void                insert_rewrite_location(char*);
! static  void                free_rewrite_location(rewrite_location_t*);
! 
! static  char            map_file[MAXPATHLEN];
! static  time_t          map_file_mtime = 0, map_file_check_time = 0;
! static  int             deny_proxy_requests;
! static  int             ip_lookup;
  
  
  
***************
*** 188,223 ****
  static int
  parse_access(char *string, myport_t *ports, int number)
  {
! char		buf[20], *p, *d, *t;
! u_short		port;
! myport_t	*pptr=ports;
! int		nres=0, rc, one=-1, so;
! struct		sockaddr_in	sin_addr;
  
      if ( !ports || !string ) return(0);
      while( string && *string && (nres < number) ) {
! 	p = string;
! 	while ( *p && IS_SPACE(*p) ) p++;
! 	if ( !*p ) return(nres);
! 	d = buf;
! 	while ( *p && !IS_SPACE(*p) ) {
! 	    *d++ = *p++;
! 	}
! 	*d = 0;
! 	string = p;
! 	if ( (t = (char*)strchr(buf, ':')) != 0 ) {
! 	    *t = 0;
! 	    port = (u_short)atoi(t+1);
! 	    bzero(&sin_addr, sizeof(sin_addr));
! 	    str_to_sa(buf, (struct sockaddr*)&sin_addr);
! 	} else {
! 	    port = (u_short)atoi(buf);
! 	    bzero(&sin_addr, sizeof(sin_addr));
! 	}
! 	nres++;
! 	pptr->port = port;
! 	pptr->in_addr = sin_addr.sin_addr;
! 	pptr++;
      }
      return(nres);
  }
--- 203,238 ----
  static int
  parse_access(char *string, myport_t *ports, int number)
  {
! char            buf[20], *p, *d, *t;
! u_short         port;
! myport_t        *pptr=ports;
! int             nres=0, rc, one=-1, so;
! struct          sockaddr_in     sin_addr;
  
      if ( !ports || !string ) return(0);
      while( string && *string && (nres < number) ) {
!         p = string;
!         while ( *p && IS_SPACE(*p) ) p++;
!         if ( !*p ) return(nres);
!         d = buf;
!         while ( *p && !IS_SPACE(*p) ) {
!             *d++ = *p++;
!         }
!         *d = 0;
!         string = p;
!         if ( (t = (char*)strchr(buf, ':')) != 0 ) {
!             *t = 0;
!             port = (u_short)atoi(t+1);
!             bzero(&sin_addr, sizeof(sin_addr));
!             str_to_sa(buf, (struct sockaddr*)&sin_addr);
!         } else {
!             port = (u_short)atoi(buf);
!             bzero(&sin_addr, sizeof(sin_addr));
!         }
!         nres++;
!         pptr->port = port;
!         pptr->in_addr = sin_addr.sin_addr;
!         pptr++;
      }
      return(nres);
  }
***************
*** 264,299 ****
  char		host_tmp[MAXHOSTNAMELEN], *s, *d;
  
      if ( !map || !map_hash_table ) return;
! 
      switch (map->type) {
   case MAP_STRING:
   case MAP_STRING_CS:
! 	if ( !map->from_host ) goto other;
! 	d = host_tmp; s = map->from_host;
! 	while ( *s && (d - host_tmp < MAXHOSTNAMELEN) ) *d++ = tolower(*s++);
! 	*d = 0;
! 	b = hash_function(host_tmp);
! 	o = ortho_hash_function(host_tmp);
! 	map->ortho = o;
! 	if ( !map_hash_table[b].next ) map_hash_table[b].next = map;
! 	  else {
! 	    this = map_hash_table[b].next;
! 	    while ( this->next_in_hash ) this = this->next_in_hash;
! 	    this->next_in_hash = map;
! 	}
! 	break;
   default:
     other:
! 	if ( !other_maps_chain ) other_maps_chain = map;
! 	  else {
! 	    this = other_maps_chain;
! 	    while ( this->next_in_hash ) this = this->next_in_hash;
! 	    this->next_in_hash = map;
! 	}
! 	break;
      }
  }
  
  int
  mod_load(void)
  {
--- 279,341 ----
  char		host_tmp[MAXHOSTNAMELEN], *s, *d;
  
      if ( !map || !map_hash_table ) return;
!     
      switch (map->type) {
   case MAP_STRING:
   case MAP_STRING_CS:
!         if ( !map->from_host ) goto other;
!         d = host_tmp; s = map->from_host;
!         while ( *s && (d - host_tmp < MAXHOSTNAMELEN) ) *d++ = tolower(*s++);
!         *d = 0;
!         b = hash_function(host_tmp);
!         o = ortho_hash_function(host_tmp);
!         map->ortho = o;
!         if ( !map_hash_table[b].next ) map_hash_table[b].next = map;
!           else {
!             this = map_hash_table[b].next;
!             while ( this->next_in_hash ) this = this->next_in_hash;
!             this->next_in_hash = map;
!         }
!         break;
   default:
     other:
!         if ( !other_maps_chain ) other_maps_chain = map;
!           else {
!             this = other_maps_chain;
!             while ( this->next_in_hash ) this = this->next_in_hash;
!             this->next_in_hash = map;
!         }
!         break;
      }
+     /* also place in reverse hash */
+     place_map_in_reverse_hash(map);
  }
  
+ static void
+ place_map_in_reverse_hash(struct map *map)
+ {
+ unsigned        b, o;
+ struct map      *this;
+ char            host_tmp[MAXHOSTNAMELEN], *s, *d;
+ 
+     if ( !map || !reverse_hash_table ) return;
+ 
+     if ( !map->to_hosts || !map->to_hosts->name ) return;
+     d = host_tmp; s = map->to_hosts->name;
+     while ( *s && (d - host_tmp < MAXHOSTNAMELEN) ) *d++ = tolower(*s++);
+     *d = 0;
+     b = hash_function(host_tmp);
+     o = ortho_hash_function(host_tmp);
+     map->reverse_ortho = o;
+ 
+     if ( !reverse_hash_table[b].next ) reverse_hash_table[b].next = map;
+       else {
+         this = reverse_hash_table[b].next;
+         while ( this->next_in_reverse_hash ) this = this->next_in_reverse_hash;
+         this->next_in_reverse_hash = map;
+     }
+ }
+ 
  int
  mod_load(void)
  {
***************
*** 309,314 ****
--- 351,357 ----
      map_file[0] = 0;
      use_host_hash = 0;
      map_hash_table = NULL;
+     reverse_hash_table = NULL;
      other_maps_chain = NULL;
      myports_string = NULL;
      access_string  = NULL;
***************
*** 333,359 ****
      WRLOCK_ACCEL_CONFIG ;
      nmyports = 0;
      if ( maps ) {
! 	free_maps(maps);
! 	maps = NULL;
      }
      if ( default_map ) {
! 	free_maps(default_map);
! 	default_map = NULL;
      }
      if ( refr_patts ) {
! 	free_refresh_patterns(refr_patts);
! 	refr_patts = NULL;
      }
      if ( rewrite_location ) {
! 	free_rewrite_location(rewrite_location);
! 	rewrite_location = NULL;
      }
      map_file[0] = 0;
      rewrite_host = TRUE;
      use_host_hash = 0;
      if ( map_hash_table ) {
! 	free(map_hash_table);
! 	map_hash_table = NULL;
      }
      other_maps_chain = NULL;
      sleep_timeout = 600;
--- 376,403 ----
      WRLOCK_ACCEL_CONFIG ;
      nmyports = 0;
      if ( maps ) {
!         free_maps(maps);
!         maps = NULL;
      }
      if ( default_map ) {
!         free_maps(default_map);
!         default_map = NULL;
      }
      if ( refr_patts ) {
!         free_refresh_patterns(refr_patts);
!         refr_patts = NULL;
      }
      if ( rewrite_location ) {
!         free_rewrite_location(rewrite_location);
!         rewrite_location = NULL;
      }
      map_file[0] = 0;
      rewrite_host = TRUE;
      use_host_hash = 0;
      if ( map_hash_table ) {
!         free(map_hash_table);
!         free(reverse_hash_table);
!         map_hash_table = NULL;
      }
      other_maps_chain = NULL;
      sleep_timeout = 600;
***************
*** 377,391 ****
  {
      WRLOCK_ACCEL_CONFIG ;
      if ( myports_string ) {
! 	nmyports = parse_myports(myports_string, &myports[0], NMYPORTS);
! 	verb_printf("%s will use %d ports\n", module_name, nmyports);
      }
      UNLOCK_ACCEL_CONFIG ;
  
      if ( access_string != NULL ){     
! 	nmyports = parse_access(access_string, &myports[0], NMYPORTS);
! 	verb_printf("%s will use %d ports for access\n", module_name, nmyports);
! 	
      }
  
      return(MOD_CODE_OK);
--- 421,434 ----
  {
      WRLOCK_ACCEL_CONFIG ;
      if ( myports_string ) {
!         nmyports = parse_myports(myports_string, &myports[0], NMYPORTS);
!         verb_printf("%s will use %d ports\n", module_name, nmyports);
      }
      UNLOCK_ACCEL_CONFIG ;
  
      if ( access_string != NULL ){     
!         nmyports = parse_access(access_string, &myports[0], NMYPORTS);
!         verb_printf("%s will use %d ports for access\n", module_name, nmyports);
      }
  
      return(MOD_CODE_OK);
***************
*** 395,465 ****
  mod_config_end(int i)
  {
      if ( use_host_hash > 0 ) {
! 	map_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
      }
      if ( map_file )
! 	reload_map_file();
      return(MOD_CODE_OK);
  }
  
  int
  mod_config(char *config, int i)
  {
! char		*p = config;
  
      WRLOCK_ACCEL_CONFIG ;
      while( *p && IS_SPACE(*p) ) p++;
  
      if ( !strncasecmp(p, "myport", 6) ) {
! 	p += 6;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	myports_string = strdup(p);
! 	/*nmyports = parse_myports(p, &myports, NMYPORTS);*/
! 	verb_printf("%s will use %d ports\n", module_name, nmyports);
      } else
      if ( !strncasecmp(p, "access", 6) ) {
! 	p += 6;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	access_string = strdup(p);
! 	verb_printf("%s will use %d ports for access\n", module_name, nmyports);
      } else
      if ( !strncasecmp(p, "rewrite_host", 12) ) {
! 	p += 12; while (*p && IS_SPACE(*p) ) p++;
! 	if ( !strcasecmp(p, "yes") ) {
! 	    rewrite_host = TRUE;
! 	    verb_printf("%s will rewrite 'Host:' header\n", module_name);
! 	} else {
! 	    rewrite_host = FALSE;
! 	    verb_printf("%s won't rewrite 'Host:' header\n", module_name);
! 	}
      } else
      if ( !strncasecmp(p, "dead_timeout", 12) ) {
! 	p += 12;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	dead_timeout = atoi(p);
      } else
      if ( !strncasecmp(p, "use_host_hash", 13) ) {
! 	p += 13;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	use_host_hash = atoi(p);
      } else
      if ( !strncasecmp(p, "proxy_requests", 14) ) {
! 	p += 14;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	deny_proxy_requests = !strncasecmp(p, "deny", 4);
      } else
      if ( !strncasecmp(p, "ip_lookup", 9) ) {
! 	p += 9;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	ip_lookup = strncasecmp(p, "no", 2);
      } else
      if ( !strncasecmp(p, "sleep_timeout", 13) ) {
! 	p += 13;
! 	while (*p && IS_SPACE(*p) ) p++;
! 	sleep_timeout = atoi(p);
      } else
      if ( !strncasecmp(p, "file", 4) )
! 	parse_map_file(p);
      UNLOCK_ACCEL_CONFIG ;
  
  
--- 438,509 ----
  mod_config_end(int i)
  {
      if ( use_host_hash > 0 ) {
!         map_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
!         reverse_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
      }
      if ( map_file )
!         reload_map_file();
      return(MOD_CODE_OK);
  }
  
  int
  mod_config(char *config, int i)
  {
! char    *p = config;
  
      WRLOCK_ACCEL_CONFIG ;
      while( *p && IS_SPACE(*p) ) p++;
  
      if ( !strncasecmp(p, "myport", 6) ) {
!         p += 6;
!         while (*p && IS_SPACE(*p) ) p++;
!         myports_string = strdup(p);
!         /*nmyports = parse_myports(p, &myports, NMYPORTS);*/
!         verb_printf("%s will use %d ports\n", module_name, nmyports);
      } else
      if ( !strncasecmp(p, "access", 6) ) {
!         p += 6;
!         while (*p && IS_SPACE(*p) ) p++;
!         access_string = strdup(p);
!         verb_printf("%s will use %d ports for access\n", module_name, nmyports);
      } else
      if ( !strncasecmp(p, "rewrite_host", 12) ) {
!         p += 12; while (*p && IS_SPACE(*p) ) p++;
!         if ( !strcasecmp(p, "yes") ) {
!             rewrite_host = TRUE;
!             verb_printf("%s will rewrite 'Host:' header\n", module_name);
!         } else {
!             rewrite_host = FALSE;
!             verb_printf("%s won't rewrite 'Host:' header\n", module_name);
!         }
      } else
      if ( !strncasecmp(p, "dead_timeout", 12) ) {
!         p += 12;
!         while (*p && IS_SPACE(*p) ) p++;
!         dead_timeout = atoi(p);
      } else
      if ( !strncasecmp(p, "use_host_hash", 13) ) {
!         p += 13;
!         while (*p && IS_SPACE(*p) ) p++;
!         use_host_hash = atoi(p);
      } else
      if ( !strncasecmp(p, "proxy_requests", 14) ) {
!         p += 14;
!         while (*p && IS_SPACE(*p) ) p++;
!         deny_proxy_requests = !strncasecmp(p, "deny", 4);
      } else
      if ( !strncasecmp(p, "ip_lookup", 9) ) {
!         p += 9;
!         while (*p && IS_SPACE(*p) ) p++;
!         ip_lookup = strncasecmp(p, "no", 2);
      } else
      if ( !strncasecmp(p, "sleep_timeout", 13) ) {
!         p += 13;
!         while (*p && IS_SPACE(*p) ) p++;
!         sleep_timeout = atoi(p);
      } else
      if ( !strncasecmp(p, "file", 4) )
!         parse_map_file(p);
      UNLOCK_ACCEL_CONFIG ;
  
  
***************
*** 496,536 ****
  struct	to_host	*host, *next_host;
  
      while (map) {
! 	next_map = map->next;
! 	if ( map->from_host ) free(map->from_host);
! 	if ( (map->type == MAP_REGEX)
! 	     || (map->type == MAP_ACL)
! 	     || (map->type == MAP_REGEX_CS) ) {
! 		regfree(&map->preg);
! 	}
! 	if ( map->cs_to_client_table )
! 	    leave_l_string_list(map->cs_to_client_table);
! 	if ( map->cs_to_server_table )
! 	    leave_l_string_list(map->cs_to_server_table);
! 	if ( map->src_cs_name ) free(map->src_cs_name);
! 	host = map->to_hosts;
! 	while ( host ) {
! 	    next_host = host->next;
! 	    if ( host->name ) free(host->name);
! 	    if ( host->path ) free(host->path);
! 	    free(host);
! 	    host = next_host;
! 	}
! 	pthread_mutex_destroy(&map->last_lock);
! 	if ( map->config_line ) free(map->config_line);
! 	free(map);
! 	map = next_map;
      }
  }
  
  int
  redir_rewrite_header(char **hdr, struct request *rq, int *flags, int instance)
  {
! struct	map		*map;
! struct	url		url, new_url;
! char			*p, *new_location = NULL, *src = NULL, *new_l_val = NULL;
! regmatch_t		pmatch[MAXMATCH];
! rewrite_location_t	*rl;
  
      if ( !rewrite_location
           || !hdr || !*hdr || !rq ) return(MOD_CODE_OK);
--- 540,580 ----
  struct	to_host	*host, *next_host;
  
      while (map) {
!         next_map = map->next;
!         if ( map->from_host ) free(map->from_host);
!         if ( (map->type == MAP_REGEX)
!              || (map->type == MAP_ACL)
!              || (map->type == MAP_REGEX_CS) ) {
!             regfree(&map->preg);
!         }
!         if ( map->cs_to_client_table )
!             leave_l_string_list(map->cs_to_client_table);
!         if ( map->cs_to_server_table )
!             leave_l_string_list(map->cs_to_server_table);
!         if ( map->src_cs_name ) free(map->src_cs_name);
!         host = map->to_hosts;
!         while ( host ) {
!             next_host = host->next;
!             if ( host->name ) free(host->name);
!             if ( host->path ) free(host->path);
!             free(host);
!             host = next_host;
!         }
!         pthread_mutex_destroy(&map->last_lock);
!         if ( map->config_line ) free(map->config_line);
!         free(map);
!         map = next_map;
      }
  }
  
  int
  redir_rewrite_header(char **hdr, struct request *rq, int *flags, int instance)
  {
! struct  map         *map;
! struct  url         url, new_url;
! char                *p, *new_location = NULL, *src = NULL, *new_l_val = NULL;
! regmatch_t          pmatch[MAXMATCH];
! rewrite_location_t  *rl;
  
      if ( !rewrite_location
           || !hdr || !*hdr || !rq ) return(MOD_CODE_OK);
***************
*** 540,546 ****
      p = (*hdr) + 9;
      while ( *p && IS_SPACE(*p) ) p++;
      if ( !*p )
! 	return(MOD_CODE_OK);
  
      RDLOCK_ACCEL_CONFIG ;
  
--- 584,590 ----
      p = (*hdr) + 9;
      while ( *p && IS_SPACE(*p) ) p++;
      if ( !*p )
!         return(MOD_CODE_OK);
  
      RDLOCK_ACCEL_CONFIG ;
  
***************
*** 554,574 ****
      map = find_map(rq, MAXMATCH, pmatch, src);
  
      if ( !map )
! 	goto done;
  
      rl = rewrite_location;
      while ( rl ) {
! 	/* if the source match acl	*/
! 	if ( rl->acl_index && url_match_named_acl_by_index(src, rl->acl_index) ) {
! 	    /* if 'Location:' value match rl->preg	*/
! 	    INIT_PMATCH(pmatch);
! 	    if ( !regexec(&rl->preg, p, MAXMATCH, (regmatch_t*)&pmatch, 0) ) {
! 		/* here it is 		*/
! 		new_l_val = build_destination(p, pmatch, rl->dst);
! 		break;
! 	    }
! 	}
! 	rl = rl->next;
      }
  
      if ( !new_l_val ) goto done;
--- 598,618 ----
      map = find_map(rq, MAXMATCH, pmatch, src);
  
      if ( !map )
!         goto done;
  
      rl = rewrite_location;
      while ( rl ) {
!         /* if the source match acl	*/
!         if ( rl->acl_index && url_match_named_acl_by_index(src, rl->acl_index) ) {
!             /* if 'Location:' value match rl->preg	*/
!             INIT_PMATCH(pmatch);
!             if ( !regexec(&rl->preg, p, MAXMATCH, (regmatch_t*)&pmatch, 0) ) {
!                 /* here it is  */
!                 new_l_val = build_destination(p, pmatch, rl->dst);
!                 break;
!             }
!         }
!         rl = rl->next;
      }
  
      if ( !new_l_val ) goto done;
***************
*** 578,602 ****
      if ( !new_url.port ) new_url.port = 80;
  
      if ( new_url.proto && new_url.host ) {
! 	int	len = strlen(new_url.proto) +
! 		      strlen(new_url.host);
! 	if ( new_url.path ) len += strlen(new_url.path);
! 	if (     url.path ) len += strlen(url.path+1);	/* we don't need leading / here */
! 	len += 10 /* Location: */ + 3 /* :// */
! 		 + 10 /* possible port */ + 1 /* \0 */ ;
! 	new_location = malloc(len);
! 	if ( !new_location ) goto done;
! 	if ( new_url.port != 80 )
! 	    sprintf(new_location, "Location: %s://%s:%d%s%s", new_url.proto,
! 				new_url.host, new_url.port, 
! 				new_url.path?new_url.path:"",
! 				    url.path?(url.path+1):"");
! 	   else
! 	    sprintf(new_location, "Location: %s://%s%s%s", new_url.proto,
! 				new_url.host, 
! 				new_url.path?new_url.path:"",
! 				    url.path?(url.path+1):"");
! 	free(*hdr); *hdr = new_location;
      }
  
  done:
--- 622,646 ----
      if ( !new_url.port ) new_url.port = 80;
  
      if ( new_url.proto && new_url.host ) {
!         int	len = strlen(new_url.proto) +
!         	      strlen(new_url.host);
!         if ( new_url.path ) len += strlen(new_url.path);
!         if (     url.path ) len += strlen(url.path+1);	/* we don't need leading / here */
!         len += 10 /* Location: */ + 3 /* :// */
!                  + 10 /* possible port */ + 1 /* \0 */ ;
!         new_location = malloc(len);
!         if ( !new_location ) goto done;
!         if ( new_url.port != 80 )
!             sprintf(new_location, "Location: %s://%s:%d%s%s", new_url.proto,
!                 new_url.host, new_url.port,
!                 new_url.path?new_url.path:"",
!                 url.path?(url.path+1):"");
!            else
!             sprintf(new_location, "Location: %s://%s%s%s", new_url.proto,
!                         new_url.host,
!                         new_url.path?new_url.path:"",
!                         url.path?(url.path+1):"");
!         free(*hdr); *hdr = new_location;
      }
  
  done:
***************
*** 619,631 ****
  int
  redir_connect(int *resulting_so, struct request *rq, int *flags, int instance)
  {
! struct	map		*map;
! struct	to_host		*host;
! int			max_attempts, so = -1, rc;
! struct	sockaddr_in	server_sa;
! regmatch_t		pmatch[MAXMATCH];
! char			*src = NULL, *destination = NULL;
! struct	url		tmp_url;
  
      /* this lock can be long (if we can't connect immediately) */
      bzero(&tmp_url, sizeof(tmp_url));
--- 663,675 ----
  int
  redir_connect(int *resulting_so, struct request *rq, int *flags, int instance)
  {
! struct	map             *map;
! struct	to_host         *host;
! int                     max_attempts, so = -1, rc;
! struct	sockaddr_in     server_sa;
! regmatch_t              pmatch[MAXMATCH];
! char                    *src = NULL, *destination = NULL;
! struct  url             tmp_url;
  
      /* this lock can be long (if we can't connect immediately) */
      bzero(&tmp_url, sizeof(tmp_url));
***************
*** 640,738 ****
      /* connect using next server */
      max_attempts = map->hosts;
      if ( max_attempts > 1 ) /* we skip firsh host (dst) */
! 	max_attempts--;
      pthread_mutex_lock(&map->last_lock);
      host = map->last_used;
      if ( !host ) {
! 	if ( (map->hosts > 1) && map->to_hosts->next ) {
! 	    /* skip dst - we use only backups to connect to destination */
! 	    host = map->to_hosts->next;
! 	} else
! 	host = map->to_hosts;
      }
      map->last_used = host->next;
      /* if host marked as failed and sleep_timeout passed - try it */
      if ( host->failed && (global_sec_timer - host->last_failed > sleep_timeout) )
! 	host->failed = FALSE;
      pthread_mutex_unlock(&map->last_lock);
      if ( !host ) goto done;	/* something wrong */
  
      so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      if ( so < 0 )
! 	goto done;
  
      while ( max_attempts ) {
! 	if ( !host->failed ) {
! 	    char 	*use_name;
! 	    u_short	use_port;
! 	    /* we can try this */
! 	    /* if map is regex then first record can be regex			*/
! 	    /* in this case we can use host and port from rewritten request	*/
! 	    if ( ((map->type == MAP_REGEX)
! 	        ||(map->type==MAP_ACL)
! 	        ||(map->type==MAP_REGEX_CS))
! 	    	  && (host == map->to_hosts) ) {
! 		destination = build_destination(src,pmatch, map->to_hosts->name);
! 		parse_raw_url(destination, &tmp_url);
! 		IF_FREE(destination); destination = NULL;
! 		use_name = tmp_url.host;
! 		use_port = tmp_url.port;
! 		if ( !use_port ) use_port = 80;
! 	    } else {
! 		use_name = host->name;
! 		use_port = host->port;
! 		/* Added by Tolyar */
! 		if ( !map->from_port || !use_port ) use_port = rq->url.port;
! 	    }
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "redir_connect(): Connecting to %s:%d\n", use_name, use_port);
! 	    rc = str_to_sa(use_name, (struct sockaddr*)&server_sa);
! 	    server_sa.sin_port = htons(use_port);
! 	    if ( rc ) /* have no name */
! 		goto try_next_host;
! 	    fcntl(so, F_SETFL, fcntl(so, F_GETFL, 0) | O_NONBLOCK );
! 	    rc = connect(so, (struct sockaddr*)&server_sa, sizeof(server_sa));
! 	    if ( rc == 0 ) {
! 		/* this is ok */
! 		*resulting_so = so;
! 		goto done;
! 	    }
! 	    if ( ERRNO == EINPROGRESS ) {
! 	      /* do timed wait */
! 	      struct pollarg pollarg;
! 
! 		pollarg.fd = so;
! 		pollarg.request = FD_POLL_WR|FD_POLL_HU;
! 		rc = poll_descriptors(1, &pollarg, dead_timeout*1000);
! 		if ( (rc > 0) && !IS_HUPED(&pollarg) ) {
! 		    /* connected */
! 		    *resulting_so = so;
! 		    goto done;
! 		}
! 		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "redir_connect(): Connect failed.\n");
! 	    }
! 	    if ( so != -1 ) {
! 		close(so);
! 		so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
! 		if ( so < 0 )
! 		    goto done;
! 	    }
! 	    host->failed = TRUE;
! 	    host->last_failed = global_sec_timer;
! 	} else {
! 	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "redir_connect(): Host %s failed %d ago. Sleep_timeout=%d\n",
! 		host->name?host->name:"???", 
! 		global_sec_timer-host->last_failed,
! 		sleep_timeout);
! 	}
    try_next_host:
          free_url(&tmp_url); bzero(&tmp_url, sizeof(tmp_url));
! 	host = host->next;
! 	if ( !host ) host = map->to_hosts;
! 	max_attempts--;
      }
      UNLOCK_ACCEL_CONFIG ;
      if ( so >= 0 )
! 	close(so);
      IF_FREE(src);
      IF_FREE(destination);
      free_url(&tmp_url);
--- 684,787 ----
      /* connect using next server */
      max_attempts = map->hosts;
      if ( max_attempts > 1 ) /* we skip firsh host (dst) */
!         max_attempts--;
      pthread_mutex_lock(&map->last_lock);
      host = map->last_used;
      if ( !host ) {
!         if ( (map->hosts > 1) && map->to_hosts->next ) {
!             /* skip dst - we use only backups to connect to destination */
!             host = map->to_hosts->next;
!         } else
!         host = map->to_hosts;
      }
      map->last_used = host->next;
      /* if host marked as failed and sleep_timeout passed - try it */
      if ( host->failed && (global_sec_timer - host->last_failed > sleep_timeout) )
!         host->failed = FALSE;
      pthread_mutex_unlock(&map->last_lock);
      if ( !host ) goto done;	/* something wrong */
  
      so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      if ( so < 0 )
!         goto done;
  
+     if ( bind(so,(struct sockaddr*)&rq->conn_from_sa,sizeof(struct sockaddr)) == -1 ) {
+       my_xlog(OOPS_LOG_SEVERE,"redir_connect(): bind: can't bind to connect_from IP in accel module\n");
+       goto done;
+     }
+ 
      while ( max_attempts ) {
!         if ( !host->failed ) {
!             char        *use_name;
!             u_short     use_port;
!             /* we can try this */
!             /* if map is regex then first record can be regex			*/
!             /* in this case we can use host and port from rewritten request	*/
!             if ( ((map->type == MAP_REGEX)
!                 ||(map->type==MAP_ACL)
!                 ||(map->type==MAP_REGEX_CS))
!                   && (host == map->to_hosts) ) {
!                 destination = build_destination(src,pmatch, map->to_hosts->name);
!                 parse_raw_url(destination, &tmp_url);
!                 IF_FREE(destination); destination = NULL;
!                 use_name = tmp_url.host;
!                 use_port = tmp_url.port;
!                 if ( !use_port ) use_port = 80;
!             } else {
!                 use_name = host->name;
!                 use_port = host->port;
!                 /* Added by Tolyar */
!                 if ( !map->from_port || !use_port ) use_port = rq->url.port;
!             }
!             my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "redir_connect(): Connecting to %s:%d\n", use_name, use_port);
!             rc = str_to_sa(use_name, (struct sockaddr*)&server_sa);
!             server_sa.sin_port = htons(use_port);
!             if ( rc ) /* have no name */
!                 goto try_next_host;
!             fcntl(so, F_SETFL, fcntl(so, F_GETFL, 0) | O_NONBLOCK );
!             rc = connect(so, (struct sockaddr*)&server_sa, sizeof(server_sa));
!             if ( rc == 0 ) {
!                 /* this is ok */
!                 *resulting_so = so;
!                 goto done;
!             }
!             if ( ERRNO == EINPROGRESS ) {
!               /* do timed wait */
!               struct pollarg pollarg;
! 
!                 pollarg.fd = so;
!                 pollarg.request = FD_POLL_WR|FD_POLL_HU;
!                 rc = poll_descriptors(1, &pollarg, dead_timeout*1000);
!                 if ( (rc > 0) && !IS_HUPED(&pollarg) ) {
!                     /* connected */
!                     *resulting_so = so;
!                     goto done;
!                 }
!                 my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "redir_connect(): Connect failed.\n");
!             }
!             if ( so != -1 ) {
!                 close(so);
!                 so = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
!                 if ( so < 0 )
!                     goto done;
!             }
!             host->failed = TRUE;
!             host->last_failed = global_sec_timer;
!         } else {
!             my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "redir_connect(): Host %s failed %d ago. Sleep_timeout=%d\n",
!                 host->name?host->name:"???", 
!                 global_sec_timer-host->last_failed,
!                 sleep_timeout);
!         }
    try_next_host:
          free_url(&tmp_url); bzero(&tmp_url, sizeof(tmp_url));
!         host = host->next;
!         if ( !host ) host = map->to_hosts;
!         max_attempts--;
      }
      UNLOCK_ACCEL_CONFIG ;
      if ( so >= 0 )
!         close(so);
      IF_FREE(src);
      IF_FREE(destination);
      free_url(&tmp_url);
***************
*** 750,758 ****
  {
  struct	map		*map;
  regmatch_t		pmatch[MAXMATCH];
! char			*destination = NULL, *src = NULL, *ohost;
  struct	av		*host_av;
  
      check_map_file_age();
  
      RDLOCK_ACCEL_CONFIG ;
--- 799,811 ----
  {
  struct	map		*map;
  regmatch_t		pmatch[MAXMATCH];
! char            *destination = NULL, *src = NULL, *ohost;
  struct	av		*host_av;
  
+     if ( (rq->meth == METH_PURGE_SITE) || (rq->meth == METH_PURGE_SITE_R) ) {
+         return(redir_control_request(so, group, rq, flags, instance));
+     };
+ 
      check_map_file_age();
  
      RDLOCK_ACCEL_CONFIG ;
***************
*** 763,798 ****
      INIT_PMATCH(pmatch);
      map = find_map(rq, MAXMATCH, pmatch, src);
      if ( map && map->to_hosts)
! 	goto map_found;
  
      if ( deny_proxy_requests ) {
! 	if ( rq && on_my_port(rq) && rq->url.host ) {
! 	    struct	output_object	*output;
! 	    UNLOCK_ACCEL_CONFIG ;
! 	    output = malloc(sizeof(*output));
! 	    if ( output ) {
! 		char	proxy_deny[] = "<body>Proxy access denied<br></body>";
! 		bzero(output, sizeof(*output));
! 		output->body = alloc_buff(128);
! 		put_av_pair(&output->headers,"HTTP/1.0", "400 Access denied");
! 		put_av_pair(&output->headers,"Expires:", "Thu, 01 Jan 1970 00:00:01 GMT");
! 		put_av_pair(&output->headers,"Content-Type:", "text/html");
! 
! 		if ( output->body ) {
! 		    attach_data(proxy_deny, sizeof(proxy_deny), output->body);
! 		}
! 		process_output_object(so, output, rq);
! 		free_output_obj(output);
! 		if ( flags ) *flags |= MOD_AFLAG_OUT;
! 	    }
! 	    return(MOD_CODE_ERR);
! 	}
      }
      goto done;
  map_found:
      if ( map->config_line ) my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "accel/redir(): request matched to %s map `%s'.\n",
! 	mapnames[map->type], map->config_line);
  
      IF_FREE ( rq->original_host );
      rq->original_host = NULL;
      IF_FREE ( rq->original_path );
--- 816,843 ----
      INIT_PMATCH(pmatch);
      map = find_map(rq, MAXMATCH, pmatch, src);
      if ( map && map->to_hosts)
!         goto map_found;
  
      if ( deny_proxy_requests ) {
!         if ( rq && on_my_port(rq) && rq->url.host ) {
!             struct	output_object	*output;
!             UNLOCK_ACCEL_CONFIG ;
!             say_bad_request(so, "Access denied", "No proxy requests allowed", ERR_ACC_DENIED, rq);
!             if ( flags ) *flags |= MOD_AFLAG_OUT;
!             return(MOD_CODE_ERR);
!         }
      }
      goto done;
  map_found:
+ 
      if ( map->config_line ) my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "accel/redir(): request matched to %s map `%s'.\n",
!         mapnames[map->type], map->config_line);
! 
!     if ( map->site_purged != 0 )
!         my_xlog(OOPS_LOG_DBG|OOPS_LOG_INFORM, "accel/redir(): map->site_purged != 0\n");
  
+     rq->site_purged = map->site_purged;
+     
      IF_FREE ( rq->original_host );
      rq->original_host = NULL;
      IF_FREE ( rq->original_path );
***************
*** 868,874 ****
  	    struct	output_object	*output;
  	    output = malloc(sizeof(*output));
  	    if ( output ) {
!                 char redirected[] = "redirected by accel";
                  char *new_location;
                  int  location_len = 0;
  
--- 913,919 ----
  	    struct	output_object	*output;
  	    output = malloc(sizeof(*output));
  	    if ( output ) {
!                 char redirected[] = "redirected by accel\n";
                  char *new_location;
                  int  location_len = 0;
  
***************
*** 932,938 ****
                     else 
                          snprintf(new_location,location_len - 1, "%s://%s%s",rq->url.proto,
                                                         rq->url.host,
-                                                        rq->url.port,
                                                         rq->url.path);
  
                  put_av_pair(&output->headers,"Location:", new_location);
--- 977,982 ----
***************
*** 1047,1052 ****
--- 1091,1142 ----
      return(MOD_CODE_OK);
  }
  
+ int
+ redir_control_request(int so, struct group *group, struct request *rq, int *flags, int instance)
+ {
+ char                    *host;
+ struct  map             *m = 0;
+ regmatch_t              pmatch[MAXMATCH];
+ 
+     if ( (rq->meth != METH_PURGE_SITE) && (rq->meth != METH_PURGE_SITE_R) )
+         return(MOD_CODE_OK);
+     if ( !rq->url.host ) {
+         say_bad_request(so, "Access denied", "Site not allowed for PURGE_SITE", ERR_ACC_DENIED, rq);
+         if ( flags ) SET(*flags, MOD_AFLAG_BRK|MOD_AFLAG_OUT);
+         return(MOD_CODE_ERR);
+     }
+     /* lookup proper map */
+     if ( rq->meth == METH_PURGE_SITE ) {
+         m = lookup_map(0, NULL, rq->url.host, rq->url.port);
+         if ( !m ) {
+             say_bad_request(so, "Access denied", "Site not allowed for PURGE_SITE", ERR_ACC_DENIED, rq);
+             if ( flags ) SET(*flags, MOD_AFLAG_BRK|MOD_AFLAG_OUT);
+             return(MOD_CODE_ERR);
+         }
+         if ( !TEST(m->flags, MAP_CANPURGE) ) {
+             say_bad_request(so, "Access denied", "Site not allowed for PURGE_SITE", ERR_ACC_DENIED, rq);
+             if ( flags ) SET(*flags, MOD_AFLAG_BRK|MOD_AFLAG_OUT);
+             return(MOD_CODE_ERR);
+         }
+         m->site_purged = global_sec_timer;
+         if ( flags ) SET(*flags, MOD_AFLAG_OUT);
+         write(so, "HTTP/1.0 200 PURGED OK\n\n", 24);
+         return(MOD_CODE_OK);
+     }
+     if ( rq->meth == METH_PURGE_SITE_R ) {
+         /* we must set new date on EVERY map which have given destination */
+         int res = set_purge_date_r(0, NULL, rq->url.host, rq->url.port, global_sec_timer);
+         if ( flags ) SET(*flags, MOD_AFLAG_OUT);
+         if ( res == 0 ) {
+             write(so, "HTTP/1.0 200 PURGED NOT OK\n\n", 28);
+         } else {
+             write(so, "HTTP/1.0 200 PURGED OK\n\n", 24);
+         }
+         return(MOD_CODE_OK);
+     }
+     return(MOD_CODE_OK);
+ }
+ 
  static int
  on_my_port(struct request *rq)
  {
***************
*** 1086,1235 ****
  
      port = ntohs(rq->my_sa.sin_port);
      if ( nmyports > 0 ) {
! 	int     n = nmyports;
! 	myport_t *mp = myports;
! 	/* if this is not on my port */
! 	while( n ) {
! 	    /* if ports are equal and addresseses are equal (unless wildcard myport) */
! 	    if (    ( mp->port == port)
! 	         && (   (mp->in_addr.s_addr == INADDR_ANY) 
! 	             || (mp->in_addr.s_addr == rq->my_sa.sin_addr.s_addr)) )
! 	         break;
! 	    n--;mp++;
! 	}
! 	if ( !n ) {
! 	    goto done;  /* not my */
! 	}
      } else
! 	return(NULL);
  
      my_xlog(OOPS_LOG_DBG|OOPS_LOG_INFORM, "find_map(): it's my.\n");
      /* first - take destination from 'Host:'		*/
      if ( rq->original_host ) {
! 	host = rq->original_host;
      } else
! 	host = attr_value(rq->av_pairs, "host");
      if ( host ) {
! 	char	host_buf[MAXHOSTNAMELEN], *o;
  
! 	strncpy(host_buf, host, sizeof(host_buf) - 1);
! 	host_buf[sizeof(host_buf) - 1] = 0;
! 	if ( (o = strchr(host_buf, ':')) ) {
! 	    *o = 0;
! 	    port = (u_short)atoi(o+1);
! 	} else
! 	    port = 80;
! 	/* now host_buf contain host part	*/
! 	if ( (use_host_hash) > 0 && map_hash_table ) {
! 	    char	*t;
! 	    unsigned 	b,o;
! 	    struct map	*this;
! 
! 	    /* lowercase host			*/
! 	    t = host_buf; while ( *t ) { *t = tolower(*t); t++; }
! 	    b = hash_function(host_buf);
! 	    o = ortho_hash_function(host_buf);
! 
! 	    if ( map_hash_table[b].next ) {
! 		/* check this line of hash table */
! 		this = map_hash_table[b].next;
! 		while ( this ) {
! 		    if ( this->ortho != o ) {
! 			this = this->next_in_hash;
! 			continue;
! 		    }
! 		    if (    !strcasecmp(host_buf, this->from_host)
! 			 && (port == this->from_port) ) {
! 			my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Found in hash.\n");
! 			goto hash_found;
! 		    }
! 		    this = this->next_in_hash;
! 		}
! 		/* not found, try with other maps */
! 	    }
! 	    this = other_maps_chain;
! 	    while ( this ) {
! 		/* if rq match this map */
! 		switch ( this->type ) {
! 		case MAP_REGEX_CS:
! 		case MAP_REGEX:
! 		    if ( src && !regexec(&this->preg, src, nmatch, pmatch, 0) ) {
! 			my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in regex map.\n", host);
! 			goto hash_found;
! 		    }
! 		    break;
! 		case MAP_ACL:
! 		    if ( rq_match_named_acl_by_index(rq, this->acl_index)
! 			&& !regexec(&this->preg, src, nmatch, pmatch, 0) ) {
! 			my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in acl map.\n", host);
! 			goto hash_found;
! 		    }
! 		    break;
! 		}
! 		this = this->next_in_hash;
! 	    }
! 	hash_found:
! 	    if ( this ) return(this);
! 	    goto try_addresses;
! 	}
! 	while(map) {
! 	    switch( map->type ) {
          case MAP_EXTERNAL:
! 	case MAP_STRING_CS:
! 	case MAP_STRING:
! 		if ( !strcasecmp(host_buf, map->from_host) && (port == map->from_port) ) {
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in string map.\n", host);
! 		    return(map);
! 		}
! 		break;
! 	case MAP_REGEX_CS:
! 	case MAP_REGEX:
! 		if ( src && !regexec(&map->preg, src, nmatch, pmatch, 0) ) {
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in regex map.\n", host);
! 		    return(map);
! 		}
! 		break;
! 	case MAP_ACL:
! 		if ( rq_match_named_acl_by_index(rq, map->acl_index)
! 		    && !regexec(&map->preg, src, nmatch, pmatch, 0) ) {
! 		    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in acl map.\n", host);
! 		    return(map);
! 		}
! 		break;
! 	default:
! 		my_xlog(OOPS_LOG_SEVERE, "find_map(): Here is unknown map type %d\n", map->type);
! 		break;
! 	    }
! 	    map = map->next;
! 	}
      }
! try_addresses:
      if ( ip_lookup == FALSE )
! 	goto done;
      /* If we didn't find hostname from host - try addresses   */
      map = maps;
      while ( map ) {
! 	if ( map->from_host ) {
! 	    str_to_sa(map->from_host, (struct sockaddr*)&map_sa);
! 	    if ( (map_sa.sin_addr.s_addr == rq->my_sa.sin_addr.s_addr) &&
! 		(!map->from_port || (map->from_port == ntohs(rq->my_sa.sin_port)) ) ) {
! 		my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "find_map(): Map found: %s\n", map->from_host);
! 		break;
! 	    }
! 	}
! 	map = map->next;
      }
  
      if ( !map ) {
! 	if ( !default_map ) goto done;
! 	my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "find_map(): Default used.\n");
! 	map = default_map;
      }
      res = map;
! done:
      return(res);
  }
  
  static void
  parse_map_file(char *p)
  {
--- 1176,1477 ----
  
      port = ntohs(rq->my_sa.sin_port);
      if ( nmyports > 0 ) {
!         int     n = nmyports;
!         myport_t *mp = myports;
!         /* if this is not on my port */
!         while( n ) {
!             /* if ports are equal and addresseses are equal (unless wildcard myport) */
!             if (    ( mp->port == port)
!                  && (   (mp->in_addr.s_addr == INADDR_ANY)
!                      || (mp->in_addr.s_addr == rq->my_sa.sin_addr.s_addr)) )
!                  break;
!             n--;mp++;
!         }
!         if ( !n ) {
!             goto done;  /* not my */
!         }
      } else
!         return(NULL);
  
      my_xlog(OOPS_LOG_DBG|OOPS_LOG_INFORM, "find_map(): it's my.\n");
      /* first - take destination from 'Host:'		*/
      if ( rq->original_host ) {
!         host = rq->original_host;
      } else
!         host = attr_value(rq->av_pairs, "host");
      if ( host ) {
!         char	host_buf[MAXHOSTNAMELEN], *o;
  
!         strncpy(host_buf, host, sizeof(host_buf) - 1);
!         host_buf[sizeof(host_buf) - 1] = 0;
!         if ( (o = strchr(host_buf, ':')) ) {
!             *o = 0;
!             port = (u_short)atoi(o+1);
!         } else
!             port = 80;
!         /* now host_buf contain host part	*/
!         if ( (use_host_hash) > 0 && map_hash_table ) {
!             char	*t;
!             unsigned 	b,o;
!             struct map	*this;
! 
!             /* lowercase host			*/
!             t = host_buf; while ( *t ) { *t = tolower(*t); t++; }
!             b = hash_function(host_buf);
!             o = ortho_hash_function(host_buf);
! 
!             if ( map_hash_table[b].next ) {
!         	/* check this line of hash table */
!         	this = map_hash_table[b].next;
!         	while ( this ) {
!         	    if ( this->ortho != o ) {
!         		this = this->next_in_hash;
!         		continue;
!         	    }
!         	    if (    !strcasecmp(host_buf, this->from_host)
!         		 && (port == this->from_port) ) {
!         		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Found in hash.\n");
!         		goto hash_found;
!         	    }
!         	    this = this->next_in_hash;
!         	}
!         	/* not found, try with other maps */
!             }
!             this = other_maps_chain;
!             while ( this ) {
!         	/* if rq match this map */
!         	switch ( this->type ) {
!         	case MAP_EXTERNAL:
!                 case MAP_STRING_CS:
!                 case MAP_STRING:
!         	    if ( !strcasecmp(host_buf, map->from_host) && (port == map->from_port) ) {
!         	        my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in string map.\n", host);
!         	        return(map);
!         	    }
!         	    break;
! 
!         	case MAP_REGEX_CS:
!         	case MAP_REGEX:
!         	    if ( src && !regexec(&this->preg, src, nmatch, pmatch, 0) ) {
!         		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in regex map.\n", host);
!         		goto hash_found;
!         	    }
!         	    break;
!         	case MAP_ACL:
!         	    if ( rq_match_named_acl_by_index(rq, this->acl_index)
!         		&& !regexec(&this->preg, src, nmatch, pmatch, 0) ) {
!         		my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in acl map.\n", host);
!         		goto hash_found;
!         	    }
!         	    break;
!         	}
!         	this = this->next_in_hash;
!             }
!         hash_found:
!             if ( this ) return(this);
!             goto try_addresses;
!         }
!         while(map) {
!             switch( map->type ) {
          case MAP_EXTERNAL:
!         case MAP_STRING_CS:
!         case MAP_STRING:
!         	if ( !strcasecmp(host_buf, map->from_host) && (port == map->from_port) ) {
!         	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in string map.\n", host);
!         	    return(map);
!         	}
!         	break;
!         case MAP_REGEX_CS:
!         case MAP_REGEX:
!         	if ( src && !regexec(&map->preg, src, nmatch, pmatch, 0) ) {
!         	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in regex map.\n", host);
!         	    return(map);
!         	}
!         	break;
!         case MAP_ACL:
!         	if ( rq_match_named_acl_by_index(rq, map->acl_index)
!         	    && !regexec(&map->preg, src, nmatch, pmatch, 0) ) {
!         	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in acl map.\n", host);
!         	    return(map);
!         	}
!         	break;
!         default:
!         	my_xlog(OOPS_LOG_SEVERE, "find_map(): Here is unknown map type %d\n", map->type);
!         	break;
!             }
!             map = map->next;
!         }
      }
!  try_addresses:
      if ( ip_lookup == FALSE )
!         goto done;
      /* If we didn't find hostname from host - try addresses   */
      map = maps;
      while ( map ) {
!         if ( map->from_host ) {
!             str_to_sa(map->from_host, (struct sockaddr*)&map_sa);
!             if ( (map_sa.sin_addr.s_addr == rq->my_sa.sin_addr.s_addr) &&
!         	(!map->from_port || (map->from_port == ntohs(rq->my_sa.sin_port)) ) ) {
!         	my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "find_map(): Map found: %s\n", map->from_host);
!         	break;
!             }
!         }
!         map = map->next;
      }
  
      if ( !map ) {
!         if ( !default_map ) goto done;
!         my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "find_map(): Default used.\n");
!         map = default_map;
      }
      res = map;
!  done:
      return(res);
  }
  
+ static int
+ set_purge_date_r(size_t nmatch, regmatch_t pmatch[], char *src, u_short port, time_t date)
+ {
+ char    *host;
+ char    host_buf[MAXHOSTNAMELEN], *o;
+ int     res = 0;
+ 
+     strncpy(host_buf, src, sizeof(host_buf) - 1);
+ 
+     host_buf[sizeof(host_buf) - 1] = 0;
+ 
+     /* now host_buf contain host part	*/
+     if ( (use_host_hash) > 0 && reverse_hash_table ) {
+         char            *t;
+         unsigned        b,o;
+         struct map      *this;
+ 
+         /* lowercase host                       */
+         t = host_buf;
+         while ( *t ) {
+             *t = tolower(*t); t++;
+         }
+         b = hash_function(host_buf);
+         o = ortho_hash_function(host_buf);
+         if ( reverse_hash_table[b].next ) {
+             /* check this line of hash table */
+             this = reverse_hash_table[b].next;
+             while ( this ) {
+                 if ( this->reverse_ortho != o ) {
+                     this = this->next_in_hash;
+                     continue;
+                 }
+                 if ( !strcmp(host_buf, this->to_hosts->name)
+                      && (port == this->to_hosts->port)
+                      && TEST(this->flags, MAP_CANPURGE_R) ) {
+                     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "lookup_map(): Found in reverse hash.\n");
+                     this->site_purged = date;
+                     res++;
+                 }
+                 this = this->next_in_reverse_hash;
+             }
+         }
+         return(res);
+     }
+     return(0);
+ }
+ 
+ static struct map *
+ lookup_map(size_t nmatch, regmatch_t pmatch[], char *src, u_short port)
+ {
+ struct  map             *res = NULL, *map = maps;
+ char                    *host;
+ char    host_buf[MAXHOSTNAMELEN], *o;
+ 
+     strncpy(host_buf, src, sizeof(host_buf) - 1);
+ 
+     host_buf[sizeof(host_buf) - 1] = 0;
+ 
+     /* now host_buf contain host part	*/
+     if ( (use_host_hash) > 0 && map_hash_table ) {
+         char            *t;
+         unsigned        b,o;
+         struct map      *this;
+ 
+         /* lowercase host                       */
+         t = host_buf;
+         while ( *t ) {
+             *t = tolower(*t); t++;
+         }
+         b = hash_function(host_buf);
+         o = ortho_hash_function(host_buf);
+ 
+         if ( map_hash_table[b].next ) {
+         /* check this line of hash table */
+                 this = map_hash_table[b].next;
+                 while ( this ) {
+                     if ( this->ortho != o ) {
+                         this = this->next_in_hash;
+                         continue;
+                     }
+                     if (    !strcasecmp(host_buf, this->from_host)
+                          && (port == this->from_port) ) {
+                         my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "lookup_map(): Found in hash.\n");
+                         goto hash_found;
+                     }
+                     this = this->next_in_hash;
+                 }
+                 /* not found, try with other maps */
+         }
+         this = other_maps_chain;
+         while ( this ) {
+           /* if rq match this map */
+           switch ( this->type ) {
+             case MAP_EXTERNAL:
+             case MAP_STRING_CS:
+             case MAP_STRING:
+                 if ( !strcasecmp(host_buf, map->from_host) && (port == map->from_port) ) {
+                     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "lookup_map(): Host %s found in string map.\n", host_buf);
+                     return(map);
+                 }
+                 break;
+ 
+             case MAP_REGEX_CS:
+             case MAP_REGEX:
+                 if ( src && !regexec(&this->preg, src, nmatch, pmatch, 0) ) {
+                     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "lookup_map(): Host %s found in regex map.\n", host_buf);
+                     goto hash_found;
+                 }
+                 break;
+             }
+             this = this->next_in_hash;
+         }
+     hash_found:
+         return(this);
+     }
+     while(map) {
+         switch( map->type ) {
+     case MAP_EXTERNAL:
+     case MAP_STRING_CS:
+     case MAP_STRING:
+     	if ( !strcasecmp(host_buf, map->from_host) && (port == map->from_port) ) {
+     	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in string map.\n", host_buf);
+     	    return(map);
+     	}
+     	break;
+     case MAP_REGEX_CS:
+     case MAP_REGEX:
+     	if ( src && !regexec(&map->preg, src, nmatch, pmatch, 0) ) {
+     	    my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "find_map(): Host %s found in regex map.\n", host_buf);
+     	    return(map);
+     	}
+     	break;
+     default:
+     	my_xlog(OOPS_LOG_SEVERE, "find_map(): Here is unknown map type %d\n", map->type);
+     	break;
+         }
+         map = map->next;
+     }
+     res = map;
+  done:
+     return(res);
+  }
+ 
  static void
  parse_map_file(char *p)
  {
***************
*** 1241,1247 ****
      verb_printf("parse_map_file(): Use %s as mapfile.\n", map_file);
  }
  
! static void
  parse_map(char *p)
  {
  char		*s, *d, *o;
--- 1483,1569 ----
      verb_printf("parse_map_file(): Use %s as mapfile.\n", map_file);
  }
  
! static  void
! set_canpurge(char *p)
! {
! /* "canpurge line"
!    look up map to which line can be matched, then set
!    flag in this map that it can contain time for site_purge
! */
! struct  map *m;
! char        *pptr;
! u_short     port = 80;
! 
!     p+=8;
!     while (*p && IS_SPACE(*p) ) p++;
!     if ( *p == 0 ) return;
!     if ( pptr = strchr(p, ':') ) {
!         *pptr = 0;
!         port = atoi(pptr+1);
!     }
!     m = lookup_map(0, NULL, p, port);
!     if ( m ) {
!         m->flags |= MAP_CANPURGE;
!     }
! }
! 
! static  void
! set_canpurge_r(char *p)
! {
! /* "canpurge line"
!    look up map to which line can be matched, then set
!    flag in this map that it can contain time for site_purge
! */
! struct  map *m;
! char        *pptr;
! u_short     port = 80;
! char        host_buf[MAXHOSTNAMELEN];
! 
!     p+=10;
!     while (*p && IS_SPACE(*p) ) p++;
!     if ( *p == 0 ) return;
!     if ( pptr = strchr(p, ':') ) {
!         *pptr = 0;
!         port = atoi(pptr+1);
!     }
! 
!     strncpy(host_buf, p, sizeof(host_buf) - 1);
! 
!     host_buf[sizeof(host_buf) - 1] = 0;
! 
!     /* now host_buf contain host part	*/
!     if ( (use_host_hash) > 0 && reverse_hash_table ) {
!         char            *t;
!         unsigned        b,o;
!         struct map      *this;
! 
!         /* lowercase host                       */
!         t = host_buf;
!         while ( *t ) {
!             *t = tolower(*t); t++;
!         }
!         b = hash_function(host_buf);
!         o = ortho_hash_function(host_buf);
!         if ( reverse_hash_table[b].next ) {
!             /* check this line of hash table */
!             this = reverse_hash_table[b].next;
!             while ( this ) {
!                 if ( this->reverse_ortho != o ) {
!                     this = this->next_in_hash;
!                     continue;
!                 }
!                 if ( !strcmp(host_buf, this->to_hosts->name)
!                      && (port == this->to_hosts->port) ) {
!                     my_xlog(OOPS_LOG_HTTP|OOPS_LOG_DBG, "lookup_map(): Found in reverse hash.\n");
!                     this->flags |= MAP_CANPURGE_R;
!                 }
!                 this = this->next_in_reverse_hash;
!             }
!         }
!     }
! }
! 
! static  void
  parse_map(char *p)
  {
  char		*s, *d, *o;
***************
*** 1253,1263 ****
      /* map from[:port] to1[:port1] to2[:port2] ... */
      p += 3;
      if ( *p == '/' ) {
! 	p++;
! 	/* switch */
! 	if ( tolower(*p) == 'r' )
! 	    flags |= MAP_REVERSE;
! 	while (*p && !IS_SPACE(*p) ) p++;
      }
      while (*p && IS_SPACE(*p) ) p++;
      config_line = strdup(p);
--- 1575,1585 ----
      /* map from[:port] to1[:port1] to2[:port2] ... */
      p += 3;
      if ( *p == '/' ) {
!         p++;
!         /* switch */
!         if ( tolower(*p) == 'r' )
!             flags |= MAP_REVERSE;
!         while (*p && !IS_SPACE(*p) ) p++;
      }
      while (*p && IS_SPACE(*p) ) p++;
      config_line = strdup(p);
***************
*** 1580,1596 ****
      while ( *s && !IS_SPACE(*s) ) s++;
      p = s;
      if ( strlen(buf) ) {
! 	map = new_map();
! 	if ( !map ) goto done;
! 	bzero(map, sizeof(*map));
          map->config_line = config_line; config_line = NULL;
! 	map->type = MAP_REGEX;
! 	map->flags |= flags;
! 	if (regcomp(&map->preg, buf, REG_EXTENDED|REG_ICASE)) {
! 	    verb_printf("parse_map_regex(): Cant regcomp %s\n", buf);
! 	    free(map);
! 	    goto done;
! 	}
  do_next_host:
  	while (*p && IS_SPACE(*p) ) p++;
  	if ( !*p ) {
--- 1902,1918 ----
      while ( *s && !IS_SPACE(*s) ) s++;
      p = s;
      if ( strlen(buf) ) {
!         map = new_map();
!         if ( !map ) goto done;
!         bzero(map, sizeof(*map));
          map->config_line = config_line; config_line = NULL;
!         map->type = MAP_REGEX;
!         map->flags |= flags;
!         if (regcomp(&map->preg, buf, REG_EXTENDED|REG_ICASE)) {
!             verb_printf("parse_map_regex(): Cant regcomp %s\n", buf);
!             free(map);
!             goto done;
!         }
  do_next_host:
  	while (*p && IS_SPACE(*p) ) p++;
  	if ( !*p ) {
***************
*** 2322,2328 ****
      mf = fopen(map_file, "r");
      if ( !mf ) {
  	verb_printf("reload_map_file(): Can't fopen %s: %m", map_file);
!         my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "reload_map_file(): Can't fopen %s: %m", map_file);
  	goto done;
      }
      map_file_mtime = sb.st_mtime;
--- 2644,2650 ----
      mf = fopen(map_file, "r");
      if ( !mf ) {
  	verb_printf("reload_map_file(): Can't fopen %s: %m", map_file);
!         my_xlog(OOPS_LOG_NOTICE|OOPS_LOG_DBG|OOPS_LOG_INFORM, "reload_map_file(): Can't fopen %s: %m\n", map_file);
  	goto done;
      }
      map_file_mtime = sb.st_mtime;
***************
*** 2348,2353 ****
--- 2670,2676 ----
      }
      if ( use_host_hash ) {
  	map_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
+         reverse_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
      }
      other_maps_chain = NULL;
  
***************
*** 2386,2391 ****
--- 2709,2717 ----
  		if ( map_hash_table )
  		    free(map_hash_table);
  		map_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
+ 		if ( reverse_hash_table )
+ 		    free(reverse_hash_table);
+ 		reverse_hash_table = calloc(use_host_hash, sizeof(*map_hash_table));
  	    }
  	} else
  	if ( !strncasecmp(p, "rewrite_host", 12) ) {
***************
*** 2455,2462 ****
  	if ( !strncasecmp(p, "map_external_regex", 18) )
  	    parse_map_external_regex(p);
  	else
! 	if ( !strncasecmp(p, "map", 3) )
! 	    parse_map(p);
      }
      if ( mf ) fclose(mf);
  done:
--- 2781,2794 ----
  	if ( !strncasecmp(p, "map_external_regex", 18) )
  	    parse_map_external_regex(p);
  	else
!         if ( !strncasecmp(p, "canpurge/r", 10) )
!             set_canpurge_r(p);
!         else
!         if ( !strncasecmp(p, "canpurge", 8) )
!             set_canpurge(p);
!         else
!         if ( !strncasecmp(p, "map", 3) )
!             parse_map(p);
      }
      if ( mf ) fclose(mf);
  done:
Index: src/modules/pam.c
===================================================================
RCS file: /usr/local/cvs/oops/src/modules/pam.c,v
retrieving revision 1.11
retrieving revision 1.12
diff -c -r1.11 -r1.12
*** pam.c	2001/08/14 05:20:51	1.11
--- pam.c	2002/03/09 17:46:54	1.12
***************
*** 101,107 ****
  
  static	char	*authreq = NULL;
  static	int	 authreqlen;
! static	char	*authreqfmt = "%s realm=%s";
  static	char	*std_template = "\n<body>Authorization to proxy-server failed.<p><hr>\n\
  <i><font size=-1>by \'pam\' module to Oops.";
  static	int	std_template_len;
--- 101,107 ----
  
  static	char	*authreq = NULL;
  static	int	 authreqlen;
! static	char	*authreqfmt = "%s realm=\"%s\"";
  static	char	*std_template = "\n<body>Authorization to proxy-server failed.<p><hr>\n\
  <i><font size=-1>by \'pam\' module to Oops.";
  static	int	std_template_len;
***************
*** 109,115 ****
  static	int	badschlen;
  static	char	*badsch=NULL;
  static	char	*badschfmt = "HTTP/1.0 407 Proxy Authentication required\n\
! Proxy-Authenticate: %s realm=%s\n\n\
  <body>Authorization to proxy-server failed.<p>\n\
  Your browser proposed unsupported scheme\n\
  <hr>\n\
--- 109,115 ----
  static	int	badschlen;
  static	char	*badsch=NULL;
  static	char	*badschfmt = "HTTP/1.0 407 Proxy Authentication required\n\
! Proxy-Authenticate: %s realm=\"%s\"\n\n\
  <body>Authorization to proxy-server failed.<p>\n\
  Your browser proposed unsupported scheme\n\
  <hr>\n\
Index: src/modules/passwd_file.c
===================================================================
RCS file: /usr/local/cvs/oops/src/modules/passwd_file.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -c -r1.13 -r1.14
*** passwd_file.c	2001/08/13 10:15:45	1.13
--- passwd_file.c	2002/03/09 17:46:54	1.14
***************
*** 75,81 ****
  
  static	char	*authreq = NULL;
  static	int	 authreqlen;
! static	char	*authreqfmt = "%s realm=%s";
  static	char	*std_template = "\n<body>Authorization to proxy-server failed.<p><hr>\n\
  <i><font size=-1>by \'passwd_file\' module to Oops.";
  static	int	std_template_len;
--- 75,81 ----
  
  static	char	*authreq = NULL;
  static	int	 authreqlen;
! static	char	*authreqfmt = "%s realm=\"%s\"";
  static	char	*std_template = "\n<body>Authorization to proxy-server failed.<p><hr>\n\
  <i><font size=-1>by \'passwd_file\' module to Oops.";
  static	int	std_template_len;
***************
*** 83,89 ****
  static	int	badschlen;
  static	char	*badsch=NULL;
  static	char	*badschfmt = "HTTP/1.0 407 Proxy Authentication required\n\
! Proxy-Authenticate: %s realm=%s\n\n\
  <body>Authorization to proxy-server failed.<p>\n\
  Your browser proposed unsupported scheme\n\
  <hr>\n\
--- 83,89 ----
  static	int	badschlen;
  static	char	*badsch=NULL;
  static	char	*badschfmt = "HTTP/1.0 407 Proxy Authentication required\n\
! Proxy-Authenticate: %s realm=\"%s\"\n\n\
  <body>Authorization to proxy-server failed.<p>\n\
  Your browser proposed unsupported scheme\n\
  <hr>\n\
Index: src/modules/passwd_sql.c
===================================================================
RCS file: /usr/local/cvs/oops/src/modules/passwd_sql.c,v
retrieving revision 1.16
retrieving revision 1.17
diff -c -r1.16 -r1.17
*** passwd_sql.c	2002/02/08 10:47:11	1.16
--- passwd_sql.c	2002/03/09 17:46:54	1.17
***************
*** 118,124 ****
  
  static	char	*authreq = NULL;
  static	int	 authreqlen;
! static	char	*authreqfmt = "%s realm=%s";
  static	char	*std_template = 
                "\n<body>Authorization to proxy-server failed.<p><hr>\n"
                "<i><font size=-1>by \'passwd_pgsql\' module to Oops.";
--- 118,124 ----
  
  static	char	*authreq = NULL;
  static	int	 authreqlen;
! static	char	*authreqfmt = "%s realm=\"%s\"";
  static	char	*std_template = 
                "\n<body>Authorization to proxy-server failed.<p><hr>\n"
                "<i><font size=-1>by \'passwd_pgsql\' module to Oops.";
***************
*** 128,134 ****
  static	char	*badsch=NULL;
  static	char	*badschfmt =
                 "HTTP/1.0 407 Proxy Authentication required\n"
!                "Proxy-Authenticate: %s realm=%s\n\n"
                 "<body>Authorization to proxy-server failed.<p>\n"
                 "Your browser proposed unsupported scheme\n"
                 "<hr>\n"
--- 128,134 ----
  static	char	*badsch=NULL;
  static	char	*badschfmt =
                 "HTTP/1.0 407 Proxy Authentication required\n"
!                "Proxy-Authenticate: %s realm=\"%s\"\n\n"
                 "<body>Authorization to proxy-server failed.<p>\n"
                 "Your browser proposed unsupported scheme\n"
                 "<hr>\n"
