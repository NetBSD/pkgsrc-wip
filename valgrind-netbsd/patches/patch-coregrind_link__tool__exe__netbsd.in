$NetBSD$

--- coregrind/link_tool_exe_netbsd.in.orig	2019-03-26 07:40:15.574675987 +0000
+++ coregrind/link_tool_exe_netbsd.in
@@ -0,0 +1,84 @@
+#! @PERL@
+
+# This script handles linking the tool executables on NetBSD,
+# statically and at an alternative load address.
+#
+# Linking statically sidesteps all sorts of complications to do with
+# having two copies of the dynamic linker (valgrind's and the
+# client's) coexisting in the same process.  The alternative load
+# address is needed because Valgrind itself will load the client at
+# whatever address it specifies, which is almost invariably the
+# default load address.  Hence we can't allow Valgrind itself (viz,
+# the tool executable) to be loaded at that address.
+#
+# Unfortunately there's no standard way to do 'static link at
+# alternative address', so these link_tool_exe_*.in scripts handle
+# the per-platform hoop-jumping.
+#
+# What we get passed here is:
+#   first arg
+#      the alternative load address
+#   all the rest of the args
+#      the gcc invocation to do the final link, that
+#      the build system would have done, left to itself
+#
+# We just let the script 'die' if something is wrong, rather than do
+# proper error reporting.  We don't expect the users to run this 
+# directly.  It is only run as part of the build process, with 
+# carefully constrained inputs.
+#
+# Linux specific complications:
+#
+# - need to support both old GNU ld and gold: use -Ttext= to
+#   set the text segment address if that is all we have. We really
+#   need -Ttext-segment. Otherwise with GNU ld sections or notes
+#   (like the build-id) don't get at the desired address. But older
+#   linkers only know about -Ttext, not -Ttext-segment. So configure
+#   checks for us and sets FLAG_T_TEXT.
+#
+# - If all we have is -Ttext, then we need to pass --build-id=none
+#   (that is, -Wl,--build-id=none to gcc) if it accepts it, to ensure
+#   the linker doesn't add a notes section which ends up at the default
+#   load address and so defeats our attempts to keep that address clear
+#   for the client.  However, older linkers don't support this flag,
+#   so it is tested for by configure.in and is shipped to us as part of
+#   argv[2 ..].
+#
+# So: what we actually do:
+# 
+#   pass the specified command to the linker as-is, except, add
+#   "-static" and "-Ttext[-segment]=<argv[1]>" to it.
+#   Previously we did this by adding these options after the first
+#   word of the rest of the arguments, which works in the common case
+#   when it's something like "gcc". But the linker invocation itself
+#   might be multiple words, say if it's "ccache gcc". So we now put
+#   the new options at the end instead.
+#
+
+use warnings;
+use strict;
+
+# expect at least: alt-load-address gcc -o foo bar.o
+die "Not enough arguments"
+    if (($#ARGV + 1) < 5);
+
+my $ala = $ARGV[0];
+shift; # Remove $ala from @ARGV
+
+# check for plausible-ish alt load address
+die "Bogus alt-load address"
+    if (length($ala) < 3 || index($ala, "0x") != 0);
+
+my $cmd = join(" ", @ARGV, "-static -Wl,@FLAG_T_TEXT@=$ala");
+
+#print "link_tool_exe_netbsd: $cmd\n";
+
+
+# Execute the command:
+my $r = system($cmd);
+
+if ($r == 0) {
+    exit 0;
+} else {
+    exit 1;
+}
